<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>什么是Spring Security | 不学习会被杀掉的！</title><meta name="keywords" content="spring源码"><meta name="author" content="章志成"><meta name="copyright" content="章志成"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Spring Security教程 相对于 Shiro，在 SSM&#x2F;SSH 中整合 Spring Security 都是比较麻烦的操作，所以，Spring Security 虽然功能比 Shiro 强大，但是使用反而没有 Shiro 多（Shiro 虽然功能没有 Spring Security 多，但是对于大部分项目而言，Shiro 也够用了）。 自从有了 Spring Boot 之后，Sprin"><meta property="og:type" content="article"><meta property="og:title" content="什么是Spring Security"><meta property="og:url" content="http://example.com/20200709/%E4%BB%80%E4%B9%88%E6%98%AFSpringSecurity/index.html"><meta property="og:site_name" content="不学习会被杀掉的！"><meta property="og:description" content="Spring Security教程 相对于 Shiro，在 SSM&#x2F;SSH 中整合 Spring Security 都是比较麻烦的操作，所以，Spring Security 虽然功能比 Shiro 强大，但是使用反而没有 Shiro 多（Shiro 虽然功能没有 Spring Security 多，但是对于大部分项目而言，Shiro 也够用了）。 自从有了 Spring Boot 之后，Sprin"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://hankz.oss-cn-hangzhou.aliyuncs.com/wallhaven-6k93rq.jpg"><meta property="article:published_time" content="2020-07-09T15:31:18.000Z"><meta property="article:modified_time" content="2022-05-15T07:31:42.782Z"><meta property="article:author" content="章志成"><meta property="article:tag" content="spring源码"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://hankz.oss-cn-hangzhou.aliyuncs.com/wallhaven-6k93rq.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/20200709/%E4%BB%80%E4%B9%88%E6%98%AFSpringSecurity/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-left"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isanchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-05-15 15:31:42"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0!==o){const a=new Date;o=864e5*o,t={value:t,expiry:a.getTime()+o};localStorage.setItem(e,JSON.stringify(t))}},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);const o=new Date;if(!(o.getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=a=>new Promise((t,e)=>{const o=document.createElement("script");o.src=a,o.async=!0,o.onerror=e,o.onload=o.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(o.onload=o.onreadystatechange=null,t())},document.head.appendChild(o)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"))})(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/tx2.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-messageboard"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(http://hankz.oss-cn-hangzhou.aliyuncs.com/wallhaven-6k93rq.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">不学习会被杀掉的！</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-messageboard"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">什么是Spring Security</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-09T15:31:18.000Z" title="发表于 2020-07-09 23:31:18">2020-07-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-15T07:31:42.782Z" title="更新于 2022-05-15 15:31:42">2022-05-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/spring/">spring</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="什么是Spring Security"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/20200709/%E4%BB%80%E4%B9%88%E6%98%AFSpringSecurity/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/20200709/%E4%BB%80%E4%B9%88%E6%98%AFSpringSecurity/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Spring-Security教程"><a href="#Spring-Security教程" class="headerlink" title="Spring Security教程"></a>Spring Security教程</h1><hr><p>相对于 Shiro，在 SSM/SSH 中整合 Spring Security 都是比较麻烦的操作，所以，Spring Security 虽然功能比 Shiro 强大，但是使用反而没有 Shiro 多（Shiro 虽然功能没有 Spring Security 多，但是对于大部分项目而言，Shiro 也够用了）。</p><p>自从有了 Spring Boot 之后，Spring Boot 对于 Spring Security 提供了 自动化配置方案，可以零配置使用 Spring Security。</p><p>因此，一般来说，常见的安全管理技术栈的组合是这样的：</p><ul><li>SSM + Shiro</li><li>Spring Boot/Spring Cloud + Spring Security</li></ul><h1 id="1-项目创建"><a href="#1-项目创建" class="headerlink" title="1.项目创建"></a>1.项目创建</h1><p>pom.xml 中的 Spring Security 依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>只要加入依赖，项目的所有接口都会被自动保护起来。</p><h1 id="2-初次体验"><a href="#2-初次体验" class="headerlink" title="2.初次体验"></a>2.初次体验</h1><p>我们创建一个 HelloController:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @GetMapping(&quot;&#x2F;hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问 <code>/hello</code> ，需要登录之后才能访问。</p><p><img src="http://www.javaboy.org/images/boot/25-2.png" alt="img"></p><p>当用户从浏览器发送请求访问 <code>/hello</code> 接口时，服务端会返回 <code>302</code> 响应码，让客户端重定向到 <code>/login</code> 页面，用户在 <code>/login</code> 页面登录，登陆成功之后，就会自动跳转到 <code>/hello</code> 接口。</p><p>另外，也可以使用 <code>POSTMAN</code> 来发送请求，使用 <code>POSTMAN</code> 发送请求时，可以将用户信息放在请求头中（这样可以避免重定向到登录页面）：</p><p><img src="http://www.javaboy.org/images/boot/25-3.png" alt="img"></p><p>通过以上两种不同的登录方式，可以看出，Spring Security 支持两种不同的认证方式：</p><ul><li>可以通过 form 表单来认证</li><li>可以通过 HttpBasic 来认证</li></ul><h1 id="3-用户名配置"><a href="#3-用户名配置" class="headerlink" title="3.用户名配置"></a>3.用户名配置</h1><p>默认情况下，登录的用户名是 <code>user</code> ，密码则是项目启动时随机生成的字符串，可以从启动的控制台日志中看到默认密码：</p><p><img src="http://www.javaboy.org/images/boot/25-4.png" alt="img"></p><p>这个随机生成的密码，每次启动时都会变。对登录的用户名/密码进行配置，有三种不同的方式：</p><ul><li>在 application.properties 中进行配置</li><li>通过 Java 代码配置在内存中</li><li>通过 Java 从数据库中加载</li></ul><h2 id="3-1-配置文件配置用户名-密码"><a href="#3-1-配置文件配置用户名-密码" class="headerlink" title="3.1 配置文件配置用户名/密码"></a>3.1 配置文件配置用户名/密码</h2><p>可以直接在 application.properties 文件中配置用户的基本信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.security.user.name&#x3D;javaboy</span><br><span class="line">spring.security.user.password&#x3D;123</span><br></pre></td></tr></table></figure><p>配置完成后，重启项目，就可以使用这里配置的用户名/密码登录了。</p><h2 id="3-2-Java-配置用户名-密码"><a href="#3-2-Java-配置用户名-密码" class="headerlink" title="3.2 Java 配置用户名/密码"></a>3.2 Java 配置用户名/密码</h2><p>也可以在 Java 代码中配置用户名密码，首先需要我们创建一个 Spring Security 的配置类，集成自 WebSecurityConfigurerAdapter 类，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;下面这两行配置表示在内存中配置了两个用户</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(&quot;javaboy&quot;).roles(&quot;admin&quot;).password(&quot;$2a$10$OR3VSksVAmCzc.7WeaRPR.t0wyCsIj24k0Bne8iKWV1o.V9wsP8Xe&quot;)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(&quot;lisi&quot;).roles(&quot;user&quot;).password(&quot;$2a$10$p1H8iWa8I4.CA.7Z8bwLjes91ZpY.rYREGHQEInNtAp4NzL6PLKxi&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Bean</span><br><span class="line">    PasswordEncoder passwordEncoder() &#123;</span><br><span class="line">        return new BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们在 configure 方法中配置了两个用户，用户的密码都是加密之后的字符串(明文是 123)，从 Spring5 开始，强制要求密码要加密，如果非不想加密，可以使用一个过期的 PasswordEncoder 的实例 NoOpPasswordEncoder，但是不建议这么做，毕竟不安全。</p><p>Spring Security 中提供了 BCryptPasswordEncoder 密码编码工具，可以非常方便的实现密码的加密加盐，相同明文加密出来的结果总是不同，这样就不需要用户去额外保存<code>盐</code>的字段了，这一点比 Shiro 要方便很多。</p><h1 id="4-登录配置"><a href="#4-登录配置" class="headerlink" title="4.登录配置"></a>4.登录配置</h1><p>对于登录接口，登录成功后的响应，登录失败后的响应，我们都可以在 WebSecurityConfigurerAdapter 的实现类中进行配置。例如下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    VerifyCodeFilter verifyCodeFilter;</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.addFilterBefore(verifyCodeFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">        http</span><br><span class="line">        .authorizeRequests()&#x2F;&#x2F;开启登录配置</span><br><span class="line">        .antMatchers(&quot;&#x2F;hello&quot;).hasRole(&quot;admin&quot;)&#x2F;&#x2F;表示访问 &#x2F;hello 这个接口，需要具备 admin 这个角色</span><br><span class="line">        .anyRequest().authenticated()&#x2F;&#x2F;表示剩余的其他接口，登录之后就能访问</span><br><span class="line">        .and()</span><br><span class="line">        .formLogin()</span><br><span class="line">        &#x2F;&#x2F;定义登录页面，未登录时，访问一个需要登录之后才能访问的接口，会自动跳转到该页面</span><br><span class="line">        .loginPage(&quot;&#x2F;login_p&quot;)</span><br><span class="line">        &#x2F;&#x2F;登录处理接口</span><br><span class="line">        .loginProcessingUrl(&quot;&#x2F;doLogin&quot;)</span><br><span class="line">        &#x2F;&#x2F;定义登录时，用户名的 key，默认为 username</span><br><span class="line">        .usernameParameter(&quot;uname&quot;)</span><br><span class="line">        &#x2F;&#x2F;定义登录时，用户密码的 key，默认为 password</span><br><span class="line">        .passwordParameter(&quot;passwd&quot;)</span><br><span class="line">        &#x2F;&#x2F;登录成功的处理器</span><br><span class="line">        .successHandler(new AuthenticationSuccessHandler() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onAuthenticationSuccess(HttpServletRequest req, HttpServletResponse resp, Authentication authentication) throws IOException, ServletException &#123;</span><br><span class="line">                    resp.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);</span><br><span class="line">                    PrintWriter out &#x3D; resp.getWriter();</span><br><span class="line">                    out.write(&quot;success&quot;);</span><br><span class="line">                    out.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .failureHandler(new AuthenticationFailureHandler() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onAuthenticationFailure(HttpServletRequest req, HttpServletResponse resp, AuthenticationException exception) throws IOException, ServletException &#123;</span><br><span class="line">                    resp.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);</span><br><span class="line">                    PrintWriter out &#x3D; resp.getWriter();</span><br><span class="line">                    out.write(&quot;fail&quot;);</span><br><span class="line">                    out.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .permitAll()&#x2F;&#x2F;和表单登录相关的接口统统都直接通过</span><br><span class="line">            .and()</span><br><span class="line">            .logout()</span><br><span class="line">            .logoutUrl(&quot;&#x2F;logout&quot;)</span><br><span class="line">            .logoutSuccessHandler(new LogoutSuccessHandler() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onLogoutSuccess(HttpServletRequest req, HttpServletResponse resp, Authentication authentication) throws IOException, ServletException &#123;</span><br><span class="line">                    resp.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);</span><br><span class="line">                    PrintWriter out &#x3D; resp.getWriter();</span><br><span class="line">                    out.write(&quot;logout success&quot;);</span><br><span class="line">                    out.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .httpBasic()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在 successHandler 方法中，配置登录成功的回调，如果是前后端分离开发的话，登录成功后返回 JSON 即可，同理，failureHandler 方法中配置登录失败的回调，logoutSuccessHandler 中则配置注销成功的回调。</p><h1 id="5-忽略拦截"><a href="#5-忽略拦截" class="headerlink" title="5.忽略拦截"></a>5.忽略拦截</h1><p>如果某一个请求地址不需要拦截的话，有两种方式实现：</p><ul><li>设置该地址匿名访问</li><li>直接过滤掉该地址，即该地址不走 Spring Security 过滤器链</li></ul><p>推荐使用第二种方案，配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void configure(WebSecurity web) throws Exception &#123;</span><br><span class="line">        web.ignoring().antMatchers(&quot;&#x2F;vercode&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Security 另外一个强大之处就是它可以结合 OAuth2 ，玩出更多的花样出来。</p><hr><hr><h1 id="Spring-Security-登录添加验证码"><a href="#Spring-Security-登录添加验证码" class="headerlink" title="Spring Security 登录添加验证码"></a>Spring Security 登录添加验证码</h1><h1 id="准备验证码"><a href="#准备验证码" class="headerlink" title="准备验证码"></a>准备验证码</h1><p>要有验证码，首先得先准备好验证码，本文采用 Java 自画的验证码，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 生成验证码的工具类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class VerifyCode &#123;</span><br><span class="line"></span><br><span class="line">	private int width &#x3D; 100;&#x2F;&#x2F; 生成验证码图片的宽度</span><br><span class="line">	private int height &#x3D; 50;&#x2F;&#x2F; 生成验证码图片的高度</span><br><span class="line">	private String[] fontNames &#x3D; &#123; &quot;宋体&quot;, &quot;楷体&quot;, &quot;隶书&quot;, &quot;微软雅黑&quot; &#125;;</span><br><span class="line">	private Color bgColor &#x3D; new Color(255, 255, 255);&#x2F;&#x2F; 定义验证码图片的背景颜色为白色</span><br><span class="line">	private Random random &#x3D; new Random();</span><br><span class="line">	private String codes &#x3D; &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;</span><br><span class="line">	private String text;&#x2F;&#x2F; 记录随机字符串</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 获取一个随意颜色</span><br><span class="line">	 * </span><br><span class="line">	 * @return</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	private Color randomColor() &#123;</span><br><span class="line">		int red &#x3D; random.nextInt(150);</span><br><span class="line">		int green &#x3D; random.nextInt(150);</span><br><span class="line">		int blue &#x3D; random.nextInt(150);</span><br><span class="line">		return new Color(red, green, blue);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 获取一个随机字体</span><br><span class="line">	 * </span><br><span class="line">	 * @return</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	private Font randomFont() &#123;</span><br><span class="line">		String name &#x3D; fontNames[random.nextInt(fontNames.length)];</span><br><span class="line">		int style &#x3D; random.nextInt(4);</span><br><span class="line">		int size &#x3D; random.nextInt(5) + 24;</span><br><span class="line">		return new Font(name, style, size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 获取一个随机字符</span><br><span class="line">	 * </span><br><span class="line">	 * @return</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	private char randomChar() &#123;</span><br><span class="line">		return codes.charAt(random.nextInt(codes.length()));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 创建一个空白的BufferedImage对象</span><br><span class="line">	 * </span><br><span class="line">	 * @return</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	private BufferedImage createImage() &#123;</span><br><span class="line">		BufferedImage image &#x3D; new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">		Graphics2D g2 &#x3D; (Graphics2D) image.getGraphics();</span><br><span class="line">		g2.setColor(bgColor);&#x2F;&#x2F; 设置验证码图片的背景颜色</span><br><span class="line">		g2.fillRect(0, 0, width, height);</span><br><span class="line">		return image;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public BufferedImage getImage() &#123;</span><br><span class="line">		BufferedImage image &#x3D; createImage();</span><br><span class="line">		Graphics2D g2 &#x3D; (Graphics2D) image.getGraphics();</span><br><span class="line">		StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">			String s &#x3D; randomChar() + &quot;&quot;;</span><br><span class="line">			sb.append(s);</span><br><span class="line">			g2.setColor(randomColor());</span><br><span class="line">			g2.setFont(randomFont());</span><br><span class="line">			float x &#x3D; i * width * 1.0f &#x2F; 4;</span><br><span class="line">			g2.drawString(s, x, height - 15);</span><br><span class="line">		&#125;</span><br><span class="line">		this.text &#x3D; sb.toString();</span><br><span class="line">		drawLine(image);</span><br><span class="line">		return image;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 绘制干扰线</span><br><span class="line">	 * </span><br><span class="line">	 * @param image</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	private void drawLine(BufferedImage image) &#123;</span><br><span class="line">		Graphics2D g2 &#x3D; (Graphics2D) image.getGraphics();</span><br><span class="line">		int num &#x3D; 5;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; num; i++) &#123;</span><br><span class="line">			int x1 &#x3D; random.nextInt(width);</span><br><span class="line">			int y1 &#x3D; random.nextInt(height);</span><br><span class="line">			int x2 &#x3D; random.nextInt(width);</span><br><span class="line">			int y2 &#x3D; random.nextInt(height);</span><br><span class="line">			g2.setColor(randomColor());</span><br><span class="line">			g2.setStroke(new BasicStroke(1.5f));</span><br><span class="line">			g2.drawLine(x1, y1, x2, y2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getText() &#123;</span><br><span class="line">		return text;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void output(BufferedImage image, OutputStream out) throws IOException &#123;</span><br><span class="line">		ImageIO.write(image, &quot;JPEG&quot;, out);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个工具类很常见，网上也有很多，就是画一个简单的验证码，通过流将验证码写到前端页面，提供验证码的 Controller 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class VerifyCodeController &#123;</span><br><span class="line">    @GetMapping(&quot;&#x2F;vercode&quot;)</span><br><span class="line">    public void code(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123;</span><br><span class="line">        VerifyCode vc &#x3D; new VerifyCode();</span><br><span class="line">        BufferedImage image &#x3D; vc.getImage();</span><br><span class="line">        String text &#x3D; vc.getText();</span><br><span class="line">        HttpSession session &#x3D; req.getSession();</span><br><span class="line">        session.setAttribute(&quot;index_code&quot;, text);</span><br><span class="line">        VerifyCode.output(image, resp.getOutputStream());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建了一个 VerifyCode 对象，将生成的验证码字符保存到 session 中，然后通过流将图片写到前端，img标签如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;&#x2F;vercode&quot; alt&#x3D;&quot;&quot;&gt;</span><br></pre></td></tr></table></figure><p>展示效果如下：</p><p><img src="http://www.javaboy.org/images/boot/p2-1.png" alt="img"></p><h1 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h1><p>在登陆页展示验证码这个就不需要我多说了，接下来我们来看看如何自定义验证码处理器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class VerifyCodeFilter extends GenericFilterBean &#123;</span><br><span class="line">    private String defaultFilterProcessUrl &#x3D; &quot;&#x2F;doLogin&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)</span><br><span class="line">            throws IOException, ServletException &#123;</span><br><span class="line">        HttpServletRequest request &#x3D; (HttpServletRequest) req;</span><br><span class="line">        HttpServletResponse response &#x3D; (HttpServletResponse) res;</span><br><span class="line">        if (&quot;POST&quot;.equalsIgnoreCase(request.getMethod()) &amp;&amp; defaultFilterProcessUrl.equals(request.getServletPath())) &#123;</span><br><span class="line">            &#x2F;&#x2F; 验证码验证</span><br><span class="line">            String requestCaptcha &#x3D; request.getParameter(&quot;code&quot;);</span><br><span class="line">            String genCaptcha &#x3D; (String) request.getSession().getAttribute(&quot;index_code&quot;);</span><br><span class="line">            if (StringUtils.isEmpty(requestCaptcha))</span><br><span class="line">                throw new AuthenticationServiceException(&quot;验证码不能为空!&quot;);</span><br><span class="line">            if (!genCaptcha.toLowerCase().equals(requestCaptcha.toLowerCase())) &#123;</span><br><span class="line">                throw new AuthenticationServiceException(&quot;验证码错误!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义过滤器继承自 GenericFilterBean ，并实现其中的 doFilter 方法，在 doFilter 方法中，当请求方法是 POST ，并且请求地址是 <code>/doLogin</code> 时，获取参数中的 code 字段值，该字段保存了用户从前端页面传来的验证码，然后获取 session 中保存的验证码，如果用户没有传来验证码，则抛出验证码不能为空异常，如果用户传入了验证码，则判断验证码是否正确，如果不正确则抛出异常，否则执行 <code>chain.doFilter(request, response);</code> 使请求继续向下走。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>最后在 Spring Security 的配置中，配置过滤器，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    VerifyCodeFilter verifyCodeFilter;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.addFilterBefore(verifyCodeFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(&quot;&#x2F;admin&#x2F;**&quot;).hasRole(&quot;admin&quot;)</span><br><span class="line">                ...</span><br><span class="line">                ...</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只贴出了部分核心代码，即 <code>http.addFilterBefore(verifyCodeFilter, UsernamePasswordAuthenticationFilter.class);</code> ，如此之后，整个配置就算完成了。<br>接下来在登录中，就需要传入验证码了，如果不传或者传错，都会抛出异常，例如不传的话，抛出如下异常：</p><p><img src="http://www.javaboy.org/images/boot/p2-2.png" alt="img"></p><hr><h1 id="Spring-Security-登录使用-JSON-格式数据"><a href="#Spring-Security-登录使用-JSON-格式数据" class="headerlink" title="Spring Security 登录使用 JSON 格式数据"></a>Spring Security 登录使用 JSON 格式数据</h1><p>在使用 SpringSecurity 中，大伙都知道默认的登录数据是通过 key/value 的形式来传递的，默认情况下不支持 JSON格式的登录数据，如果有这种需求，就需要自己来解决。</p><p>在说如何使用 JSON 登录之前，我们还是先来看看基本的登录吧，本文为了简单，SpringSecurity 在使用中就不连接数据库了，直接在内存中配置用户名和密码，具体操作步骤如下：</p><ul><li>创建 Spring Boot 工程</li></ul><p>首先创建 SpringBoot 工程，添加 SpringSecurity 依赖，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>添加 Security 配置</li></ul><p>创建 SecurityConfig，完成 SpringSecurity 的配置，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    PasswordEncoder passwordEncoder() &#123;</span><br><span class="line">        return new BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line">        auth.inMemoryAuthentication().withUser(&quot;zhangsan&quot;).password(&quot;$2a$10$2O4EwLrrFPEboTfDOtC0F.RpUMk.3q3KvBHRx7XXKUMLBGjOOBs8q&quot;).roles(&quot;user&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(WebSecurity web) throws Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginProcessingUrl(&quot;&#x2F;doLogin&quot;)</span><br><span class="line">                .successHandler(new AuthenticationSuccessHandler() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onAuthenticationSuccess(HttpServletRequest req, HttpServletResponse resp, Authentication authentication) throws IOException, ServletException &#123;</span><br><span class="line">                        RespBean ok &#x3D; RespBean.ok(&quot;登录成功！&quot;,authentication.getPrincipal());</span><br><span class="line">                        resp.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);</span><br><span class="line">                        PrintWriter out &#x3D; resp.getWriter();</span><br><span class="line">                        out.write(new ObjectMapper().writeValueAsString(ok));</span><br><span class="line">                        out.flush();</span><br><span class="line">                        out.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .failureHandler(new AuthenticationFailureHandler() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onAuthenticationFailure(HttpServletRequest req, HttpServletResponse resp, AuthenticationException e) throws IOException, ServletException &#123;</span><br><span class="line">                        RespBean error &#x3D; RespBean.error(&quot;登录失败&quot;);</span><br><span class="line">                        resp.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);</span><br><span class="line">                        PrintWriter out &#x3D; resp.getWriter();</span><br><span class="line">                        out.write(new ObjectMapper().writeValueAsString(error));</span><br><span class="line">                        out.flush();</span><br><span class="line">                        out.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .loginPage(&quot;&#x2F;login&quot;)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .logout()</span><br><span class="line">                .logoutUrl(&quot;&#x2F;logout&quot;)</span><br><span class="line">                .logoutSuccessHandler(new LogoutSuccessHandler() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onLogoutSuccess(HttpServletRequest req, HttpServletResponse resp, Authentication authentication) throws IOException, ServletException &#123;</span><br><span class="line">                        RespBean ok &#x3D; RespBean.ok(&quot;注销成功！&quot;);</span><br><span class="line">                        resp.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);</span><br><span class="line">                        PrintWriter out &#x3D; resp.getWriter();</span><br><span class="line">                        out.write(new ObjectMapper().writeValueAsString(ok));</span><br><span class="line">                        out.flush();</span><br><span class="line">                        out.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf()</span><br><span class="line">                .disable()</span><br><span class="line">                .exceptionHandling()</span><br><span class="line">                .accessDeniedHandler(new AccessDeniedHandler() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void handle(HttpServletRequest req, HttpServletResponse resp, AccessDeniedException e) throws IOException, ServletException &#123;</span><br><span class="line">                        RespBean error &#x3D; RespBean.error(&quot;权限不足，访问失败&quot;);</span><br><span class="line">                        resp.setStatus(403);</span><br><span class="line">                        resp.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);</span><br><span class="line">                        PrintWriter out &#x3D; resp.getWriter();</span><br><span class="line">                        out.write(new ObjectMapper().writeValueAsString(error));</span><br><span class="line">                        out.flush();</span><br><span class="line">                        out.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的配置虽然有点长，但是很基础，配置含义也比较清晰，首先提供 BCryptPasswordEncoder 作为 PasswordEncoder ，可以实现对密码的自动加密加盐，非常方便，然后提供了一个名为 <code>zhangsan</code> 的用户，密码是 <code>123</code> ，角色是 <code>user</code> ，最后配置登录逻辑，所有的请求都需要登录后才能访问，登录接口是 <code>/doLogin</code> ，用户名的 key 是 username ，密码的 key 是 password ，同时配置登录成功、登录失败以及注销成功、权限不足时都给用户返回JSON提示，另外，这里虽然配置了登录页面为 <code>/login</code> ，实际上这不是一个页面，而是一段 JSON ，在 LoginController 中提供该接口，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@ResponseBody</span><br><span class="line">public class LoginController &#123;</span><br><span class="line">    @GetMapping(&quot;&#x2F;login&quot;)</span><br><span class="line">    public RespBean login() &#123;</span><br><span class="line">        return RespBean.error(&quot;尚未登录，请登录&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @GetMapping(&quot;&#x2F;hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>/login</code> 只是一个 JSON 提示，而不是页面， <code>/hello</code> 则是一个测试接口。</p><p>OK，做完上述步骤就可以开始测试了，运行SpringBoot项目，访问 <code>/hello</code> 接口，结果如下：</p><p><img src="http://www.javaboy.org/images/boot/p1-1.png" alt="img"></p><p>此时先调用登录接口进行登录，如下：</p><p><img src="http://www.javaboy.org/images/boot/p1-2.png" alt="img"></p><p>登录成功后，再去访问 <code>/hello</code> 接口就可以成功访问了。</p><hr><h1 id="使用JSON登录"><a href="#使用JSON登录" class="headerlink" title="使用JSON登录"></a>使用JSON登录</h1><p>上面演示的是一种原始的登录方案，如果想将用户名密码通过 JSON 的方式进行传递，则需要自定义相关过滤器，通过分析源码我们发现，默认的用户名密码提取在 UsernamePasswordAuthenticationFilter 过滤器中，部分源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class UsernamePasswordAuthenticationFilter extends</span><br><span class="line">		AbstractAuthenticationProcessingFilter &#123;</span><br><span class="line">	public static final String SPRING_SECURITY_FORM_USERNAME_KEY &#x3D; &quot;username&quot;;</span><br><span class="line">	public static final String SPRING_SECURITY_FORM_PASSWORD_KEY &#x3D; &quot;password&quot;;</span><br><span class="line"></span><br><span class="line">	private String usernameParameter &#x3D; SPRING_SECURITY_FORM_USERNAME_KEY;</span><br><span class="line">	private String passwordParameter &#x3D; SPRING_SECURITY_FORM_PASSWORD_KEY;</span><br><span class="line">	private boolean postOnly &#x3D; true;</span><br><span class="line">	public UsernamePasswordAuthenticationFilter() &#123;</span><br><span class="line">		super(new AntPathRequestMatcher(&quot;&#x2F;login&quot;, &quot;POST&quot;));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Authentication attemptAuthentication(HttpServletRequest request,</span><br><span class="line">			HttpServletResponse response) throws AuthenticationException &#123;</span><br><span class="line">		if (postOnly &amp;&amp; !request.getMethod().equals(&quot;POST&quot;)) &#123;</span><br><span class="line">			throw new AuthenticationServiceException(</span><br><span class="line">					&quot;Authentication method not supported: &quot; + request.getMethod());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		String username &#x3D; obtainUsername(request);</span><br><span class="line">		String password &#x3D; obtainPassword(request);</span><br><span class="line"></span><br><span class="line">		if (username &#x3D;&#x3D; null) &#123;</span><br><span class="line">			username &#x3D; &quot;&quot;;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (password &#x3D;&#x3D; null) &#123;</span><br><span class="line">			password &#x3D; &quot;&quot;;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		username &#x3D; username.trim();</span><br><span class="line"></span><br><span class="line">		UsernamePasswordAuthenticationToken authRequest &#x3D; new UsernamePasswordAuthenticationToken(</span><br><span class="line">				username, password);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; Allow subclasses to set the &quot;details&quot; property</span><br><span class="line">		setDetails(request, authRequest);</span><br><span class="line"></span><br><span class="line">		return this.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	protected String obtainPassword(HttpServletRequest request) &#123;</span><br><span class="line">		return request.getParameter(passwordParameter);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	protected String obtainUsername(HttpServletRequest request) &#123;</span><br><span class="line">		return request.getParameter(usernameParameter);</span><br><span class="line">	&#125;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看到，默认的用户名/密码提取就是通过 request 中的 getParameter 来提取的，如果想使用 JSON 传递用户名密码，只需要将这个过滤器替换掉即可，自定义过滤器如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class CustomAuthenticationFilter extends UsernamePasswordAuthenticationFilter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123;</span><br><span class="line">        if (request.getContentType().equals(MediaType.APPLICATION_JSON_UTF8_VALUE)</span><br><span class="line">                || request.getContentType().equals(MediaType.APPLICATION_JSON_VALUE)) &#123;</span><br><span class="line">            ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">            UsernamePasswordAuthenticationToken authRequest &#x3D; null;</span><br><span class="line">            try (InputStream is &#x3D; request.getInputStream()) &#123;</span><br><span class="line">                Map&lt;String,String&gt; authenticationBean &#x3D; mapper.readValue(is, Map.class);</span><br><span class="line">                authRequest &#x3D; new UsernamePasswordAuthenticationToken(</span><br><span class="line">                        authenticationBean.get(&quot;username&quot;), authenticationBean.get(&quot;password&quot;));</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                authRequest &#x3D; new UsernamePasswordAuthenticationToken(</span><br><span class="line">                        &quot;&quot;, &quot;&quot;);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                setDetails(request, authRequest);</span><br><span class="line">                return this.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return super.attemptAuthentication(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只是将用户名/密码的获取方案重新修正下，改为了从 JSON 中获取用户名密码，然后在 SecurityConfig 中作出如下修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">    http.authorizeRequests().anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .and().csrf().disable();</span><br><span class="line">    http.addFilterAt(customAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">&#125;</span><br><span class="line">@Bean</span><br><span class="line">CustomAuthenticationFilter customAuthenticationFilter() throws Exception &#123;</span><br><span class="line">    CustomAuthenticationFilter filter &#x3D; new CustomAuthenticationFilter();</span><br><span class="line">    filter.setAuthenticationSuccessHandler(new AuthenticationSuccessHandler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onAuthenticationSuccess(HttpServletRequest req, HttpServletResponse resp, Authentication authentication) throws IOException, ServletException &#123;</span><br><span class="line">            resp.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);</span><br><span class="line">            PrintWriter out &#x3D; resp.getWriter();</span><br><span class="line">            RespBean respBean &#x3D; RespBean.ok(&quot;登录成功!&quot;);</span><br><span class="line">            out.write(new ObjectMapper().writeValueAsString(respBean));</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    filter.setAuthenticationFailureHandler(new AuthenticationFailureHandler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onAuthenticationFailure(HttpServletRequest req, HttpServletResponse resp, AuthenticationException e) throws IOException, ServletException &#123;</span><br><span class="line">            resp.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);</span><br><span class="line">            PrintWriter out &#x3D; resp.getWriter();</span><br><span class="line">            RespBean respBean &#x3D; RespBean.error(&quot;登录失败!&quot;);</span><br><span class="line">            out.write(new ObjectMapper().writeValueAsString(respBean));</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    filter.setAuthenticationManager(authenticationManagerBean());</span><br><span class="line">    return filter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将自定义的 CustomAuthenticationFilter 类加入进来即可，接下来就可以使用 JSON 进行登录了，如下：</p><p><img src="http://www.javaboy.org/images/boot/p1-3.png" alt="img"></p><hr><hr><h1 id="Spring-Security-中的角色继承问题"><a href="#Spring-Security-中的角色继承问题" class="headerlink" title="Spring Security 中的角色继承问题"></a>Spring Security 中的角色继承问题</h1><p>角色继承实际上是一个很常见的需求，因为大部分公司治理可能都是金字塔形的，上司可能具备下属的部分甚至所有权限，这一现实场景，反映到我们的代码中，就是角色继承了。 Spring Security 中为开发者提供了相关的角色继承解决方案，但是这一解决方案在最近的 Spring Security 版本变迁中，使用方法有所变化。</p><p>在 Spring Boot2.0.8（对应 Spring Security 也是 5.0.11）上面是一种写法，从 Spring Boot2.1.0（对应 Spring Security5.1.1）又是另外一种写法</p><h1 id="以前的写法"><a href="#以前的写法" class="headerlink" title="以前的写法"></a>以前的写法</h1><p>这里说的以前写法，就是指 SpringBoot2.0.8（含）之前的写法，在之前的写法中，角色继承只需要开发者提供一个 RoleHierarchy 接口的实例即可，例如下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">RoleHierarchy roleHierarchy() &#123;</span><br><span class="line">    RoleHierarchyImpl roleHierarchy &#x3D; new RoleHierarchyImpl();</span><br><span class="line">    String hierarchy &#x3D; &quot;ROLE_dba &gt; ROLE_admin ROLE_admin &gt; ROLE_user&quot;;</span><br><span class="line">    roleHierarchy.setHierarchy(hierarchy);</span><br><span class="line">    return roleHierarchy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们提供了一个 RoleHierarchy 接口的实例，使用字符串来描述了角色之间的继承关系， <code>ROLE_dba</code> 具备 <code>ROLE_admin</code> 的所有权限，而 <code>ROLE_admin</code> 则具备 <code>ROLE_user</code> 的所有权限，继承与继承之间用一个空格隔开。提供了这个 Bean 之后，以后所有具备 <code>ROLE_user</code> 角色才能访问的资源， <code>ROLE_dba</code> 和 <code>ROLE_admin</code> 也都能访问，具备 <code>ROLE_amdin</code> 角色才能访问的资源， <code>ROLE_dba</code> 也能访问。</p><h1 id="现在的写法"><a href="#现在的写法" class="headerlink" title="现在的写法"></a>现在的写法</h1><p>但是上面这种写法仅限于 Spring Boot2.0.8（含）之前的版本，在之后的版本中，这种写法则不被支持，新版的写法是下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">RoleHierarchy roleHierarchy() &#123;</span><br><span class="line">    RoleHierarchyImpl roleHierarchy &#x3D; new RoleHierarchyImpl();</span><br><span class="line">    String hierarchy &#x3D; &quot;ROLE_dba &gt; ROLE_admin \n ROLE_admin &gt; ROLE_user&quot;;</span><br><span class="line">    roleHierarchy.setHierarchy(hierarchy);</span><br><span class="line">    return roleHierarchy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变化主要就是分隔符，将原来用空格隔开的地方，现在用换行符了。这里表达式的含义依然和上面一样，不再赘述。</p><p>上面两种不同写法都是配置角色的继承关系，配置完成后，接下来指定角色和资源的对应关系即可，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">    http.authorizeRequests().antMatchers(&quot;&#x2F;admin&#x2F;**&quot;)</span><br><span class="line">            .hasRole(&quot;admin&quot;)</span><br><span class="line">            .antMatchers(&quot;&#x2F;db&#x2F;**&quot;)</span><br><span class="line">            .hasRole(&quot;dba&quot;)</span><br><span class="line">            .antMatchers(&quot;&#x2F;user&#x2F;**&quot;)</span><br><span class="line">            .hasRole(&quot;user&quot;)</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .loginProcessingUrl(&quot;&#x2F;doLogin&quot;)</span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个表示 <code>/db/**</code> 格式的路径需要具备 dba 角色才能访问， <code>/admin/**</code> 格式的路径则需要具备 admin 角色才能访问， <code>/user/**</code> 格式的路径，则需要具备 user 角色才能访问，此时提供相关接口，会发现，dba 除了访问 <code>/db/**</code> ，也能访问 <code>/admin/**</code> 和 <code>/user/**</code> ，admin 角色除了访问 <code>/admin/**</code> ，也能访问 <code>/user/**</code> ，user 角色则只能访问 <code>/user/**</code> 。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>这样两种不同的写法，其实也对应了两种不同的解析策略，角色继承关系的解析在 RoleHierarchyImpl 类的 buildRolesReachableInOneStepMap 方法中，Spring Boot2.0.8（含）之前该方法的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void buildRolesReachableInOneStepMap() &#123;</span><br><span class="line">	Pattern pattern &#x3D; Pattern.compile(&quot;(\\s*([^\\s&gt;]+)\\s*&gt;\\s*([^\\s&gt;]+))&quot;);</span><br><span class="line">	Matcher roleHierarchyMatcher &#x3D; pattern</span><br><span class="line">			.matcher(this.roleHierarchyStringRepresentation);</span><br><span class="line">	this.rolesReachableInOneStepMap &#x3D; new HashMap&lt;GrantedAuthority, Set&lt;GrantedAuthority&gt;&gt;();</span><br><span class="line">	while (roleHierarchyMatcher.find()) &#123;</span><br><span class="line">		GrantedAuthority higherRole &#x3D; new SimpleGrantedAuthority(</span><br><span class="line">				roleHierarchyMatcher.group(2));</span><br><span class="line">		GrantedAuthority lowerRole &#x3D; new SimpleGrantedAuthority(</span><br><span class="line">				roleHierarchyMatcher.group(3));</span><br><span class="line">		Set&lt;GrantedAuthority&gt; rolesReachableInOneStepSet;</span><br><span class="line">		if (!this.rolesReachableInOneStepMap.containsKey(higherRole)) &#123;</span><br><span class="line">			rolesReachableInOneStepSet &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">			this.rolesReachableInOneStepMap.put(higherRole,</span><br><span class="line">					rolesReachableInOneStepSet);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			rolesReachableInOneStepSet &#x3D; this.rolesReachableInOneStepMap</span><br><span class="line">					.get(higherRole);</span><br><span class="line">		&#125;</span><br><span class="line">		addReachableRoles(rolesReachableInOneStepSet, lowerRole);</span><br><span class="line">		logger.debug(&quot;buildRolesReachableInOneStepMap() - From role &quot; + higherRole</span><br><span class="line">				+ &quot; one can reach role &quot; + lowerRole + &quot; in one step.&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段源码中我们可以看到，角色的继承关系是通过正则表达式进行解析，通过空格进行切分，然后构建相应的 map 出来。</p><p>Spring Boot2.1.0（含）之后该方法的源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void buildRolesReachableInOneStepMap() &#123;</span><br><span class="line">	this.rolesReachableInOneStepMap &#x3D; new HashMap&lt;GrantedAuthority, Set&lt;GrantedAuthority&gt;&gt;();</span><br><span class="line">	try (BufferedReader bufferedReader &#x3D; new BufferedReader(</span><br><span class="line">			new StringReader(this.roleHierarchyStringRepresentation))) &#123;</span><br><span class="line">		for (String readLine; (readLine &#x3D; bufferedReader.readLine()) !&#x3D; null;) &#123;</span><br><span class="line">			String[] roles &#x3D; readLine.split(&quot; &gt; &quot;);</span><br><span class="line">			for (int i &#x3D; 1; i &lt; roles.length; i++) &#123;</span><br><span class="line">				GrantedAuthority higherRole &#x3D; new SimpleGrantedAuthority(</span><br><span class="line">						roles[i - 1].replaceAll(&quot;^\\s+|\\s+$&quot;, &quot;&quot;));</span><br><span class="line">				GrantedAuthority lowerRole &#x3D; new SimpleGrantedAuthority(roles[i].replaceAll(&quot;^\\s+|\\s+$</span><br><span class="line">				Set&lt;GrantedAuthority&gt; rolesReachableInOneStepSet;</span><br><span class="line">				if (!this.rolesReachableInOneStepMap.containsKey(higherRole)) &#123;</span><br><span class="line">					rolesReachableInOneStepSet &#x3D; new HashSet&lt;GrantedAuthority&gt;();</span><br><span class="line">					this.rolesReachableInOneStepMap.put(higherRole, rolesReachableInOneStepSet);</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					rolesReachableInOneStepSet &#x3D; this.rolesReachableInOneStepMap.get(higherRole);</span><br><span class="line">				&#125;</span><br><span class="line">				addReachableRoles(rolesReachableInOneStepSet, lowerRole);</span><br><span class="line">				if (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(&quot;buildRolesReachableInOneStepMap() - From role &quot; + higherRole</span><br><span class="line">							+ &quot; one can reach role &quot; + lowerRole + &quot; in one step.&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; catch (IOException e) &#123;</span><br><span class="line">		throw new IllegalStateException(e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里我们可以看到，这里并没有一上来就是用正则表达式，而是先将角色继承字符串转为一个 BufferedReader ，然后一行一行的读出来，再进行解析，最后再构建相应的 map。从这里我们可以看出为什么前后版本对此有不同的写法。</p><hr><h1 id="干货-一个案例学会Spring-Security-中使用-JWT"><a href="#干货-一个案例学会Spring-Security-中使用-JWT" class="headerlink" title="干货|一个案例学会Spring Security 中使用 JWT"></a>干货|一个案例学会Spring Security 中使用 JWT</h1><h1 id="1-无状态登录"><a href="#1-无状态登录" class="headerlink" title="1 无状态登录"></a>1 无状态登录</h1><h2 id="1-1-什么是有状态？"><a href="#1-1-什么是有状态？" class="headerlink" title="1.1 什么是有状态？"></a>1.1 什么是有状态？</h2><p>有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如Tomcat中的Session。例如登录：用户登录后，我们把用户的信息保存在服务端session中，并且给用户一个cookie值，记录对应的session，然后下次请求，用户携带cookie值来（这一步有浏览器自动完成），我们就能识别到对应session，从而找到用户的信息。这种方式目前来看最方便，但是也有一些缺陷，如下：</p><ul><li>服务端保存大量数据，增加服务端压力</li><li>服务端保存用户状态，不支持集群化部署</li></ul><h2 id="1-2-什么是无状态"><a href="#1-2-什么是无状态" class="headerlink" title="1.2 什么是无状态"></a>1.2 什么是无状态</h2><p>微服务集群中的每个服务，对外提供的都使用RESTful风格的接口。而RESTful风格的一个最重要的规范就是：服务的无状态性，即：</p><ul><li>服务端不保存任何客户端请求者信息</li><li>客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份</li></ul><p>那么这种无状态性有哪些好处呢？</p><ul><li>客户端请求不依赖服务端的信息，多次请求不需要必须访问到同一台服务器</li><li>服务端的集群和状态对客户端透明</li><li>服务端可以任意的迁移和伸缩（可以方便的进行集群化部署）</li><li>减小服务端存储压力</li></ul><h2 id="1-3-如何实现无状态"><a href="#1-3-如何实现无状态" class="headerlink" title="1.3.如何实现无状态"></a>1.3.如何实现无状态</h2><p>无状态登录的流程：</p><ul><li>首先客户端发送账户名/密码到服务端进行认证</li><li>认证通过后，服务端将用户信息加密并且编码成一个token，返回给客户端</li><li>以后客户端每次发送请求，都需要携带认证的token</li><li>服务端对客户端发送来的token进行解密，判断是否有效，并且获取用户登录信息</li></ul><h2 id="1-4-JWT"><a href="#1-4-JWT" class="headerlink" title="1.4 JWT"></a>1.4 JWT</h2><h3 id="1-4-1-简介"><a href="#1-4-1-简介" class="headerlink" title="1.4.1 简介"></a>1.4.1 简介</h3><p>JWT，全称是Json Web Token， 是一种JSON风格的轻量级的授权和身份认证规范，可实现无状态、分布式的Web应用授权：</p><p><img src="http://www.javaboy.org/images/sb/20-1.png" alt="img"></p><p>JWT 作为一种规范，并没有和某一种语言绑定在一起，常用的Java 实现是GitHub 上的开源项目 jjwt，地址如下：<code>https://github.com/jwtk/jjwt</code></p><h3 id="1-4-2-JWT数据格式"><a href="#1-4-2-JWT数据格式" class="headerlink" title="1.4.2 JWT数据格式"></a>1.4.2 JWT数据格式</h3><p>JWT包含三部分数据：</p><ul><li><p>Header：头部，通常头部有两部分信息：</p><ul><li>声明类型，这里是JWT</li><li>加密算法，自定义</li></ul><p>我们会对头部进行Base64Url编码（可解码），得到第一部分数据。</p></li><li><p>Payload：载荷，就是有效数据，在官方文档中(RFC7519)，这里给了7个示例信息：</p><ul><li>iss (issuer)：表示签发人</li><li>exp (expiration time)：表示token过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul><p>这部分也会采用Base64Url编码，得到第二部分数据。</p></li><li><p>Signature：签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥secret（密钥保存在服务端，不能泄露给客户端），通过Header中配置的加密算法生成。用于验证整个数据完整和可靠性。</p></li></ul><p>生成的数据格式如下图：</p><p><img src="http://www.javaboy.org/images/sb/20-2.png" alt="img"></p><p>注意，这里的数据通过 <code>.</code> 隔开成了三部分，分别对应前面提到的三部分，另外，这里数据是不换行的，图片换行只是为了展示方便而已。</p><h3 id="1-4-3-JWT交互流程"><a href="#1-4-3-JWT交互流程" class="headerlink" title="1.4.3 JWT交互流程"></a>1.4.3 JWT交互流程</h3><p>流程图：</p><p><img src="http://www.javaboy.org/images/sb/20-3.png" alt="img"></p><p>步骤翻译：</p><ol><li>应用程序或客户端向授权服务器请求授权</li><li>获取到授权后，授权服务器会向应用程序返回访问令牌</li><li>应用程序使用访问令牌来访问受保护资源（如API）</li></ol><p>因为JWT签发的token中已经包含了用户的身份信息，并且每次请求都会携带，这样服务的就无需保存用户信息，甚至无需去数据库查询，这样就完全符合了RESTful的无状态规范。</p><h2 id="1-5-JWT-存在的问题"><a href="#1-5-JWT-存在的问题" class="headerlink" title="1.5 JWT 存在的问题"></a>1.5 JWT 存在的问题</h2><p>说了这么多，JWT 也不是天衣无缝，由客户端维护登录状态带来的一些问题在这里依然存在，举例如下：</p><ol><li>续签问题，这是被很多人诟病的问题之一，传统的cookie+session的方案天然的支持续签，但是jwt由于服务端不保存用户状态，因此很难完美解决续签问题，如果引入redis，虽然可以解决问题，但是jwt也变得不伦不类了。</li><li>注销问题，由于服务端不再保存用户信息，所以一般可以通过修改secret来实现注销，服务端secret修改后，已经颁发的未过期的token就会认证失败，进而实现注销，不过毕竟没有传统的注销方便。</li><li>密码重置，密码重置后，原本的token依然可以访问系统，这时候也需要强制修改secret。</li><li>基于第2点和第3点，一般建议不同用户取不同secret。</li></ol><h1 id="2-实战"><a href="#2-实战" class="headerlink" title="2 实战"></a>2 实战</h1><p>说了这么久，接下来我们就来看看这个东西到底要怎么用？</p><h2 id="2-1-环境搭建"><a href="#2-1-环境搭建" class="headerlink" title="2.1 环境搭建"></a>2.1 环境搭建</h2><p>首先我们来创建一个Spring Boot项目，创建时需要添加Spring Security依赖，创建完成后，添加 <code>jjwt</code> 依赖，完整的pom.xml文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.jsonwebtoken&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jjwt&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.9.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>然后在项目中创建一个简单的 User 对象实现 UserDetails 接口，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class User implements UserDetails &#123;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    private List&lt;GrantedAuthority&gt; authorities;</span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean isAccountNonExpired() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean isAccountNonLocked() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean isCredentialsNonExpired() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean isEnabled() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;省略getter&#x2F;setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是我们的用户对象，先放着备用，再创建一个HelloController，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @GetMapping(&quot;&#x2F;hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;hello jwt !&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    @GetMapping(&quot;&#x2F;admin&quot;)</span><br><span class="line">    public String admin() &#123;</span><br><span class="line">        return &quot;hello admin !&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HelloController 很简单，这里有两个接口，设计是 <code>/hello</code> 接口可以被具有 user 角色的用户访问，而 <code>/admin</code> 接口则可以被具有 admin 角色的用户访问。</p><h2 id="2-2-JWT-过滤器配置"><a href="#2-2-JWT-过滤器配置" class="headerlink" title="2.2 JWT 过滤器配置"></a>2.2 JWT 过滤器配置</h2><p>接下来提供两个和 JWT 相关的过滤器配置：</p><ol><li>一个是用户登录的过滤器，在用户的登录的过滤器中校验用户是否登录成功，如果登录成功，则生成一个token返回给客户端，登录失败则给前端一个登录失败的提示。</li><li>第二个过滤器则是当其他请求发送来，校验token的过滤器，如果校验成功，就让请求继续执行。</li></ol><p>这两个过滤器，我们分别来看，先看第一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class JwtLoginFilter extends AbstractAuthenticationProcessingFilter &#123;</span><br><span class="line">    protected JwtLoginFilter(String defaultFilterProcessesUrl, AuthenticationManager authenticationManager) &#123;</span><br><span class="line">        super(new AntPathRequestMatcher(defaultFilterProcessesUrl));</span><br><span class="line">        setAuthenticationManager(authenticationManager);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Authentication attemptAuthentication(HttpServletRequest req, HttpServletResponse resp) throws AuthenticationException, IOException, ServletException &#123;</span><br><span class="line">        User user &#x3D; new ObjectMapper().readValue(req.getInputStream(), User.class);</span><br><span class="line">        return getAuthenticationManager().authenticate(new UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword()));</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void successfulAuthentication(HttpServletRequest req, HttpServletResponse resp, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123;</span><br><span class="line">        Collection&lt;? extends GrantedAuthority&gt; authorities &#x3D; authResult.getAuthorities();</span><br><span class="line">        StringBuffer as &#x3D; new StringBuffer();</span><br><span class="line">        for (GrantedAuthority authority : authorities) &#123;</span><br><span class="line">            as.append(authority.getAuthority())</span><br><span class="line">                    .append(&quot;,&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        String jwt &#x3D; Jwts.builder()</span><br><span class="line">                .claim(&quot;authorities&quot;, as)&#x2F;&#x2F;配置用户角色</span><br><span class="line">                .setSubject(authResult.getName())</span><br><span class="line">                .setExpiration(new Date(System.currentTimeMillis() + 10 * 60 * 1000))</span><br><span class="line">                .signWith(SignatureAlgorithm.HS512,&quot;sang@123&quot;)</span><br><span class="line">                .compact();</span><br><span class="line">        resp.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);</span><br><span class="line">        PrintWriter out &#x3D; resp.getWriter();</span><br><span class="line">        out.write(new ObjectMapper().writeValueAsString(jwt));</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">    protected void unsuccessfulAuthentication(HttpServletRequest req, HttpServletResponse resp, AuthenticationException failed) throws IOException, ServletException &#123;</span><br><span class="line">        resp.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);</span><br><span class="line">        PrintWriter out &#x3D; resp.getWriter();</span><br><span class="line">        out.write(&quot;登录失败!&quot;);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这个类，我说如下几点：</p><ol><li>自定义 JwtLoginFilter 继承自 AbstractAuthenticationProcessingFilter，并实现其中的三个默认方法。</li><li>attemptAuthentication方法中，我们从登录参数中提取出用户名密码，然后调用AuthenticationManager.authenticate()方法去进行自动校验。</li><li>第二步如果校验成功，就会来到successfulAuthentication回调中，在successfulAuthentication方法中，将用户角色遍历然后用一个 <code>,</code> 连接起来，然后再利用Jwts去生成token，按照代码的顺序，生成过程一共配置了四个参数，分别是用户角色、主题、过期时间以及加密算法和密钥，然后将生成的token写出到客户端。</li><li>第二步如果校验失败就会来到unsuccessfulAuthentication方法中，在这个方法中返回一个错误提示给客户端即可。</li></ol><p>再来看第二个token校验的过滤器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class JwtFilter extends GenericFilterBean &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        HttpServletRequest req &#x3D; (HttpServletRequest) servletRequest;</span><br><span class="line">        String jwtToken &#x3D; req.getHeader(&quot;authorization&quot;);</span><br><span class="line">        System.out.println(jwtToken);</span><br><span class="line">        Claims claims &#x3D; Jwts.parser().setSigningKey(&quot;sang@123&quot;).parseClaimsJws(jwtToken.replace(&quot;Bearer&quot;,&quot;&quot;))</span><br><span class="line">                .getBody();</span><br><span class="line">        String username &#x3D; claims.getSubject();&#x2F;&#x2F;获取当前登录用户名</span><br><span class="line">        List&lt;GrantedAuthority&gt; authorities &#x3D; AuthorityUtils.commaSeparatedStringToAuthorityList((String) claims.get(&quot;authorities&quot;));</span><br><span class="line">        UsernamePasswordAuthenticationToken token &#x3D; new UsernamePasswordAuthenticationToken(username, null, authorities);</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(token);</span><br><span class="line">        filterChain.doFilter(req,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这个过滤器，我说如下几点：</p><ol><li>首先从请求头中提取出 authorization 字段，这个字段对应的value就是用户的token。</li><li>将提取出来的token字符串转换为一个Claims对象，再从Claims对象中提取出当前用户名和用户角色，创建一个UsernamePasswordAuthenticationToken放到当前的Context中，然后执行过滤链使请求继续执行下去。</li></ol><p>如此之后，两个和JWT相关的过滤器就算配置好了。</p><h2 id="2-3-Spring-Security-配置"><a href="#2-3-Spring-Security-配置" class="headerlink" title="2.3 Spring Security 配置"></a>2.3 Spring Security 配置</h2><p>接下来我们来配置 Spring Security,如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    PasswordEncoder passwordEncoder() &#123;</span><br><span class="line">        return NoOpPasswordEncoder.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line">        auth.inMemoryAuthentication().withUser(&quot;admin&quot;)</span><br><span class="line">                .password(&quot;123&quot;).roles(&quot;admin&quot;)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(&quot;sang&quot;)</span><br><span class="line">                .password(&quot;456&quot;)</span><br><span class="line">                .roles(&quot;user&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(&quot;&#x2F;hello&quot;).hasRole(&quot;user&quot;)</span><br><span class="line">                .antMatchers(&quot;&#x2F;admin&quot;).hasRole(&quot;admin&quot;)</span><br><span class="line">                .antMatchers(HttpMethod.POST, &quot;&#x2F;login&quot;).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .addFilterBefore(new JwtLoginFilter(&quot;&#x2F;login&quot;,authenticationManager()),UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                .addFilterBefore(new JwtFilter(),UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>简单起见，这里我并未对密码进行加密，因此配置了NoOpPasswordEncoder的实例。</li><li>简单起见，这里并未连接数据库，我直接在内存中配置了两个用户，两个用户具备不同的角色。</li><li>配置路径规则时， <code>/hello</code> 接口必须要具备 user 角色才能访问， <code>/admin</code> 接口必须要具备 admin 角色才能访问，POST 请求并且是 <code>/login</code> 接口则可以直接通过，其他接口必须认证后才能访问。</li><li>最后配置上两个自定义的过滤器并且关闭掉csrf保护。</li></ol><h2 id="2-4-测试"><a href="#2-4-测试" class="headerlink" title="2.4 测试"></a>2.4 测试</h2><p>做完这些之后，我们的环境就算完全搭建起来了，接下来启动项目然后在 POSTMAN 中进行测试，如下：</p><p><img src="http://www.javaboy.org/images/sb/20-4.png" alt="img"></p><p>登录成功后返回的字符串就是经过 base64url 转码的token，一共有三部分，通过一个 <code>.</code> 隔开，我们可以对第一个 <code>.</code> 之前的字符串进行解码，即Header，如下：</p><p><img src="http://www.javaboy.org/images/sb/20-5.png" alt="img"></p><p>再对两个 <code>.</code> 之间的字符解码，即 payload：</p><p><img src="http://www.javaboy.org/images/sb/20-6.png" alt="img"></p><p>可以看到，我们设置信息，由于base64并不是加密方案，只是一种编码方案，因此，不建议将敏感的用户信息放到token中。</p><p>接下来再去访问 <code>/hello</code> 接口，注意认证方式选择 Bearer Token，Token值为刚刚获取到的值，如下：</p><p><img src="http://www.javaboy.org/images/sb/20-7.png" alt="img"></p><p>可以看到，访问成功。</p><h1><a href="#" class="headerlink"></a></h1><hr><h1 id="Spring-Security-前后端分离登录，非法请求直接返回-JSON"><a href="#Spring-Security-前后端分离登录，非法请求直接返回-JSON" class="headerlink" title="Spring Security 前后端分离登录，非法请求直接返回 JSON"></a>Spring Security 前后端分离登录，非法请求直接返回 JSON</h1><p>在 Spring Security 中未获认证的请求默认会重定向到登录页，但是在前后端分离的登录中，这个默认行为则显得非常不合适，今天我们主要来看看如何实现未获认证的请求直接返回 JSON ，而不是重定向到登录页面。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>这里关于 Spring Security 的基本用法我就不再赘述了，如果小伙伴们不了解，可以参考上面的 6 篇文章。</p><p>大家知道，在自定义 Spring Security 配置的时候，有这样几个属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .loginProcessingUrl(&quot;&#x2F;doLogin&quot;)</span><br><span class="line">            .loginPage(&quot;&#x2F;login&quot;)</span><br><span class="line">            &#x2F;&#x2F;其他配置</span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个比较重要的属性：</p><ul><li>loginProcessingUrl：这个表示配置处理登录请求的接口地址，例如你是表单登录，那么 form 表单中 action 的值就是这里填的值。</li><li>loginPage：这个表示登录页的地址，例如当你访问一个需要登录后才能访问的资源时，系统就会自动给你通过重定向跳转到这个页面上来。</li></ul><p>这种配置在前后端不分的登录中是没有问题的，在前后端分离的登录中，这种配置就有问题了。我举个简单的例子，例如我想访问 <code>/hello</code> 接口，但是这个接口需要登录之后才能访问，我现在没有登录就直接去访问这个接口了，那么系统会给我返回 302，让我去登录页面，在前后端分离中，我的后端一般是没有登录页面的，就是一个提示 JSON，例如下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;login&quot;)</span><br><span class="line">public RespBean login() &#123;</span><br><span class="line">    return RespBean.error(&quot;尚未登录，请登录!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>完整代码大家可以参考我的微人事项目。</p></blockquote><p>也就是说，当我没有登录直接去访问 <code>/hello</code> 这个接口的时候，我会看到上面这段 JSON 字符串。在前后端分离开发中，这个看起来没问题（后端不再做页面跳转，无论发生什么都是返回 JSON）。但是问题就出在这里，系统默认的跳转是一个重定向，就是说当你访问 <code>/hello</code> 的时候，服务端会给浏览器返回 302，同时响应头中有一个 Location 字段，它的值为 <code>http://localhost:8081/login</code> ，也就是告诉浏览器你去访问 <code>http://localhost:8081/login</code> 地址吧。浏览器收到指令之后，就会直接去访问 <code>http://localhost:8081/login</code> 地址，如果此时是开发环境并且请求还是 Ajax 请求，就会发生跨域。因为前后端分离开发中，前端我们一般在 NodeJS 上启动，然后前端的所有请求通过 NodeJS 做请求转发，现在服务端直接把请求地址告诉浏览器了，浏览器就会直接去访问 <code>http://localhost:8081/login</code> 了，而不会做请求转发了，因此就发生了跨域问题。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>很明显，上面的问题我们不能用跨域的思路来解决，虽然这种方式看起来也能解决问题，但不是最佳方案。</p><p>如果我们的 Spring Security 在用户未获认证的时候去请求一个需要认证后才能请求的数据，此时不给用户重定向，而是直接就返回一个 JSON，告诉用户这个请求需要认证之后才能发起，就不会有上面的事情了。</p><p>这里就涉及到 Spring Security 中的一个接口 <code>AuthenticationEntryPoint</code> ，该接口有一个实现类：<code>LoginUrlAuthenticationEntryPoint</code> ，该类中有一个方法 <code>commence</code>，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Performs the redirect (or forward) to the login form URL.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void commence(HttpServletRequest request, HttpServletResponse response,</span><br><span class="line">		AuthenticationException authException) &#123;</span><br><span class="line">	String redirectUrl &#x3D; null;</span><br><span class="line">	if (useForward) &#123;</span><br><span class="line">		if (forceHttps &amp;&amp; &quot;http&quot;.equals(request.getScheme())) &#123;</span><br><span class="line">			redirectUrl &#x3D; buildHttpsRedirectUrlForRequest(request);</span><br><span class="line">		&#125;</span><br><span class="line">		if (redirectUrl &#x3D;&#x3D; null) &#123;</span><br><span class="line">			String loginForm &#x3D; determineUrlToUseForThisRequest(request, response,</span><br><span class="line">					authException);</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Server side forward to: &quot; + loginForm);</span><br><span class="line">			&#125;</span><br><span class="line">			RequestDispatcher dispatcher &#x3D; request.getRequestDispatcher(loginForm);</span><br><span class="line">			dispatcher.forward(request, response);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		redirectUrl &#x3D; buildRedirectUrlToLoginPage(request, response, authException);</span><br><span class="line">	&#125;</span><br><span class="line">	redirectStrategy.sendRedirect(request, response, redirectUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们从这个方法的注释中就可以看出，这个方法是用来决定到底是要重定向还是要 forward，通过 Debug 追踪，我们发现默认情况下 useForward 的值为 false，所以请求走进了重定向。</p><p>那么我们解决问题的思路很简单，直接重写这个方法，在方法中返回 JSON 即可，不再做重定向操作，具体配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .loginProcessingUrl(&quot;&#x2F;doLogin&quot;)</span><br><span class="line">            .loginPage(&quot;&#x2F;login&quot;)</span><br><span class="line">            &#x2F;&#x2F;其他配置</span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable().exceptionHandling()</span><br><span class="line">                .authenticationEntryPoint(new AuthenticationEntryPoint() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void commence(HttpServletRequest req, HttpServletResponse resp, AuthenticationException authException) throws IOException, ServletException &#123;</span><br><span class="line">                resp.setContentType(&quot;application&#x2F;json;charset&#x3D;utf-8&quot;);</span><br><span class="line">                PrintWriter out &#x3D; resp.getWriter();</span><br><span class="line">                RespBean respBean &#x3D; RespBean.error(&quot;访问失败!&quot;);</span><br><span class="line">                if (authException instanceof InsufficientAuthenticationException) &#123;</span><br><span class="line">                    respBean.setMsg(&quot;请求失败，请联系管理员!&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                out.write(new ObjectMapper().writeValueAsString(respBean));</span><br><span class="line">                out.flush();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Spring Security 的配置中加上自定义的 <code>AuthenticationEntryPoint</code> 处理方法，该方法中直接返回相应的 JSON 提示即可。这样，如果用户再去直接访问一个需要认证之后才可以访问的请求，就不会发生重定向操作了，服务端会直接给浏览器一个 JSON 提示，浏览器收到 JSON 之后，该干嘛干嘛。</p><hr><h2 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h2><p>OAuth 是一个开放标准，该标准允许用户让第三方应用访问该用户在某一网站上存储的私密资源（如头像、照片、视频等），而在这个过程中无需将用户名和密码提供给第三方应用。实现这一功能是通过提供一个令牌（token），而不是用户名和密码来访问他们存放在特定服务提供者的数据。采用令牌（token）的方式可以让用户灵活的对第三方应用授权或者收回权限。</p><p>OAuth2 是 OAuth 协议的下一版本，但不向下兼容 OAuth 1.0。传统的 Web 开发登录认证一般都是基于 session 的，但是在前后端分离的架构中继续使用 session 就会有许多不便，因为移动端（Android、iOS、微信小程序等）要么不支持 cookie（微信小程序），要么使用非常不便，对于这些问题，使用 OAuth2 认证都能解决。</p><h2 id="授权模式"><a href="#授权模式" class="headerlink" title="授权模式"></a>授权模式</h2><p>OAuth协议的授权模式共分为四种：</p><ol><li>授权码模式：常见的第三方平台登录功能基本都是使用这种模式。</li><li>简化模式：简化模式是不需要客户端服务器参与，直接在浏览器中向授权服务器申请令牌（token），一般如果网站是纯静态页面则可以采用这种方式。</li><li>密码模式：密码模式是用户把用户名密码直接告诉客户端，客户端使用说这些信息向授权服务器申请令牌（token）。这需要用户对客户端高度信任，例如客户端应用和服务提供商就是同一家公司。</li><li>客户端模式：客户端模式是指客户端使用自己的名义而不是用户的名义向服务提供者申请授权，严格来说，客户端模式并不能算作 OAuth 协议要解决的问题的一种解决方案，但是，对于开发者而言，在一些前后端分离应用或者为移动端提供的认证授权服务器上使用这种模式还是非常方便的。</li></ol></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/spring%E6%BA%90%E7%A0%81/">spring源码</a></div><div class="post_share"><div class="social-share" data-image="http://hankz.oss-cn-hangzhou.aliyuncs.com/wallhaven-6k93rq.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/kele.png" target="_blank"><img class="post-qr-code-img" src="/img/kele.png" alt="觉得还不错，请他喝一瓶可乐"></a><div class="post-qr-code-desc">觉得还不错，请他喝一瓶可乐</div></li><li class="reward-item"><a href="/img/ali.jpg" target="_blank"><img class="post-qr-code-img" src="/img/ali.jpg" alt="雪碧也是可以的"></a><div class="post-qr-code-desc">雪碧也是可以的</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/20200709/%E4%BB%80%E4%B9%88%E6%98%AFRedis/"><img class="prev-cover" src="http://hankz.oss-cn-hangzhou.aliyuncs.com/wallhaven-57gyw9.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">什么是Redis</div></div></a></div><div class="next-post pull-right"><a href="/20200413/%E4%BB%80%E4%B9%88%E6%98%AFGit/"><img class="next-cover" src="http://hankz.oss-cn-hangzhou.aliyuncs.com/wallhaven-5736e3.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">什么是GIT</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/20210316/mybatis源码解析/" title="mybatis源码解析"><img class="cover" src="http://hankz.oss-cn-hangzhou.aliyuncs.com/wallhaven-6oj73l.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-16</div><div class="title">mybatis源码解析</div></div></a></div><div><a href="/20210410/springboot源码解析/" title="springboot源码解析"><img class="cover" src="http://hankz.oss-cn-hangzhou.aliyuncs.com/wallhaven-6ok5wl.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-10</div><div class="title">springboot源码解析</div></div></a></div><div><a href="/20210307/什么是spring循环依赖-源码分析/" title="什么是spring循环依赖?源码分析"><img class="cover" src="http://hankz.oss-cn-hangzhou.aliyuncs.com/wallhaven-6oj73l.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-07</div><div class="title">什么是spring循环依赖?源码分析</div></div></a></div><div><a href="/20210308/spring源码解析/" title="spring源码解析"><img class="cover" src="http://hankz.oss-cn-hangzhou.aliyuncs.com/wallhaven-6ok5wl.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-08</div><div class="title">spring源码解析</div></div></a></div><div><a href="/20210316/Java常见源码解析/" title="Java常见源码解析"><img class="cover" src="http://hankz.oss-cn-hangzhou.aliyuncs.com/wallhaven-6oj73l.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-16</div><div class="title">Java常见源码解析</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/tx2.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"><div class="author-info__name">章志成</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/gump12138"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/cooper12138" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:994739211@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">延迟满足</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-Security%E6%95%99%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">Spring Security教程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA"><span class="toc-number">2.</span> <span class="toc-text">1.项目创建</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%88%9D%E6%AC%A1%E4%BD%93%E9%AA%8C"><span class="toc-number">3.</span> <span class="toc-text">2.初次体验</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%94%A8%E6%88%B7%E5%90%8D%E9%85%8D%E7%BD%AE"><span class="toc-number">4.</span> <span class="toc-text">3.用户名配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E5%90%8D-%E5%AF%86%E7%A0%81"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 配置文件配置用户名&#x2F;密码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Java-%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E5%90%8D-%E5%AF%86%E7%A0%81"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 Java 配置用户名&#x2F;密码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E7%99%BB%E5%BD%95%E9%85%8D%E7%BD%AE"><span class="toc-number">5.</span> <span class="toc-text">4.登录配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%BF%BD%E7%95%A5%E6%8B%A6%E6%88%AA"><span class="toc-number">6.</span> <span class="toc-text">5.忽略拦截</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-Security-%E7%99%BB%E5%BD%95%E6%B7%BB%E5%8A%A0%E9%AA%8C%E8%AF%81%E7%A0%81"><span class="toc-number">7.</span> <span class="toc-text">Spring Security 登录添加验证码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E9%AA%8C%E8%AF%81%E7%A0%81"><span class="toc-number">8.</span> <span class="toc-text">准备验证码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">9.</span> <span class="toc-text">自定义过滤器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-number">10.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-Security-%E7%99%BB%E5%BD%95%E4%BD%BF%E7%94%A8-JSON-%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AE"><span class="toc-number">11.</span> <span class="toc-text">Spring Security 登录使用 JSON 格式数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8JSON%E7%99%BB%E5%BD%95"><span class="toc-number">12.</span> <span class="toc-text">使用JSON登录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-Security-%E4%B8%AD%E7%9A%84%E8%A7%92%E8%89%B2%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98"><span class="toc-number">13.</span> <span class="toc-text">Spring Security 中的角色继承问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A5%E5%89%8D%E7%9A%84%E5%86%99%E6%B3%95"><span class="toc-number">14.</span> <span class="toc-text">以前的写法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%B0%E5%9C%A8%E7%9A%84%E5%86%99%E6%B3%95"><span class="toc-number">15.</span> <span class="toc-text">现在的写法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">16.</span> <span class="toc-text">源码分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B2%E8%B4%A7-%E4%B8%80%E4%B8%AA%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%BC%9ASpring-Security-%E4%B8%AD%E4%BD%BF%E7%94%A8-JWT"><span class="toc-number">17.</span> <span class="toc-text">干货|一个案例学会Spring Security 中使用 JWT</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%97%A0%E7%8A%B6%E6%80%81%E7%99%BB%E5%BD%95"><span class="toc-number">18.</span> <span class="toc-text">1 无状态登录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%89%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">18.1.</span> <span class="toc-text">1.1 什么是有状态？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81"><span class="toc-number">18.2.</span> <span class="toc-text">1.2 什么是无状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%97%A0%E7%8A%B6%E6%80%81"><span class="toc-number">18.3.</span> <span class="toc-text">1.3.如何实现无状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-JWT"><span class="toc-number">18.4.</span> <span class="toc-text">1.4 JWT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">18.4.1.</span> <span class="toc-text">1.4.1 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-JWT%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">18.4.2.</span> <span class="toc-text">1.4.2 JWT数据格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3-JWT%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B"><span class="toc-number">18.4.3.</span> <span class="toc-text">1.4.3 JWT交互流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-JWT-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">18.5.</span> <span class="toc-text">1.5 JWT 存在的问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%AE%9E%E6%88%98"><span class="toc-number">19.</span> <span class="toc-text">2 实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">19.1.</span> <span class="toc-text">2.1 环境搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-JWT-%E8%BF%87%E6%BB%A4%E5%99%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">19.2.</span> <span class="toc-text">2.2 JWT 过滤器配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-Spring-Security-%E9%85%8D%E7%BD%AE"><span class="toc-number">19.3.</span> <span class="toc-text">2.3 Spring Security 配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E6%B5%8B%E8%AF%95"><span class="toc-number">19.4.</span> <span class="toc-text">2.4 测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">20.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-Security-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%99%BB%E5%BD%95%EF%BC%8C%E9%9D%9E%E6%B3%95%E8%AF%B7%E6%B1%82%E7%9B%B4%E6%8E%A5%E8%BF%94%E5%9B%9E-JSON"><span class="toc-number">21.</span> <span class="toc-text">Spring Security 前后端分离登录，非法请求直接返回 JSON</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">21.1.</span> <span class="toc-text">前置知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">21.2.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OAuth2"><span class="toc-number">21.3.</span> <span class="toc-text">OAuth2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%88%E6%9D%83%E6%A8%A1%E5%BC%8F"><span class="toc-number">21.4.</span> <span class="toc-text">授权模式</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/20220516/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/" title="垃圾回收相关算法"><img src="https://zzc-sso.oss-cn-hangzhou.aliyuncs.com/bolg/JVM/src%3Dhttp___upload-images.jianshu.io_upload_images_15462057-05caf5645086f1cf.png%26refer%3Dhttp___upload-images.jianshu.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="垃圾回收相关算法"></a><div class="content"><a class="title" href="/20220516/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/" title="垃圾回收相关算法">垃圾回收相关算法</a><time datetime="2022-05-16T09:29:15.000Z" title="发表于 2022-05-16 17:29:15">2022-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/20220516/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" title="垃圾回收相关概念"><img src="https://zzc-sso.oss-cn-hangzhou.aliyuncs.com/bolg/JVM/src%3Dhttp___upload-images.jianshu.io_upload_images_15462057-05caf5645086f1cf.png%26refer%3Dhttp___upload-images.jianshu.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="垃圾回收相关概念"></a><div class="content"><a class="title" href="/20220516/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" title="垃圾回收相关概念">垃圾回收相关概念</a><time datetime="2022-05-16T09:29:15.000Z" title="发表于 2022-05-16 17:29:15">2022-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/20220516/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/" title="垃圾回收相关概念"><img src="https://zzc-sso.oss-cn-hangzhou.aliyuncs.com/bolg/JVM/src%3Dhttp___upload-images.jianshu.io_upload_images_15462057-05caf5645086f1cf.png%26refer%3Dhttp___upload-images.jianshu.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="垃圾回收相关概念"></a><div class="content"><a class="title" href="/20220516/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/" title="垃圾回收相关概念">垃圾回收相关概念</a><time datetime="2022-05-16T09:29:15.000Z" title="发表于 2022-05-16 17:29:15">2022-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/20220516/StringTable/" title="StringTable"><img src="https://zzc-sso.oss-cn-hangzhou.aliyuncs.com/bolg/JVM/src%3Dhttp___upload-images.jianshu.io_upload_images_15462057-05caf5645086f1cf.png%26refer%3Dhttp___upload-images.jianshu.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="StringTable"></a><div class="content"><a class="title" href="/20220516/StringTable/" title="StringTable">StringTable</a><time datetime="2022-05-16T05:47:39.000Z" title="发表于 2022-05-16 13:47:39">2022-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/20220515/%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/" title="本地方法栈"><img src="https://zzc-sso.oss-cn-hangzhou.aliyuncs.com/bolg/JVM/src%3Dhttp___upload-images.jianshu.io_upload_images_15462057-05caf5645086f1cf.png%26refer%3Dhttp___upload-images.jianshu.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="本地方法栈"></a><div class="content"><a class="title" href="/20220515/%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/" title="本地方法栈">本地方法栈</a><time datetime="2022-05-15T14:26:16.000Z" title="发表于 2022-05-15 22:26:16">2022-05-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 章志成</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="http://hankz.cc/">一个cv大师</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>function loadValine(){function e(){new Valine(Object.assign({el:"#vcomment",appId:"rX8EGp1QDIbaOBer0HPXb4wr-gzGzoHsz",appKey:"zYi2FKT3jfoRihSzwUQkzwd3",placeholder:"Please leave your footprints",avatar:"monsterid",meta:"nick,mail,link".split(","),pageSize:"10",lang:"zh-CN",recordIP:!1,serverURLs:"",emojiCDN:"",emojiMaps:"",enableQQ:!1,path:window.location.pathname,requiredFields:["nick,mail"],visitor:!1},null))}"function"==typeof Valine?e():getScript("https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js").then(e)}function loadOtherComment(){loadValine()}setTimeout(loadValine,0)</script></div><div class="aplayer no-destroy" data-id="84943176" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-autoplay="false" data-theme="#2980b9" data-loop="all" data-order="random" data-preload="auto" data-volume="0.4" data-mutex="true" data-listfolded="true" data-listmaxheight="340px" data-storagename="metingjs" muted></div><div class="aplayer no-destroy" data-id="https://music.163.com/playlist?id=84943176&userid=77272308" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-autoplay="true" data-theme="#2980b9" data-loop="all" data-order="random" data-preload="auto" data-volume="0.4" data-mutex="true" data-listfolded="true" data-listmaxheight="340px" data-storagename="metingjs" muted></div><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async mobile="true"></script><script>!function(t,a,n){a.ChatraID="K3d9XytKCJ4u5JfPd";var c=t.createElement("script");a[n]=a[n]||function(){(a[n].q=a[n].q||[]).push(arguments)},c.async=!0,c.src="https://call.chatra.io/chatra.js",t.head&&t.head.appendChild(c)}(document,window,"Chatra");var chatBtnFn=()=>{document.getElementById("chat_btn").addEventListener("click",function(){Chatra("openChat")})};function chatBtnHide(){Chatra("hide")}function chatBtnShow(){Chatra("show")}chatBtnFn()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:complete",function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script");var o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()}),document.addEventListener("pjax:send",function(){if("object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")}),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>