<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>手写spring系列-第3章-容器IOC-2 | 去海边</title><meta name="keywords" content="手写spring系列"><meta name="author" content="章志成"><meta name="copyright" content="章志成"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="初始化和销毁方法当我们的类创建的 Bean 对象，交给 Spring 容器管理以后，这个类对象就可以被赋予更多的使用能力 可以在 Bean 初始化过程，执行一些操作。比如帮我们做一些数据的加载执行，链接注册中心暴漏RPC接口以及在Web程序关闭时执行链接断开，内存销毁等操作。如果说没有Spring我们也可以通过构造函数、静态方法以及手动调用的方式实现，但这样的处理方式终究不如把诸如此类的操作都交给"><meta property="og:type" content="article"><meta property="og:title" content="手写spring系列-第3章-容器IOC-2"><meta property="og:url" content="http://example.com/20220607/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E5%AE%B9%E5%99%A8IOC-2/index.html"><meta property="og:site_name" content="去海边"><meta property="og:description" content="初始化和销毁方法当我们的类创建的 Bean 对象，交给 Spring 容器管理以后，这个类对象就可以被赋予更多的使用能力 可以在 Bean 初始化过程，执行一些操作。比如帮我们做一些数据的加载执行，链接注册中心暴漏RPC接口以及在Web程序关闭时执行链接断开，内存销毁等操作。如果说没有Spring我们也可以通过构造函数、静态方法以及手动调用的方式实现，但这样的处理方式终究不如把诸如此类的操作都交给"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206042241269.jpeg"><meta property="article:published_time" content="2022-06-07T15:40:17.000Z"><meta property="article:modified_time" content="2022-06-09T16:06:38.060Z"><meta property="article:author" content="章志成"><meta property="article:tag" content="手写spring系列"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206042241269.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/20220607/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E5%AE%B9%E5%99%A8IOC-2/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-left"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isanchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-06-10 00:06:38"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0!==o){const a=new Date;o=864e5*o,t={value:t,expiry:a.getTime()+o};localStorage.setItem(e,JSON.stringify(t))}},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);const o=new Date;if(!(o.getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=a=>new Promise((t,e)=>{const o=document.createElement("script");o.src=a,o.async=!0,o.onerror=e,o.onload=o.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(o.onload=o.onreadystatechange=null,t())},document.head.appendChild(o)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"))})(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/tx2.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">74</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-messageboard"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202205192232746.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">去海边</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-messageboard"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">手写spring系列-第3章-容器IOC-2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-07T15:40:17.000Z" title="发表于 2022-06-07 23:40:17">2022-06-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-09T16:06:38.060Z" title="更新于 2022-06-10 00:06:38">2022-06-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97/">手写spring系列</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="手写spring系列-第3章-容器IOC-2"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/20220607/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E5%AE%B9%E5%99%A8IOC-2/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/20220607/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E5%AE%B9%E5%99%A8IOC-2/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="初始化和销毁方法"><a href="#初始化和销毁方法" class="headerlink" title="初始化和销毁方法"></a>初始化和销毁方法</h1><p>当我们的类创建的 Bean 对象，交给 Spring 容器管理以后，这个类对象就可以被赋予更多的使用能力</p><p>可以在 Bean 初始化过程，执行一些操作。比如帮我们做一些数据的加载执行，链接注册中心暴漏RPC接口以及在Web程序关闭时执行链接断开，内存销毁等操作。<em>如果说没有Spring我们也可以通过构造函数、静态方法以及手动调用的方式实现，但这样的处理方式终究不如把诸如此类的操作都交给 Spring 容器来管理更加合适。</em></p><ul><li>需要满足用户可以在 xml 中配置初始化和销毁的方法，也可以通过实现类的方式处理，比如我们在使用 Spring 时用到的 InitializingBean, DisposableBean 两个接口。 -其实还可以有一种是注解的方式处理初始化操作，不过目前还没有实现到注解的逻辑，后续再完善此类功能</li></ul><p><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206080035152.png" alt="img"></p><ul><li>在 spring.xml 配置中添加 <code>init-method、destroy-method</code> 两个注解，在配置文件加载的过程中，把注解配置一并定义到 BeanDefinition 的属性当中。这样在 initializeBean 初始化操作的工程中，就可以通过反射的方式来调用配置在 Bean 定义属性当中的方法信息了。另外如果是接口实现的方式，那么直接可以通过 Bean 对象调用对应接口定义的方法即可，<code>((InitializingBean) bean).afterPropertiesSet()</code>，两种方式达到的效果是一样的。</li><li>除了在初始化做的操作外，<code>destroy-method</code> 和 <code>DisposableBean</code> 接口的定义，都会在 Bean 对象初始化完成阶段，执行注册销毁方法的信息到 DefaultSingletonBeanRegistry 类中的 disposableBeans 属性里，这是为了后续统一进行操作。<em>这里还有一段适配器的使用，因为反射调用和接口直接调用，是两种方式。所以需要使用适配器进行包装</em></li></ul><p><em>参考 DisposableBeanAdapter 的具体实现</em> -关于销毁方法需要在虚拟机执行关闭之前进行操作，所以这里需要用到一个注册钩子的操作，如：<code>Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; System.out.println(&quot;close！&quot;)));</code></p><p><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206080037210.png" alt="图 8-4"></p><ul><li>以上整个类图结构描述出来的就是本次新增 Bean 实例化过程中的初始化方法和销毁方法。</li><li>因为我们一共实现了两种方式的初始化和销毁方法，xml配置和定义接口，所以这里既有 InitializingBean、DisposableBean 也有需要 XmlBeanDefinitionReader 加载 spring.xml 配置信息到 BeanDefinition 中。</li><li>另外接口 ConfigurableBeanFactory 定义了 destroySingletons 销毁方法，并由 AbstractBeanFactory 继承的父类 DefaultSingletonBeanRegistry 实现 ConfigurableBeanFactory 接口定义的 destroySingletons 方法。<em>把实现接口的操作又交给继承的父类处理。是一种不错的隔离分层服务的设计方式</em></li><li>最后就是关于向虚拟机注册钩子，保证在虚拟机关闭之前，执行销毁操作。<code>Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; System.out.println(&quot;close！&quot;)));</code></li></ul><h3 id="定义初始化和销毁方法的接口"><a href="#定义初始化和销毁方法的接口" class="headerlink" title="定义初始化和销毁方法的接口"></a>定义初始化和销毁方法的接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Bean 处理了属性填充后调用</span><br><span class="line">     * </span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void afterPropertiesSet() throws Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    void destroy() throws Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>InitializingBean、DisposableBean，两个接口方法还是比较常用的，在一些需要结合 Spring 实现的组件中，经常会使用这两个方法来做一些参数的初始化和销毁操作。比如接口暴漏、数据库数据读取、配置文件加载等等</li></ul><h3 id="Bean属性定义新增初始化和销毁"><a href="#Bean属性定义新增初始化和销毁" class="headerlink" title="Bean属性定义新增初始化和销毁"></a>Bean属性定义新增初始化和销毁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class BeanDefinition &#123;</span><br><span class="line"></span><br><span class="line">    private Class beanClass;</span><br><span class="line"></span><br><span class="line">    private PropertyValues propertyValues;</span><br><span class="line"></span><br><span class="line">    private String initMethodName;</span><br><span class="line">    </span><br><span class="line">    private String destroyMethodName;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; ...get&#x2F;set</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>在 BeanDefinition 新增加了两个属性：initMethodName、destroyMethodName，这两个属性是为了在 spring.xml 配置的 Bean 对象中，可以配置 <code>init-method=&quot;initDataMethod&quot; destroy-method=&quot;destroyDataMethod&quot;</code> 操作，最终实现接口的效果是一样的。<em>只不过一个是接口方法的直接调用，另外是一个在配置文件中读取到方法反射调用</em></li></ul><h3 id="执行-Bean-对象的初始化方法"><a href="#执行-Bean-对象的初始化方法" class="headerlink" title="执行 Bean 对象的初始化方法"></a>执行 Bean 对象的初始化方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory implements AutowireCapableBeanFactory &#123;</span><br><span class="line"></span><br><span class="line">    private InstantiationStrategy instantiationStrategy &#x3D; new CglibSubclassingInstantiationStrategy();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object createBean(String beanName, BeanDefinition beanDefinition, Object[] args) throws BeansException &#123;</span><br><span class="line">        Object bean &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            bean &#x3D; createBeanInstance(beanDefinition, beanName, args);</span><br><span class="line">            &#x2F;&#x2F; 给 Bean 填充属性</span><br><span class="line">            applyPropertyValues(beanName, bean, beanDefinition);</span><br><span class="line">            &#x2F;&#x2F; 执行 Bean 的初始化方法和 BeanPostProcessor 的前置和后置处理方法</span><br><span class="line">            bean &#x3D; initializeBean(beanName, bean, beanDefinition);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new BeansException(&quot;Instantiation of bean failed&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">        addSingleton(beanName, bean);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Object initializeBean(String beanName, Object bean, BeanDefinition beanDefinition) &#123;</span><br><span class="line">        &#x2F;&#x2F; 1. 执行 BeanPostProcessor Before 处理</span><br><span class="line">        Object wrappedBean &#x3D; applyBeanPostProcessorsBeforeInitialization(bean, beanName);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 执行 Bean 对象的初始化方法</span><br><span class="line">        try &#123;</span><br><span class="line">            invokeInitMethods(beanName, wrappedBean, beanDefinition);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new BeansException(&quot;Invocation of init method of bean[&quot; + beanName + &quot;] failed&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2. 执行 BeanPostProcessor After 处理</span><br><span class="line">        wrappedBean &#x3D; applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">        return wrappedBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void invokeInitMethods(String beanName, Object bean, BeanDefinition beanDefinition) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 1. 实现接口 InitializingBean</span><br><span class="line">        if (bean instanceof InitializingBean) &#123;</span><br><span class="line">            ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2. 配置信息 init-method &#123;判断是为了避免二次执行销毁&#125;</span><br><span class="line">        String initMethodName &#x3D; beanDefinition.getInitMethodName();</span><br><span class="line">        if (StrUtil.isNotEmpty(initMethodName)) &#123;</span><br><span class="line">            Method initMethod &#x3D; beanDefinition.getBeanClass().getMethod(initMethodName);</span><br><span class="line">            if (null &#x3D;&#x3D; initMethod) &#123;</span><br><span class="line">                throw new BeansException(&quot;Could not find an init method named &#39;&quot; + initMethodName + &quot;&#39; on bean with name &#39;&quot; + beanName + &quot;&#39;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            initMethod.invoke(bean);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>抽象类 AbstractAutowireCapableBeanFactory 中的 createBean 是用来创建 Bean 对象的方法，在这个方法中我们之前已经扩展了 BeanFactoryPostProcessor、BeanPostProcessor 操作，这里我们继续完善执行 Bean 对象的初始化方法的处理动作。</li><li>在方法 invokeInitMethods 中，主要分为两块来执行实现了 InitializingBean 接口的操作，处理 afterPropertiesSet 方法。另外一个是判断配置信息 init-method 是否存在，执行反射调用 initMethod.invoke(bean)。这两种方式都可以在 Bean 对象初始化过程中进行处理加载 Bean 对象中的初始化操作，让使用者可以额外新增加自己想要的动作。</li></ul><h3 id="定义销毁方法适配器-接口和配置"><a href="#定义销毁方法适配器-接口和配置" class="headerlink" title="定义销毁方法适配器(接口和配置)"></a>定义销毁方法适配器(接口和配置)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class DisposableBeanAdapter implements DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    private final Object bean;</span><br><span class="line">    private final String beanName;</span><br><span class="line">    private String destroyMethodName;</span><br><span class="line"></span><br><span class="line">    public DisposableBeanAdapter(Object bean, String beanName, BeanDefinition beanDefinition) &#123;</span><br><span class="line">        this.bean &#x3D; bean;</span><br><span class="line">        this.beanName &#x3D; beanName;</span><br><span class="line">        this.destroyMethodName &#x3D; beanDefinition.getDestroyMethodName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 1. 实现接口 DisposableBean</span><br><span class="line">        if (bean instanceof DisposableBean) &#123;</span><br><span class="line">            ((DisposableBean) bean).destroy();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2. 配置信息 destroy-method &#123;判断是为了避免二次执行销毁&#125;</span><br><span class="line">        if (StrUtil.isNotEmpty(destroyMethodName) &amp;&amp; !(bean instanceof DisposableBean &amp;&amp; &quot;destroy&quot;.equals(this.destroyMethodName))) &#123;</span><br><span class="line">            Method destroyMethod &#x3D; bean.getClass().getMethod(destroyMethodName);</span><br><span class="line">            if (null &#x3D;&#x3D; destroyMethod) &#123;</span><br><span class="line">                throw new BeansException(&quot;Couldn&#39;t find a destroy method named &#39;&quot; + destroyMethodName + &quot;&#39; on bean with name &#39;&quot; + beanName + &quot;&#39;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            destroyMethod.invoke(bean);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>这里怎么有一个适配器的类呢，因为销毁方法有两种甚至多种方式，目前有<code>实现接口 DisposableBean</code>、<code>配置信息 destroy-method</code>，两种方式。而这两种方式的销毁动作是由 AbstractApplicationContext 在注册虚拟机钩子后看，虚拟机关闭前执行的操作动作。</li><li>那么在销毁执行时不太希望还得关注都销毁那些类型的方法，它的使用上更希望是有一个统一的接口进行销毁，所以这里就新增了适配类，做统一处理。</li></ul><h3 id="创建Bean时注册销毁方法对象"><a href="#创建Bean时注册销毁方法对象" class="headerlink" title="创建Bean时注册销毁方法对象"></a>创建Bean时注册销毁方法对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory implements AutowireCapableBeanFactory &#123;</span><br><span class="line"></span><br><span class="line">    private InstantiationStrategy instantiationStrategy &#x3D; new CglibSubclassingInstantiationStrategy();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object createBean(String beanName, BeanDefinition beanDefinition, Object[] args) throws BeansException &#123;</span><br><span class="line">        Object bean &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            bean &#x3D; createBeanInstance(beanDefinition, beanName, args);</span><br><span class="line">            &#x2F;&#x2F; 给 Bean 填充属性</span><br><span class="line">            applyPropertyValues(beanName, bean, beanDefinition);</span><br><span class="line">            &#x2F;&#x2F; 执行 Bean 的初始化方法和 BeanPostProcessor 的前置和后置处理方法</span><br><span class="line">            bean &#x3D; initializeBean(beanName, bean, beanDefinition);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new BeansException(&quot;Instantiation of bean failed&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 注册实现了 DisposableBean 接口的 Bean 对象</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, beanDefinition);</span><br><span class="line"></span><br><span class="line">        addSingleton(beanName, bean);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void registerDisposableBeanIfNecessary(String beanName, Object bean, BeanDefinition beanDefinition) &#123;</span><br><span class="line">        if (bean instanceof DisposableBean || StrUtil.isNotEmpty(beanDefinition.getDestroyMethodName())) &#123;</span><br><span class="line">            registerDisposableBean(beanName, new DisposableBeanAdapter(bean, beanName, beanDefinition));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>在创建 Bean 对象的实例的时候，需要把销毁方法保存起来，方便后续执行销毁动作进行调用。</li><li>那么这个销毁方法的具体方法信息，会被注册到 DefaultSingletonBeanRegistry 中新增加的 <code>Map&lt;String, DisposableBean&gt; disposableBeans</code> 属性中去，因为这个接口的方法最终可以被类 AbstractApplicationContext 的 close 方法通过 <code>getBeanFactory().destroySingletons()</code> 调用。</li><li>在注册销毁方法的时候，会根据是接口类型和配置类型统一交给 DisposableBeanAdapter 销毁适配器类来做统一处理。<em>实现了某个接口的类可以被 instanceof 判断或者强转后调用接口方法</em></li></ul><h3 id="虚拟机关闭钩子注册调用销毁方法"><a href="#虚拟机关闭钩子注册调用销毁方法" class="headerlink" title="虚拟机关闭钩子注册调用销毁方法"></a>虚拟机关闭钩子注册调用销毁方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface ConfigurableApplicationContext extends ApplicationContext &#123;</span><br><span class="line"></span><br><span class="line">    void refresh() throws BeansException;</span><br><span class="line"></span><br><span class="line">    void registerShutdownHook();</span><br><span class="line"></span><br><span class="line">    void close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先我们需要在 ConfigurableApplicationContext 接口中定义注册虚拟机钩子的方法 <code>registerShutdownHook</code> 和手动执行关闭的方法 <code>close</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void registerShutdownHook() &#123;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(new Thread(this::close));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void close() &#123;</span><br><span class="line">        getBeanFactory().destroySingletons();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>这里主要体现了关于注册钩子和关闭的方法实现</li></ul><p><strong>TEST</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class UserDao &#123;</span><br><span class="line"></span><br><span class="line">    private static Map&lt;String, String&gt; hashMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void initDataMethod()&#123;</span><br><span class="line">        System.out.println(&quot;执行：init-method&quot;);</span><br><span class="line">        hashMap.put(&quot;10001&quot;, &quot;zzc1&quot;);</span><br><span class="line">        hashMap.put(&quot;10002&quot;, &quot;zzc2&quot;);</span><br><span class="line">        hashMap.put(&quot;10003&quot;, &quot;zzc3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void destroyDataMethod()&#123;</span><br><span class="line">        System.out.println(&quot;执行：destroy-method&quot;);</span><br><span class="line">        hashMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String queryUserName(String uId) &#123;</span><br><span class="line">        return hashMap.get(uId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class UserService implements InitializingBean, DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    private String uId;</span><br><span class="line">    private String company;</span><br><span class="line">    private String location;</span><br><span class="line">    private UserDao userDao;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;执行：UserService.destroy&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;执行：UserService.afterPropertiesSet&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...get&#x2F;set</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>UserDao，修改了之前使用 static 静态块初始化数据的方式，改为提供 initDataMethod 和 destroyDataMethod 两个更优雅的操作方式进行处理。</li><li>UserService，以实现接口 InitializingBean, DisposableBean 的两个方法 destroy()、afterPropertiesSet()，处理相应的初始化和销毁方法的动作。<em>afterPropertiesSet，方法名字很好，在属性设置后执行</em></li></ul><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;cn.bugstack.springframework.test.bean.UserDao&quot; init-method&#x3D;&quot;initDataMethod&quot; destroy-method&#x3D;&quot;destroyDataMethod&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;cn.bugstack.springframework.test.bean.UserService&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;uId&quot; value&#x3D;&quot;10001&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;company&quot; value&#x3D;&quot;腾讯&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;location&quot; value&#x3D;&quot;深圳&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;userDao&quot; ref&#x3D;&quot;userDao&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>配置文件中主要是新增了，<code>init-method=&quot;initDataMethod&quot; destroy-method=&quot;destroyDataMethod&quot;</code>，这样两个配置。从源码的学习中可以知道，这两个配置是为了加入到 BeanDefinition 定义类之后写入到类 DefaultListableBeanFactory 中的 beanDefinitionMap 属性中去</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test_xml() &#123;</span><br><span class="line">    &#x2F;&#x2F; 1.初始化 BeanFactory</span><br><span class="line">    ClassPathXmlApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;classpath:spring.xml&quot;);</span><br><span class="line">    applicationContext.registerShutdownHook();      </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2. 获取Bean对象调用方法</span><br><span class="line">    UserService userService &#x3D; applicationContext.getBean(&quot;userService&quot;, UserService.class);</span><br><span class="line">    String result &#x3D; userService.queryUserInfo();</span><br><span class="line">    System.out.println(&quot;测试结果：&quot; + result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>成了关于初始和销毁在使用接口定义 <code>implements InitializingBean, DisposableBean</code> 和在spring.xml中配置 <code>init-method=&quot;initDataMethod&quot; destroy-method=&quot;destroyDataMethod&quot;</code> 的两种具体在 <code>AbstractAutowireCapableBeanFactory</code> 完成初始方法和 <code>AbstractApplicationContext</code> 处理销毁动作的具体实现过程。</p><p>可以看到目前这个 Spring 框架对 Bean 的操作越来越完善了，可扩展性也不断的增强。你既可以在Bean注册完成实例化前进行 BeanFactoryPostProcessor 操作，也可以在Bean实例化过程中执行前置和后置操作，现在又可以执行Bean的初始化方法和销毁方法。所以一个简单的Bean对象，已经被赋予了各种扩展能力</p><p>A继承B实现C时，C的接口方法由A继承的父类B实现。可以复用到通常的业务系统开发中进行处理一些复杂逻辑的功能分层，做到程序的可扩展、易维护等特性。</p><h1 id="实现感知容器对象"><a href="#实现感知容器对象" class="headerlink" title="实现感知容器对象"></a>实现感知容器对象</h1><p><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206092351024.png" alt="img"></p><ul><li>定义接口 Aware，在 Spring 框架中它是一种感知标记性接口，具体的子类定义和实现能感知容器中的相关对象。<em>也就是通过这个桥梁，向具体的实现类中提供容器服务</em></li><li>继承 Aware 的接口包括：BeanFactoryAware、BeanClassLoaderAware、BeanNameAware和ApplicationContextAware</li></ul><p><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206092353180.png" alt="图 9-2"></p><ul><li>Aware 有四个继承的接口，其他这些接口的继承都是为了继承一个标记，有了标记的存在更方便类的操作和具体判断实现。</li><li>另外由于 ApplicationContext 并不是在 AbstractAutowireCapableBeanFactory 中 createBean 方法下的内容，所以需要像容器中注册 <code>addBeanPostProcessor</code> ，再由 createBean 统一调用 applyBeanPostProcessorsBeforeInitialization 时进行操作</li></ul><h3 id="定义标记接口"><a href="#定义标记接口" class="headerlink" title="定义标记接口"></a>定义标记接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Marker superinterface indicating that a bean is eligible to be</span><br><span class="line"> * notified by the Spring container of a particular framework object</span><br><span class="line"> * through a callback-style method.  Actual method signature is</span><br><span class="line"> * determined by individual subinterfaces, but should typically</span><br><span class="line"> * consist of just one void-returning method that accepts a single</span><br><span class="line"> * argument.</span><br><span class="line"> *</span><br><span class="line"> * 标记类接口，实现该接口可以被Spring容器感知</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface Aware &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>在 Spring 中有特别多类似这样的标记接口的设计方式，它们的存在就像是一种标签一样，可以方便统一摘取出属于此类接口的实现类，通常会有 instanceof 一起判断使用</li></ul><h3 id="容器感知类"><a href="#容器感知类" class="headerlink" title="容器感知类"></a>容器感知类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanFactoryAware extends Aware &#123;</span><br><span class="line"></span><br><span class="line">   void setBeanFactory(BeanFactory beanFactory) throws BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface BeanClassLoaderAware extends Aware&#123;</span><br><span class="line"></span><br><span class="line">    void setBeanClassLoader(ClassLoader classLoader);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public interface BeanNameAware extends Aware &#123;</span><br><span class="line"></span><br><span class="line">    void setBeanName(String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public interface ApplicationContextAware extends Aware &#123;</span><br><span class="line"></span><br><span class="line">    void setApplicationContext(ApplicationContext applicationContext) throws BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="包装处理器-ApplicationContextAwareProcessor"><a href="#包装处理器-ApplicationContextAwareProcessor" class="headerlink" title="包装处理器(ApplicationContextAwareProcessor)"></a>包装处理器(ApplicationContextAwareProcessor)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ApplicationContextAwareProcessor implements BeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">    private final ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    public ApplicationContextAwareProcessor(ApplicationContext applicationContext) &#123;</span><br><span class="line">        this.applicationContext &#x3D; applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        if (bean instanceof ApplicationContextAware)&#123;</span><br><span class="line">            ((ApplicationContextAware) bean).setApplicationContext(applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>由于 ApplicationContext 的获取并不能直接在创建 Bean 时候就可以拿到，所以需要在 refresh 操作时，把 ApplicationContext 写入到一个包装的 BeanPostProcessor 中去，再由 AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization 方法调用</li></ul><h3 id="注册-BeanPostProcessor"><a href="#注册-BeanPostProcessor" class="headerlink" title="注册 BeanPostProcessor"></a>注册 BeanPostProcessor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void refresh() throws BeansException &#123;</span><br><span class="line">        &#x2F;&#x2F; 1. 创建 BeanFactory，并加载 BeanDefinition</span><br><span class="line">        refreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2. 获取 BeanFactory</span><br><span class="line">        ConfigurableListableBeanFactory beanFactory &#x3D; getBeanFactory();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3. 添加 ApplicationContextAwareProcessor，让继承自 ApplicationContextAware 的 Bean 对象都能感知所属的 ApplicationContext</span><br><span class="line">        beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 4. 在 Bean 实例化之前，执行 BeanFactoryPostProcessor (Invoke factory processors registered as beans in the context.)</span><br><span class="line">        invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 5. BeanPostProcessor 需要提前于其他 Bean 对象实例化之前执行注册操作</span><br><span class="line">        registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 6. 提前实例化单例Bean对象</span><br><span class="line">        beanFactory.preInstantiateSingletons();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> 	&#x2F;&#x2F; ...   </span><br><span class="line">&#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>refresh() 方法就是整个 Spring 容器的操作过程。本次新增加了关于 addBeanPostProcessor 的操作。</p></li><li><p>添加 ApplicationContextAwareProcessor，让继承自 ApplicationContextAware 的 Bean 对象都能感知所属的 ApplicationContext</p></li></ul><h3 id="感知调用操作"><a href="#感知调用操作" class="headerlink" title="感知调用操作"></a>感知调用操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory implements AutowireCapableBeanFactory &#123;</span><br><span class="line"></span><br><span class="line">    private InstantiationStrategy instantiationStrategy &#x3D; new CglibSubclassingInstantiationStrategy();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object createBean(String beanName, BeanDefinition beanDefinition, Object[] args) throws BeansException &#123;</span><br><span class="line">        Object bean &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            bean &#x3D; createBeanInstance(beanDefinition, beanName, args);</span><br><span class="line">            &#x2F;&#x2F; 给 Bean 填充属性</span><br><span class="line">            applyPropertyValues(beanName, bean, beanDefinition);</span><br><span class="line">            &#x2F;&#x2F; 执行 Bean 的初始化方法和 BeanPostProcessor 的前置和后置处理方法</span><br><span class="line">            bean &#x3D; initializeBean(beanName, bean, beanDefinition);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new BeansException(&quot;Instantiation of bean failed&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 注册实现了 DisposableBean 接口的 Bean 对象</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, beanDefinition);</span><br><span class="line"></span><br><span class="line">        addSingleton(beanName, bean);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Object initializeBean(String beanName, Object bean, BeanDefinition beanDefinition) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; invokeAwareMethods</span><br><span class="line">        if (bean instanceof Aware) &#123;</span><br><span class="line">            if (bean instanceof BeanFactoryAware) &#123;</span><br><span class="line">                ((BeanFactoryAware) bean).setBeanFactory(this);</span><br><span class="line">            &#125;</span><br><span class="line">            if (bean instanceof BeanClassLoaderAware)&#123;</span><br><span class="line">                ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());</span><br><span class="line">            &#125;</span><br><span class="line">            if (bean instanceof BeanNameAware) &#123;</span><br><span class="line">                ((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 1. 执行 BeanPostProcessor Before 处理</span><br><span class="line">        Object wrappedBean &#x3D; applyBeanPostProcessorsBeforeInitialization(bean, beanName);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 执行 Bean 对象的初始化方法</span><br><span class="line">        try &#123;</span><br><span class="line">            invokeInitMethods(beanName, wrappedBean, beanDefinition);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new BeansException(&quot;Invocation of init method of bean[&quot; + beanName + &quot;] failed&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2. 执行 BeanPostProcessor After 处理</span><br><span class="line">        wrappedBean &#x3D; applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">        return wrappedBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) throws BeansException &#123;</span><br><span class="line">        Object result &#x3D; existingBean;</span><br><span class="line">        for (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">            Object current &#x3D; processor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">            if (null &#x3D;&#x3D; current) return result;</span><br><span class="line">            result &#x3D; current;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) throws BeansException &#123;</span><br><span class="line">        Object result &#x3D; existingBean;</span><br><span class="line">        for (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">            Object current &#x3D; processor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">            if (null &#x3D;&#x3D; current) return result;</span><br><span class="line">            result &#x3D; current;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>首先在 initializeBean 中，通过判断 <code>bean instanceof Aware</code>，调用了三个接口方法，<code>BeanFactoryAware.setBeanFactory(this)</code>、<code>BeanClassLoaderAware.setBeanClassLoader(getBeanClassLoader())</code>、<code>BeanNameAware.setBeanName(beanName)</code>，这样就能通知到已经实现了此接口的类。</li><li>另外我们还向 BeanPostProcessor 中添加了 <code>ApplicationContextAwareProcessor</code>，此时在这个方法中也会被调用到具体的类实现，得到一个 ApplicationContex 属性</li></ul><p><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206092359525.png" alt="图 9-3"></p><h1 id="对象作用域以及FactoryBean"><a href="#对象作用域以及FactoryBean" class="headerlink" title="对象作用域以及FactoryBean"></a>对象作用域以及FactoryBean</h1><p>交给 Spring 管理的 Bean 对象，一定就是我们用类创建出来的 Bean 吗？创建出来的 Bean 就永远是单例的吗，没有可能是原型模式吗？</p><p><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206100004876.png" alt="img"></p><ul><li><p>整个的实现过程包括了两部分，一个解决单例还是原型对象，另外一个处理 FactoryBean 类型对象创建过程中关于获取具体调用对象的 <code>getObject</code> 操作</p></li><li><p><code>SCOPE_SINGLETON</code>、<code>SCOPE_PROTOTYPE</code>，对象类型的创建获取方式，主要区分在于 <code>AbstractAutowireCapableBeanFactory#createBean</code> 创建完成对象后是否放入到内存中，如果不放入则每次获取都会重新创建。</p></li><li><p>createBean 执行对象创建、属性填充、依赖加载、前置后置处理、初始化等操作后，就要开始做执行判断整个对象是否是一个 FactoryBean 对象，如果是这样的对象，就需要再继续执行获取 FactoryBean 具体对象中的 <code>getObject</code> 对象了。整个 getBean 过程中都会新增一个单例类型的判断<code>factory.isSingleton()</code>，用于决定是否使用内存存放对象信息。</p></li></ul><p><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206100006516.png" alt="图 10-2"></p></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97/">手写spring系列</a></div><div class="post_share"><div class="social-share" data-image="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206042241269.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/kele.png" target="_blank"><img class="post-qr-code-img" src="/img/kele.png" alt="觉得还不错，请他喝一瓶可乐"></a><div class="post-qr-code-desc">觉得还不错，请他喝一瓶可乐</div></li><li class="reward-item"><a href="/img/ali.jpg" target="_blank"><img class="post-qr-code-img" src="/img/ali.jpg" alt="雪碧也是可以的"></a><div class="post-qr-code-desc">雪碧也是可以的</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/20220605/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Bean%E5%AE%B9%E5%99%A8/"><img class="next-cover" src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206042241269.jpeg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">手写spring系列-第2章-容器IOC-1</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/20220604/手写spring系列-第1章-源码整理解析/" title="手写spring系列-第1章-源码整体解析"><img class="cover" src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206042241269.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-04</div><div class="title">手写spring系列-第1章-源码整体解析</div></div></a></div><div><a href="/20220605/手写spring系列-第2章-实现一个简单的Bean容器/" title="手写spring系列-第2章-容器IOC-1"><img class="cover" src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206042241269.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-05</div><div class="title">手写spring系列-第2章-容器IOC-1</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/tx2.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"><div class="author-info__name">章志成</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">74</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/gump12138"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/cooper12138" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:994739211@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">延迟满足</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">初始化和销毁方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.0.1.</span> <span class="toc-text">定义初始化和销毁方法的接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B9%89%E6%96%B0%E5%A2%9E%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81"><span class="toc-number">1.0.2.</span> <span class="toc-text">Bean属性定义新增初始化和销毁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C-Bean-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.3.</span> <span class="toc-text">执行 Bean 对象的初始化方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95%E9%80%82%E9%85%8D%E5%99%A8-%E6%8E%A5%E5%8F%A3%E5%92%8C%E9%85%8D%E7%BD%AE"><span class="toc-number">1.0.4.</span> <span class="toc-text">定义销毁方法适配器(接口和配置)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BABean%E6%97%B6%E6%B3%A8%E5%86%8C%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.0.5.</span> <span class="toc-text">创建Bean时注册销毁方法对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%B3%E9%97%AD%E9%92%A9%E5%AD%90%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.6.</span> <span class="toc-text">虚拟机关闭钩子注册调用销毁方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.0.7.</span> <span class="toc-text">配置文件</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%84%9F%E7%9F%A5%E5%AE%B9%E5%99%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">实现感知容器对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%A0%87%E8%AE%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.0.1.</span> <span class="toc-text">定义标记接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%84%9F%E7%9F%A5%E7%B1%BB"><span class="toc-number">2.0.2.</span> <span class="toc-text">容器感知类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E5%A4%84%E7%90%86%E5%99%A8-ApplicationContextAwareProcessor"><span class="toc-number">2.0.3.</span> <span class="toc-text">包装处理器(ApplicationContextAwareProcessor)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C-BeanPostProcessor"><span class="toc-number">2.0.4.</span> <span class="toc-text">注册 BeanPostProcessor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%9F%E7%9F%A5%E8%B0%83%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">2.0.5.</span> <span class="toc-text">感知调用操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BB%A5%E5%8F%8AFactoryBean"><span class="toc-number">3.</span> <span class="toc-text">对象作用域以及FactoryBean</span></a></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/20220607/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E5%AE%B9%E5%99%A8IOC-2/" title="手写spring系列-第3章-容器IOC-2"><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206042241269.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="手写spring系列-第3章-容器IOC-2"></a><div class="content"><a class="title" href="/20220607/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E5%AE%B9%E5%99%A8IOC-2/" title="手写spring系列-第3章-容器IOC-2">手写spring系列-第3章-容器IOC-2</a><time datetime="2022-06-07T15:40:17.000Z" title="发表于 2022-06-07 23:40:17">2022-06-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/20220605/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Bean%E5%AE%B9%E5%99%A8/" title="手写spring系列-第2章-容器IOC-1"><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206042241269.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="手写spring系列-第2章-容器IOC-1"></a><div class="content"><a class="title" href="/20220605/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Bean%E5%AE%B9%E5%99%A8/" title="手写spring系列-第2章-容器IOC-1">手写spring系列-第2章-容器IOC-1</a><time datetime="2022-06-05T12:44:03.000Z" title="发表于 2022-06-05 20:44:03">2022-06-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/20220604/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC1%E7%AB%A0-%E6%BA%90%E7%A0%81%E6%95%B4%E7%90%86%E8%A7%A3%E6%9E%90/" title="手写spring系列-第1章-源码整体解析"><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206042241269.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="手写spring系列-第1章-源码整体解析"></a><div class="content"><a class="title" href="/20220604/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC1%E7%AB%A0-%E6%BA%90%E7%A0%81%E6%95%B4%E7%90%86%E8%A7%A3%E6%9E%90/" title="手写spring系列-第1章-源码整体解析">手写spring系列-第1章-源码整体解析</a><time datetime="2022-06-04T14:29:51.000Z" title="发表于 2022-06-04 22:29:51">2022-06-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/20220524/%E4%BB%8E%E8%B7%9F%E5%84%BF%E4%B8%8A%E7%90%86%E8%A7%A3MYSQL%E7%AC%94%E8%AE%B0%E8%80%8C%E5%B7%B2/" title="mysql系列-第1章-从跟儿上理解MYSQL笔记而已"><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202205242214058.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="mysql系列-第1章-从跟儿上理解MYSQL笔记而已"></a><div class="content"><a class="title" href="/20220524/%E4%BB%8E%E8%B7%9F%E5%84%BF%E4%B8%8A%E7%90%86%E8%A7%A3MYSQL%E7%AC%94%E8%AE%B0%E8%80%8C%E5%B7%B2/" title="mysql系列-第1章-从跟儿上理解MYSQL笔记而已">mysql系列-第1章-从跟儿上理解MYSQL笔记而已</a><time datetime="2022-05-24T14:12:25.000Z" title="发表于 2022-05-24 22:12:25">2022-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/20220523/%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/" title="并发系列-第4章-案例分析"><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202205192229069.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="并发系列-第4章-案例分析"></a><div class="content"><a class="title" href="/20220523/%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/" title="并发系列-第4章-案例分析">并发系列-第4章-案例分析</a><time datetime="2022-05-22T16:24:30.000Z" title="发表于 2022-05-23 00:24:30">2022-05-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 章志成</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="http://hankz.cc/">一个cv大师</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>function loadValine(){function e(){new Valine(Object.assign({el:"#vcomment",appId:"rX8EGp1QDIbaOBer0HPXb4wr-gzGzoHsz",appKey:"zYi2FKT3jfoRihSzwUQkzwd3",placeholder:"Please leave your footprints",avatar:"monsterid",meta:"nick,mail,link".split(","),pageSize:"10",lang:"zh-CN",recordIP:!1,serverURLs:"",emojiCDN:"",emojiMaps:"",enableQQ:!1,path:window.location.pathname,requiredFields:["nick,mail"],visitor:!1},null))}"function"==typeof Valine?e():getScript("https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js").then(e)}function loadOtherComment(){loadValine()}setTimeout(loadValine,0)</script></div><div class="aplayer no-destroy" data-id="84943176" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-autoplay="false" data-theme="#2980b9" data-loop="all" data-order="random" data-preload="auto" data-volume="0.4" data-mutex="true" data-listfolded="true" data-listmaxheight="340px" data-storagename="metingjs" muted></div><div class="aplayer no-destroy" data-id="https://music.163.com/playlist?id=84943176&userid=77272308" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-autoplay="true" data-theme="#2980b9" data-loop="all" data-order="random" data-preload="auto" data-volume="0.4" data-mutex="true" data-listfolded="true" data-listmaxheight="340px" data-storagename="metingjs" muted></div><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async mobile="true"></script><script>!function(t,a,n){a.ChatraID="K3d9XytKCJ4u5JfPd";var c=t.createElement("script");a[n]=a[n]||function(){(a[n].q=a[n].q||[]).push(arguments)},c.async=!0,c.src="https://call.chatra.io/chatra.js",t.head&&t.head.appendChild(c)}(document,window,"Chatra");var chatBtnFn=()=>{document.getElementById("chat_btn").addEventListener("click",function(){Chatra("openChat")})};function chatBtnHide(){Chatra("hide")}function chatBtnShow(){Chatra("show")}chatBtnFn()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:complete",function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script");var o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()}),document.addEventListener("pjax:send",function(){if("object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")}),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>