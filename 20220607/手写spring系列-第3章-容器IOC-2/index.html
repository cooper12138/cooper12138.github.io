<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>手写spring系列-第3章-容器IOC-2 | 去海边</title><meta name="keywords" content="手写spring系列"><meta name="author" content="章志成"><meta name="copyright" content="章志成"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="初始化和销毁方法当我们的类创建的 Bean 对象，交给 Spring 容器管理以后，这个类对象就可以被赋予更多的使用能力 可以在 Bean 初始化过程，执行一些操作。比如帮我们做一些数据的加载执行，链接注册中心暴漏RPC接口以及在Web程序关闭时执行链接断开，内存销毁等操作。如果说没有Spring我们也可以通过构造函数、静态方法以及手动调用的方式实现，但这样的处理方式终究不如把诸如此类的操作都交给"><meta property="og:type" content="article"><meta property="og:title" content="手写spring系列-第3章-容器IOC-2"><meta property="og:url" content="http://example.com/20220607/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E5%AE%B9%E5%99%A8IOC-2/index.html"><meta property="og:site_name" content="去海边"><meta property="og:description" content="初始化和销毁方法当我们的类创建的 Bean 对象，交给 Spring 容器管理以后，这个类对象就可以被赋予更多的使用能力 可以在 Bean 初始化过程，执行一些操作。比如帮我们做一些数据的加载执行，链接注册中心暴漏RPC接口以及在Web程序关闭时执行链接断开，内存销毁等操作。如果说没有Spring我们也可以通过构造函数、静态方法以及手动调用的方式实现，但这样的处理方式终究不如把诸如此类的操作都交给"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206042241269.jpeg"><meta property="article:published_time" content="2022-06-07T15:40:17.000Z"><meta property="article:modified_time" content="2022-06-11T16:26:45.679Z"><meta property="article:author" content="章志成"><meta property="article:tag" content="手写spring系列"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206042241269.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/20220607/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E5%AE%B9%E5%99%A8IOC-2/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-left"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isanchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-06-12 00:26:45"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0!==o){const a=new Date;o=864e5*o,t={value:t,expiry:a.getTime()+o};localStorage.setItem(e,JSON.stringify(t))}},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);const o=new Date;if(!(o.getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=a=>new Promise((t,e)=>{const o=document.createElement("script");o.src=a,o.async=!0,o.onerror=e,o.onload=o.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(o.onload=o.onreadystatechange=null,t())},document.head.appendChild(o)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"))})(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/tx2.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">75</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-messageboard"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202205192232746.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">去海边</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-messageboard"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">手写spring系列-第3章-容器IOC-2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-07T15:40:17.000Z" title="发表于 2022-06-07 23:40:17">2022-06-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-11T16:26:45.679Z" title="更新于 2022-06-12 00:26:45">2022-06-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97/">手写spring系列</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="手写spring系列-第3章-容器IOC-2"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/20220607/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E5%AE%B9%E5%99%A8IOC-2/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/20220607/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E5%AE%B9%E5%99%A8IOC-2/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="初始化和销毁方法"><a href="#初始化和销毁方法" class="headerlink" title="初始化和销毁方法"></a>初始化和销毁方法</h1><p>当我们的类创建的 Bean 对象，交给 Spring 容器管理以后，这个类对象就可以被赋予更多的使用能力</p><p>可以在 Bean 初始化过程，执行一些操作。比如帮我们做一些数据的加载执行，链接注册中心暴漏RPC接口以及在Web程序关闭时执行链接断开，内存销毁等操作。<em>如果说没有Spring我们也可以通过构造函数、静态方法以及手动调用的方式实现，但这样的处理方式终究不如把诸如此类的操作都交给 Spring 容器来管理更加合适。</em></p><ul><li>需要满足用户可以在 xml 中配置初始化和销毁的方法，也可以通过实现类的方式处理，比如我们在使用 Spring 时用到的 InitializingBean, DisposableBean 两个接口。 -其实还可以有一种是注解的方式处理初始化操作，不过目前还没有实现到注解的逻辑，后续再完善此类功能</li></ul><p><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206080035152.png" alt="img"></p><ul><li>在 spring.xml 配置中添加 <code>init-method、destroy-method</code> 两个注解，在配置文件加载的过程中，把注解配置一并定义到 BeanDefinition 的属性当中。这样在 initializeBean 初始化操作的工程中，就可以通过反射的方式来调用配置在 Bean 定义属性当中的方法信息了。另外如果是接口实现的方式，那么直接可以通过 Bean 对象调用对应接口定义的方法即可，<code>((InitializingBean) bean).afterPropertiesSet()</code>，两种方式达到的效果是一样的。</li><li>除了在初始化做的操作外，<code>destroy-method</code> 和 <code>DisposableBean</code> 接口的定义，都会在 Bean 对象初始化完成阶段，执行注册销毁方法的信息到 DefaultSingletonBeanRegistry 类中的 disposableBeans 属性里，这是为了后续统一进行操作。<em>这里还有一段适配器的使用，因为反射调用和接口直接调用，是两种方式。所以需要使用适配器进行包装</em></li></ul><p><em>参考 DisposableBeanAdapter 的具体实现</em> -关于销毁方法需要在虚拟机执行关闭之前进行操作，所以这里需要用到一个注册钩子的操作，如：<code>Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; System.out.println(&quot;close！&quot;)));</code></p><p><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206080037210.png" alt="图 8-4"></p><ul><li>以上整个类图结构描述出来的就是本次新增 Bean 实例化过程中的初始化方法和销毁方法。</li><li>因为我们一共实现了两种方式的初始化和销毁方法，xml配置和定义接口，所以这里既有 InitializingBean、DisposableBean 也有需要 XmlBeanDefinitionReader 加载 spring.xml 配置信息到 BeanDefinition 中。</li><li>另外接口 ConfigurableBeanFactory 定义了 destroySingletons 销毁方法，并由 AbstractBeanFactory 继承的父类 DefaultSingletonBeanRegistry 实现 ConfigurableBeanFactory 接口定义的 destroySingletons 方法。<em>把实现接口的操作又交给继承的父类处理。是一种不错的隔离分层服务的设计方式</em></li><li>最后就是关于向虚拟机注册钩子，保证在虚拟机关闭之前，执行销毁操作。<code>Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; System.out.println(&quot;close！&quot;)));</code></li></ul><h3 id="定义初始化和销毁方法的接口"><a href="#定义初始化和销毁方法的接口" class="headerlink" title="定义初始化和销毁方法的接口"></a>定义初始化和销毁方法的接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Bean 处理了属性填充后调用</span><br><span class="line">     * </span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void afterPropertiesSet() throws Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    void destroy() throws Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>InitializingBean、DisposableBean，两个接口方法还是比较常用的，在一些需要结合 Spring 实现的组件中，经常会使用这两个方法来做一些参数的初始化和销毁操作。比如接口暴漏、数据库数据读取、配置文件加载等等</li></ul><h3 id="Bean属性定义新增初始化和销毁"><a href="#Bean属性定义新增初始化和销毁" class="headerlink" title="Bean属性定义新增初始化和销毁"></a>Bean属性定义新增初始化和销毁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class BeanDefinition &#123;</span><br><span class="line"></span><br><span class="line">    private Class beanClass;</span><br><span class="line"></span><br><span class="line">    private PropertyValues propertyValues;</span><br><span class="line"></span><br><span class="line">    private String initMethodName;</span><br><span class="line">    </span><br><span class="line">    private String destroyMethodName;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; ...get&#x2F;set</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>在 BeanDefinition 新增加了两个属性：initMethodName、destroyMethodName，这两个属性是为了在 spring.xml 配置的 Bean 对象中，可以配置 <code>init-method=&quot;initDataMethod&quot; destroy-method=&quot;destroyDataMethod&quot;</code> 操作，最终实现接口的效果是一样的。<em>只不过一个是接口方法的直接调用，另外是一个在配置文件中读取到方法反射调用</em></li></ul><h3 id="执行-Bean-对象的初始化方法"><a href="#执行-Bean-对象的初始化方法" class="headerlink" title="执行 Bean 对象的初始化方法"></a>执行 Bean 对象的初始化方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory implements AutowireCapableBeanFactory &#123;</span><br><span class="line"></span><br><span class="line">    private InstantiationStrategy instantiationStrategy &#x3D; new CglibSubclassingInstantiationStrategy();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object createBean(String beanName, BeanDefinition beanDefinition, Object[] args) throws BeansException &#123;</span><br><span class="line">        Object bean &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            bean &#x3D; createBeanInstance(beanDefinition, beanName, args);</span><br><span class="line">            &#x2F;&#x2F; 给 Bean 填充属性</span><br><span class="line">            applyPropertyValues(beanName, bean, beanDefinition);</span><br><span class="line">            &#x2F;&#x2F; 执行 Bean 的初始化方法和 BeanPostProcessor 的前置和后置处理方法</span><br><span class="line">            bean &#x3D; initializeBean(beanName, bean, beanDefinition);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new BeansException(&quot;Instantiation of bean failed&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">        addSingleton(beanName, bean);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Object initializeBean(String beanName, Object bean, BeanDefinition beanDefinition) &#123;</span><br><span class="line">        &#x2F;&#x2F; 1. 执行 BeanPostProcessor Before 处理</span><br><span class="line">        Object wrappedBean &#x3D; applyBeanPostProcessorsBeforeInitialization(bean, beanName);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 执行 Bean 对象的初始化方法</span><br><span class="line">        try &#123;</span><br><span class="line">            invokeInitMethods(beanName, wrappedBean, beanDefinition);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new BeansException(&quot;Invocation of init method of bean[&quot; + beanName + &quot;] failed&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2. 执行 BeanPostProcessor After 处理</span><br><span class="line">        wrappedBean &#x3D; applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">        return wrappedBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void invokeInitMethods(String beanName, Object bean, BeanDefinition beanDefinition) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 1. 实现接口 InitializingBean</span><br><span class="line">        if (bean instanceof InitializingBean) &#123;</span><br><span class="line">            ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2. 配置信息 init-method &#123;判断是为了避免二次执行销毁&#125;</span><br><span class="line">        String initMethodName &#x3D; beanDefinition.getInitMethodName();</span><br><span class="line">        if (StrUtil.isNotEmpty(initMethodName)) &#123;</span><br><span class="line">            Method initMethod &#x3D; beanDefinition.getBeanClass().getMethod(initMethodName);</span><br><span class="line">            if (null &#x3D;&#x3D; initMethod) &#123;</span><br><span class="line">                throw new BeansException(&quot;Could not find an init method named &#39;&quot; + initMethodName + &quot;&#39; on bean with name &#39;&quot; + beanName + &quot;&#39;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            initMethod.invoke(bean);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>抽象类 AbstractAutowireCapableBeanFactory 中的 createBean 是用来创建 Bean 对象的方法，在这个方法中我们之前已经扩展了 BeanFactoryPostProcessor、BeanPostProcessor 操作，这里我们继续完善执行 Bean 对象的初始化方法的处理动作。</li><li>在方法 invokeInitMethods 中，主要分为两块来执行实现了 InitializingBean 接口的操作，处理 afterPropertiesSet 方法。另外一个是判断配置信息 init-method 是否存在，执行反射调用 initMethod.invoke(bean)。这两种方式都可以在 Bean 对象初始化过程中进行处理加载 Bean 对象中的初始化操作，让使用者可以额外新增加自己想要的动作。</li></ul><h3 id="定义销毁方法适配器-接口和配置"><a href="#定义销毁方法适配器-接口和配置" class="headerlink" title="定义销毁方法适配器(接口和配置)"></a>定义销毁方法适配器(接口和配置)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class DisposableBeanAdapter implements DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    private final Object bean;</span><br><span class="line">    private final String beanName;</span><br><span class="line">    private String destroyMethodName;</span><br><span class="line"></span><br><span class="line">    public DisposableBeanAdapter(Object bean, String beanName, BeanDefinition beanDefinition) &#123;</span><br><span class="line">        this.bean &#x3D; bean;</span><br><span class="line">        this.beanName &#x3D; beanName;</span><br><span class="line">        this.destroyMethodName &#x3D; beanDefinition.getDestroyMethodName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 1. 实现接口 DisposableBean</span><br><span class="line">        if (bean instanceof DisposableBean) &#123;</span><br><span class="line">            ((DisposableBean) bean).destroy();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2. 配置信息 destroy-method &#123;判断是为了避免二次执行销毁&#125;</span><br><span class="line">        if (StrUtil.isNotEmpty(destroyMethodName) &amp;&amp; !(bean instanceof DisposableBean &amp;&amp; &quot;destroy&quot;.equals(this.destroyMethodName))) &#123;</span><br><span class="line">            Method destroyMethod &#x3D; bean.getClass().getMethod(destroyMethodName);</span><br><span class="line">            if (null &#x3D;&#x3D; destroyMethod) &#123;</span><br><span class="line">                throw new BeansException(&quot;Couldn&#39;t find a destroy method named &#39;&quot; + destroyMethodName + &quot;&#39; on bean with name &#39;&quot; + beanName + &quot;&#39;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            destroyMethod.invoke(bean);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>这里怎么有一个适配器的类呢，因为销毁方法有两种甚至多种方式，目前有<code>实现接口 DisposableBean</code>、<code>配置信息 destroy-method</code>，两种方式。而这两种方式的销毁动作是由 AbstractApplicationContext 在注册虚拟机钩子后看，虚拟机关闭前执行的操作动作。</li><li>那么在销毁执行时不太希望还得关注都销毁那些类型的方法，它的使用上更希望是有一个统一的接口进行销毁，所以这里就新增了适配类，做统一处理。</li></ul><h3 id="创建Bean时注册销毁方法对象"><a href="#创建Bean时注册销毁方法对象" class="headerlink" title="创建Bean时注册销毁方法对象"></a>创建Bean时注册销毁方法对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory implements AutowireCapableBeanFactory &#123;</span><br><span class="line"></span><br><span class="line">    private InstantiationStrategy instantiationStrategy &#x3D; new CglibSubclassingInstantiationStrategy();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object createBean(String beanName, BeanDefinition beanDefinition, Object[] args) throws BeansException &#123;</span><br><span class="line">        Object bean &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            bean &#x3D; createBeanInstance(beanDefinition, beanName, args);</span><br><span class="line">            &#x2F;&#x2F; 给 Bean 填充属性</span><br><span class="line">            applyPropertyValues(beanName, bean, beanDefinition);</span><br><span class="line">            &#x2F;&#x2F; 执行 Bean 的初始化方法和 BeanPostProcessor 的前置和后置处理方法</span><br><span class="line">            bean &#x3D; initializeBean(beanName, bean, beanDefinition);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new BeansException(&quot;Instantiation of bean failed&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 注册实现了 DisposableBean 接口的 Bean 对象</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, beanDefinition);</span><br><span class="line"></span><br><span class="line">        addSingleton(beanName, bean);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void registerDisposableBeanIfNecessary(String beanName, Object bean, BeanDefinition beanDefinition) &#123;</span><br><span class="line">        if (bean instanceof DisposableBean || StrUtil.isNotEmpty(beanDefinition.getDestroyMethodName())) &#123;</span><br><span class="line">            registerDisposableBean(beanName, new DisposableBeanAdapter(bean, beanName, beanDefinition));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>在创建 Bean 对象的实例的时候，需要把销毁方法保存起来，方便后续执行销毁动作进行调用。</li><li>那么这个销毁方法的具体方法信息，会被注册到 DefaultSingletonBeanRegistry 中新增加的 <code>Map&lt;String, DisposableBean&gt; disposableBeans</code> 属性中去，因为这个接口的方法最终可以被类 AbstractApplicationContext 的 close 方法通过 <code>getBeanFactory().destroySingletons()</code> 调用。</li><li>在注册销毁方法的时候，会根据是接口类型和配置类型统一交给 DisposableBeanAdapter 销毁适配器类来做统一处理。<em>实现了某个接口的类可以被 instanceof 判断或者强转后调用接口方法</em></li></ul><h3 id="虚拟机关闭钩子注册调用销毁方法"><a href="#虚拟机关闭钩子注册调用销毁方法" class="headerlink" title="虚拟机关闭钩子注册调用销毁方法"></a>虚拟机关闭钩子注册调用销毁方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface ConfigurableApplicationContext extends ApplicationContext &#123;</span><br><span class="line"></span><br><span class="line">    void refresh() throws BeansException;</span><br><span class="line"></span><br><span class="line">    void registerShutdownHook();</span><br><span class="line"></span><br><span class="line">    void close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先我们需要在 ConfigurableApplicationContext 接口中定义注册虚拟机钩子的方法 <code>registerShutdownHook</code> 和手动执行关闭的方法 <code>close</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void registerShutdownHook() &#123;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(new Thread(this::close));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void close() &#123;</span><br><span class="line">        getBeanFactory().destroySingletons();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>这里主要体现了关于注册钩子和关闭的方法实现</li></ul><p><strong>TEST</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class UserDao &#123;</span><br><span class="line"></span><br><span class="line">    private static Map&lt;String, String&gt; hashMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void initDataMethod()&#123;</span><br><span class="line">        System.out.println(&quot;执行：init-method&quot;);</span><br><span class="line">        hashMap.put(&quot;10001&quot;, &quot;zzc1&quot;);</span><br><span class="line">        hashMap.put(&quot;10002&quot;, &quot;zzc2&quot;);</span><br><span class="line">        hashMap.put(&quot;10003&quot;, &quot;zzc3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void destroyDataMethod()&#123;</span><br><span class="line">        System.out.println(&quot;执行：destroy-method&quot;);</span><br><span class="line">        hashMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String queryUserName(String uId) &#123;</span><br><span class="line">        return hashMap.get(uId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class UserService implements InitializingBean, DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    private String uId;</span><br><span class="line">    private String company;</span><br><span class="line">    private String location;</span><br><span class="line">    private UserDao userDao;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;执行：UserService.destroy&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;执行：UserService.afterPropertiesSet&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...get&#x2F;set</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>UserDao，修改了之前使用 static 静态块初始化数据的方式，改为提供 initDataMethod 和 destroyDataMethod 两个更优雅的操作方式进行处理。</li><li>UserService，以实现接口 InitializingBean, DisposableBean 的两个方法 destroy()、afterPropertiesSet()，处理相应的初始化和销毁方法的动作。<em>afterPropertiesSet，方法名字很好，在属性设置后执行</em></li></ul><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;cn.bugstack.springframework.test.bean.UserDao&quot; init-method&#x3D;&quot;initDataMethod&quot; destroy-method&#x3D;&quot;destroyDataMethod&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;cn.bugstack.springframework.test.bean.UserService&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;uId&quot; value&#x3D;&quot;10001&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;company&quot; value&#x3D;&quot;腾讯&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;location&quot; value&#x3D;&quot;深圳&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;userDao&quot; ref&#x3D;&quot;userDao&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>配置文件中主要是新增了，<code>init-method=&quot;initDataMethod&quot; destroy-method=&quot;destroyDataMethod&quot;</code>，这样两个配置。从源码的学习中可以知道，这两个配置是为了加入到 BeanDefinition 定义类之后写入到类 DefaultListableBeanFactory 中的 beanDefinitionMap 属性中去</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test_xml() &#123;</span><br><span class="line">    &#x2F;&#x2F; 1.初始化 BeanFactory</span><br><span class="line">    ClassPathXmlApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;classpath:spring.xml&quot;);</span><br><span class="line">    applicationContext.registerShutdownHook();      </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2. 获取Bean对象调用方法</span><br><span class="line">    UserService userService &#x3D; applicationContext.getBean(&quot;userService&quot;, UserService.class);</span><br><span class="line">    String result &#x3D; userService.queryUserInfo();</span><br><span class="line">    System.out.println(&quot;测试结果：&quot; + result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>成了关于初始和销毁在使用接口定义 <code>implements InitializingBean, DisposableBean</code> 和在spring.xml中配置 <code>init-method=&quot;initDataMethod&quot; destroy-method=&quot;destroyDataMethod&quot;</code> 的两种具体在 <code>AbstractAutowireCapableBeanFactory</code> 完成初始方法和 <code>AbstractApplicationContext</code> 处理销毁动作的具体实现过程。</p><p>可以看到目前这个 Spring 框架对 Bean 的操作越来越完善了，可扩展性也不断的增强。你既可以在Bean注册完成实例化前进行 BeanFactoryPostProcessor 操作，也可以在Bean实例化过程中执行前置和后置操作，现在又可以执行Bean的初始化方法和销毁方法。所以一个简单的Bean对象，已经被赋予了各种扩展能力</p><p>A继承B实现C时，C的接口方法由A继承的父类B实现。可以复用到通常的业务系统开发中进行处理一些复杂逻辑的功能分层，做到程序的可扩展、易维护等特性。</p><h1 id="实现感知容器对象"><a href="#实现感知容器对象" class="headerlink" title="实现感知容器对象"></a>实现感知容器对象</h1><p><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206092351024.png" alt="img"></p><ul><li>定义接口 Aware，在 Spring 框架中它是一种感知标记性接口，具体的子类定义和实现能感知容器中的相关对象。<em>也就是通过这个桥梁，向具体的实现类中提供容器服务</em></li><li>继承 Aware 的接口包括：BeanFactoryAware、BeanClassLoaderAware、BeanNameAware和ApplicationContextAware</li></ul><p><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206092353180.png" alt="图 9-2"></p><ul><li>Aware 有四个继承的接口，其他这些接口的继承都是为了继承一个标记，有了标记的存在更方便类的操作和具体判断实现。</li><li>另外由于 ApplicationContext 并不是在 AbstractAutowireCapableBeanFactory 中 createBean 方法下的内容，所以需要像容器中注册 <code>addBeanPostProcessor</code> ，再由 createBean 统一调用 applyBeanPostProcessorsBeforeInitialization 时进行操作</li></ul><h3 id="定义标记接口"><a href="#定义标记接口" class="headerlink" title="定义标记接口"></a>定义标记接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Marker superinterface indicating that a bean is eligible to be</span><br><span class="line"> * notified by the Spring container of a particular framework object</span><br><span class="line"> * through a callback-style method.  Actual method signature is</span><br><span class="line"> * determined by individual subinterfaces, but should typically</span><br><span class="line"> * consist of just one void-returning method that accepts a single</span><br><span class="line"> * argument.</span><br><span class="line"> *</span><br><span class="line"> * 标记类接口，实现该接口可以被Spring容器感知</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface Aware &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>在 Spring 中有特别多类似这样的标记接口的设计方式，它们的存在就像是一种标签一样，可以方便统一摘取出属于此类接口的实现类，通常会有 instanceof 一起判断使用</li></ul><h3 id="容器感知类"><a href="#容器感知类" class="headerlink" title="容器感知类"></a>容器感知类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanFactoryAware extends Aware &#123;</span><br><span class="line"></span><br><span class="line">   void setBeanFactory(BeanFactory beanFactory) throws BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface BeanClassLoaderAware extends Aware&#123;</span><br><span class="line"></span><br><span class="line">    void setBeanClassLoader(ClassLoader classLoader);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public interface BeanNameAware extends Aware &#123;</span><br><span class="line"></span><br><span class="line">    void setBeanName(String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public interface ApplicationContextAware extends Aware &#123;</span><br><span class="line"></span><br><span class="line">    void setApplicationContext(ApplicationContext applicationContext) throws BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="包装处理器-ApplicationContextAwareProcessor"><a href="#包装处理器-ApplicationContextAwareProcessor" class="headerlink" title="包装处理器(ApplicationContextAwareProcessor)"></a>包装处理器(ApplicationContextAwareProcessor)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ApplicationContextAwareProcessor implements BeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">    private final ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    public ApplicationContextAwareProcessor(ApplicationContext applicationContext) &#123;</span><br><span class="line">        this.applicationContext &#x3D; applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        if (bean instanceof ApplicationContextAware)&#123;</span><br><span class="line">            ((ApplicationContextAware) bean).setApplicationContext(applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>由于 ApplicationContext 的获取并不能直接在创建 Bean 时候就可以拿到，所以需要在 refresh 操作时，把 ApplicationContext 写入到一个包装的 BeanPostProcessor 中去，再由 AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization 方法调用</li></ul><h3 id="注册-BeanPostProcessor"><a href="#注册-BeanPostProcessor" class="headerlink" title="注册 BeanPostProcessor"></a>注册 BeanPostProcessor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void refresh() throws BeansException &#123;</span><br><span class="line">        &#x2F;&#x2F; 1. 创建 BeanFactory，并加载 BeanDefinition</span><br><span class="line">        refreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2. 获取 BeanFactory</span><br><span class="line">        ConfigurableListableBeanFactory beanFactory &#x3D; getBeanFactory();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3. 添加 ApplicationContextAwareProcessor，让继承自 ApplicationContextAware 的 Bean 对象都能感知所属的 ApplicationContext</span><br><span class="line">        beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 4. 在 Bean 实例化之前，执行 BeanFactoryPostProcessor (Invoke factory processors registered as beans in the context.)</span><br><span class="line">        invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 5. BeanPostProcessor 需要提前于其他 Bean 对象实例化之前执行注册操作</span><br><span class="line">        registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 6. 提前实例化单例Bean对象</span><br><span class="line">        beanFactory.preInstantiateSingletons();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> 	&#x2F;&#x2F; ...   </span><br><span class="line">&#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>refresh() 方法就是整个 Spring 容器的操作过程。本次新增加了关于 addBeanPostProcessor 的操作。</p></li><li><p>添加 ApplicationContextAwareProcessor，让继承自 ApplicationContextAware 的 Bean 对象都能感知所属的 ApplicationContext</p></li></ul><h3 id="感知调用操作"><a href="#感知调用操作" class="headerlink" title="感知调用操作"></a>感知调用操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory implements AutowireCapableBeanFactory &#123;</span><br><span class="line"></span><br><span class="line">    private InstantiationStrategy instantiationStrategy &#x3D; new CglibSubclassingInstantiationStrategy();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object createBean(String beanName, BeanDefinition beanDefinition, Object[] args) throws BeansException &#123;</span><br><span class="line">        Object bean &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            bean &#x3D; createBeanInstance(beanDefinition, beanName, args);</span><br><span class="line">            &#x2F;&#x2F; 给 Bean 填充属性</span><br><span class="line">            applyPropertyValues(beanName, bean, beanDefinition);</span><br><span class="line">            &#x2F;&#x2F; 执行 Bean 的初始化方法和 BeanPostProcessor 的前置和后置处理方法</span><br><span class="line">            bean &#x3D; initializeBean(beanName, bean, beanDefinition);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new BeansException(&quot;Instantiation of bean failed&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 注册实现了 DisposableBean 接口的 Bean 对象</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, beanDefinition);</span><br><span class="line"></span><br><span class="line">        addSingleton(beanName, bean);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Object initializeBean(String beanName, Object bean, BeanDefinition beanDefinition) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; invokeAwareMethods</span><br><span class="line">        if (bean instanceof Aware) &#123;</span><br><span class="line">            if (bean instanceof BeanFactoryAware) &#123;</span><br><span class="line">                ((BeanFactoryAware) bean).setBeanFactory(this);</span><br><span class="line">            &#125;</span><br><span class="line">            if (bean instanceof BeanClassLoaderAware)&#123;</span><br><span class="line">                ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());</span><br><span class="line">            &#125;</span><br><span class="line">            if (bean instanceof BeanNameAware) &#123;</span><br><span class="line">                ((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 1. 执行 BeanPostProcessor Before 处理</span><br><span class="line">        Object wrappedBean &#x3D; applyBeanPostProcessorsBeforeInitialization(bean, beanName);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 执行 Bean 对象的初始化方法</span><br><span class="line">        try &#123;</span><br><span class="line">            invokeInitMethods(beanName, wrappedBean, beanDefinition);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new BeansException(&quot;Invocation of init method of bean[&quot; + beanName + &quot;] failed&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2. 执行 BeanPostProcessor After 处理</span><br><span class="line">        wrappedBean &#x3D; applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">        return wrappedBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) throws BeansException &#123;</span><br><span class="line">        Object result &#x3D; existingBean;</span><br><span class="line">        for (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">            Object current &#x3D; processor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">            if (null &#x3D;&#x3D; current) return result;</span><br><span class="line">            result &#x3D; current;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) throws BeansException &#123;</span><br><span class="line">        Object result &#x3D; existingBean;</span><br><span class="line">        for (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">            Object current &#x3D; processor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">            if (null &#x3D;&#x3D; current) return result;</span><br><span class="line">            result &#x3D; current;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>首先在 initializeBean 中，通过判断 <code>bean instanceof Aware</code>，调用了三个接口方法，<code>BeanFactoryAware.setBeanFactory(this)</code>、<code>BeanClassLoaderAware.setBeanClassLoader(getBeanClassLoader())</code>、<code>BeanNameAware.setBeanName(beanName)</code>，这样就能通知到已经实现了此接口的类。</li><li>另外我们还向 BeanPostProcessor 中添加了 <code>ApplicationContextAwareProcessor</code>，此时在这个方法中也会被调用到具体的类实现，得到一个 ApplicationContex 属性</li></ul><p><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206092359525.png" alt="图 9-3"></p><h1 id="对象作用域以及FactoryBean"><a href="#对象作用域以及FactoryBean" class="headerlink" title="对象作用域以及FactoryBean"></a>对象作用域以及FactoryBean</h1><p>交给 Spring 管理的 Bean 对象，一定就是我们用类创建出来的 Bean 吗？创建出来的 Bean 就永远是单例的吗，没有可能是原型模式吗？</p><p><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206100004876.png" alt="img"></p><ul><li><p>整个的实现过程包括了两部分，一个解决单例还是原型对象，另外一个处理 FactoryBean 类型对象创建过程中关于获取具体调用对象的 <code>getObject</code> 操作</p></li><li><p><code>SCOPE_SINGLETON</code>、<code>SCOPE_PROTOTYPE</code>，对象类型的创建获取方式，主要区分在于 <code>AbstractAutowireCapableBeanFactory#createBean</code> 创建完成对象后是否放入到内存中，如果不放入则每次获取都会重新创建。</p></li><li><p>createBean 执行对象创建、属性填充、依赖加载、前置后置处理、初始化等操作后，就要开始做执行判断整个对象是否是一个 FactoryBean 对象，如果是这样的对象，就需要再继续执行获取 FactoryBean 具体对象中的 <code>getObject</code> 对象了。整个 getBean 过程中都会新增一个单例类型的判断<code>factory.isSingleton()</code>，用于决定是否使用内存存放对象信息。</p></li></ul><p><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206100006516.png" alt="图 10-2"></p><ul><li>以上整个类关系图展示的就是添加 Bean 的实例化是单例还是原型模式以及 FactoryBean 的实现。</li><li>其实整个实现的过程并不复杂，只是在现有的 AbstractAutowireCapableBeanFactory 类以及继承的抽象类 AbstractBeanFactory 中进行扩展。</li><li>不过这次我们把 AbstractBeanFactory 继承的 DefaultSingletonBeanRegistry 类，中间加了一层 FactoryBeanRegistrySupport，这个类在 Spring 框架中主要是处理关于 FactoryBean 注册的支撑操作</li></ul><h3 id="Bean的作用范围定义和xml解析"><a href="#Bean的作用范围定义和xml解析" class="headerlink" title="Bean的作用范围定义和xml解析"></a>Bean的作用范围定义和xml解析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class BeanDefinition &#123;</span><br><span class="line"></span><br><span class="line">    String SCOPE_SINGLETON &#x3D; ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line"></span><br><span class="line">    String SCOPE_PROTOTYPE &#x3D; ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line">    private Class beanClass;</span><br><span class="line"></span><br><span class="line">    private PropertyValues propertyValues;</span><br><span class="line"></span><br><span class="line">    private String initMethodName;</span><br><span class="line"></span><br><span class="line">    private String destroyMethodName;</span><br><span class="line"></span><br><span class="line">    private String scope &#x3D; SCOPE_SINGLETON;</span><br><span class="line"></span><br><span class="line">    private boolean singleton &#x3D; true;</span><br><span class="line"></span><br><span class="line">    private boolean prototype &#x3D; false;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; ...get&#x2F;set</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>singleton、prototype，是本次在 BeanDefinition 类中新增加的两个属性信息，用于把从 spring.xml 中解析到的 Bean 对象作用范围填充到属性中。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class XmlBeanDefinitionReader extends AbstractBeanDefinitionReader &#123;</span><br><span class="line"></span><br><span class="line">    protected void doLoadBeanDefinitions(InputStream inputStream) throws ClassNotFoundException &#123;</span><br><span class="line">      </span><br><span class="line">        for (int i &#x3D; 0; i &lt; childNodes.getLength(); i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 判断元素</span><br><span class="line">            if (!(childNodes.item(i) instanceof Element)) continue;</span><br><span class="line">            &#x2F;&#x2F; 判断对象</span><br><span class="line">            if (!&quot;bean&quot;.equals(childNodes.item(i).getNodeName())) continue;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 解析标签</span><br><span class="line">            Element bean &#x3D; (Element) childNodes.item(i);</span><br><span class="line">            String id &#x3D; bean.getAttribute(&quot;id&quot;);</span><br><span class="line">            String name &#x3D; bean.getAttribute(&quot;name&quot;);</span><br><span class="line">            String className &#x3D; bean.getAttribute(&quot;class&quot;);</span><br><span class="line">            String initMethod &#x3D; bean.getAttribute(&quot;init-method&quot;);</span><br><span class="line">            String destroyMethodName &#x3D; bean.getAttribute(&quot;destroy-method&quot;);</span><br><span class="line">            String beanScope &#x3D; bean.getAttribute(&quot;scope&quot;);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 获取 Class，方便获取类中的名称</span><br><span class="line">            Class&lt;?&gt; clazz &#x3D; Class.forName(className);</span><br><span class="line">            &#x2F;&#x2F; 优先级 id &gt; name</span><br><span class="line">            String beanName &#x3D; StrUtil.isNotEmpty(id) ? id : name;</span><br><span class="line">            if (StrUtil.isEmpty(beanName)) &#123;</span><br><span class="line">                beanName &#x3D; StrUtil.lowerFirst(clazz.getSimpleName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 定义Bean</span><br><span class="line">            BeanDefinition beanDefinition &#x3D; new BeanDefinition(clazz);</span><br><span class="line">            beanDefinition.setInitMethodName(initMethod);</span><br><span class="line">            beanDefinition.setDestroyMethodName(destroyMethodName);</span><br><span class="line"></span><br><span class="line">            if (StrUtil.isNotEmpty(beanScope)) &#123;</span><br><span class="line">                beanDefinition.setScope(beanScope);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 注册 BeanDefinition</span><br><span class="line">            getRegistry().registerBeanDefinition(beanName, beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>在解析 XML 处理类 XmlBeanDefinitionReader 中，新增加了关于 Bean 对象配置中 scope 的解析，并把这个属性信息填充到 Bean 定义中。<code>beanDefinition.setScope(beanScope)</code></li></ul><h3 id="创建和修改对象时候判断单例和原型模式"><a href="#创建和修改对象时候判断单例和原型模式" class="headerlink" title="创建和修改对象时候判断单例和原型模式"></a>创建和修改对象时候判断单例和原型模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractAutowireCapableBeanFactory extends AbstractBeanFactory implements AutowireCapableBeanFactory &#123;</span><br><span class="line"></span><br><span class="line">    private InstantiationStrategy instantiationStrategy &#x3D; new CglibSubclassingInstantiationStrategy();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object createBean(String beanName, BeanDefinition beanDefinition, Object[] args) throws BeansException &#123;</span><br><span class="line">        Object bean &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            bean &#x3D; createBeanInstance(beanDefinition, beanName, args);</span><br><span class="line">            &#x2F;&#x2F; 给 Bean 填充属性</span><br><span class="line">            applyPropertyValues(beanName, bean, beanDefinition);</span><br><span class="line">            &#x2F;&#x2F; 执行 Bean 的初始化方法和 BeanPostProcessor 的前置和后置处理方法</span><br><span class="line">            bean &#x3D; initializeBean(beanName, bean, beanDefinition);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new BeansException(&quot;Instantiation of bean failed&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 注册实现了 DisposableBean 接口的 Bean 对象</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, beanDefinition);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 判断 SCOPE_SINGLETON、SCOPE_PROTOTYPE</span><br><span class="line">        if (beanDefinition.isSingleton()) &#123;</span><br><span class="line">            addSingleton(beanName, bean);</span><br><span class="line">        &#125;</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void registerDisposableBeanIfNecessary(String beanName, Object bean, BeanDefinition beanDefinition) &#123;</span><br><span class="line">        &#x2F;&#x2F; 非 Singleton 类型的 Bean 不执行销毁方法</span><br><span class="line">        if (!beanDefinition.isSingleton()) return;</span><br><span class="line"></span><br><span class="line">        if (bean instanceof DisposableBean || StrUtil.isNotEmpty(beanDefinition.getDestroyMethodName())) &#123;</span><br><span class="line">            registerDisposableBean(beanName, new DisposableBeanAdapter(bean, beanName, beanDefinition));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; ... 其他功能</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>单例模式和原型模式的区别就在于是否存放到内存中，如果是原型模式那么就不会存放到内存中，每次获取都重新创建对象，另外非 Singleton 类型的 Bean 不需要执行销毁方法。</li><li>所以这里的代码会有两处修改，一处是 createBean 中判断是否添加到 addSingleton(beanName, bean);，另外一处是 registerDisposableBeanIfNecessary 销毁注册中的判断 <code>if (!beanDefinition.isSingleton()) return;</code></li></ul><h3 id="定义-FactoryBean-接口"><a href="#定义-FactoryBean-接口" class="headerlink" title="定义 FactoryBean 接口"></a>定义 FactoryBean 接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface FactoryBean&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    T getObject() throws Exception;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">    boolean isSingleton();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>FactoryBean 中需要提供3个方法，获取对象、对象类型，以及是否是单例对象，如果是单例对象依然会被放到内存中。</li></ul><h3 id="实现一个-FactoryBean-注册服务"><a href="#实现一个-FactoryBean-注册服务" class="headerlink" title="实现一个 FactoryBean 注册服务"></a>实现一个 FactoryBean 注册服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public abstract class FactoryBeanRegistrySupport extends DefaultSingletonBeanRegistry &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Cache of singleton objects created by FactoryBeans: FactoryBean name --&gt; object</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private final Map&lt;String, Object&gt; factoryBeanObjectCache &#x3D; new ConcurrentHashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    protected Object getCachedObjectForFactoryBean(String beanName) &#123;</span><br><span class="line">        Object object &#x3D; this.factoryBeanObjectCache.get(beanName);</span><br><span class="line">        return (object !&#x3D; NULL_OBJECT ? object : null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Object getObjectFromFactoryBean(FactoryBean factory, String beanName) &#123;</span><br><span class="line">        if (factory.isSingleton()) &#123;</span><br><span class="line">            Object object &#x3D; this.factoryBeanObjectCache.get(beanName);</span><br><span class="line">            if (object &#x3D;&#x3D; null) &#123;</span><br><span class="line">                object &#x3D; doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">                this.factoryBeanObjectCache.put(beanName, (object !&#x3D; null ? object : NULL_OBJECT));</span><br><span class="line">            &#125;</span><br><span class="line">            return (object !&#x3D; NULL_OBJECT ? object : null);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Object doGetObjectFromFactoryBean(final FactoryBean factory, final String beanName)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return factory.getObject();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new BeansException(&quot;FactoryBean threw exception on object[&quot; + beanName + &quot;] creation&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>FactoryBeanRegistrySupport 类主要处理的就是关于 FactoryBean 此类对象的注册操作，之所以放到这样一个单独的类里，就是希望做到不同领域模块下只负责各自需要完成的功能，避免因为扩展导致类膨胀到难以维护。</li><li>同样这里也定义了缓存操作 factoryBeanObjectCache，用于存放单例类型的对象，避免重复创建。<em>在日常使用用，基本也都是创建的单例对象</em></li><li>doGetObjectFromFactoryBean 是具体的获取 FactoryBean#getObject() 方法，因为既有缓存的处理也有对象的获取，所以额外提供了 getObjectFromFactoryBean 进行逻辑包装</li></ul><h3 id="扩展-AbstractBeanFactory-创建对象逻辑"><a href="#扩展-AbstractBeanFactory-创建对象逻辑" class="headerlink" title="扩展 AbstractBeanFactory 创建对象逻辑"></a>扩展 AbstractBeanFactory 创建对象逻辑</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory &#123;</span><br><span class="line"></span><br><span class="line">    protected &lt;T&gt; T doGetBean(final String name, final Object[] args) &#123;</span><br><span class="line">        Object sharedInstance &#x3D; getSingleton(name);</span><br><span class="line">        if (sharedInstance !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果是 FactoryBean，则需要调用 FactoryBean#getObject</span><br><span class="line">            return (T) getObjectForBeanInstance(sharedInstance, name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BeanDefinition beanDefinition &#x3D; getBeanDefinition(name);</span><br><span class="line">        Object bean &#x3D; createBean(name, beanDefinition, args);</span><br><span class="line">        return (T) getObjectForBeanInstance(bean, name);</span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">    private Object getObjectForBeanInstance(Object beanInstance, String beanName) &#123;</span><br><span class="line">        if (!(beanInstance instanceof FactoryBean)) &#123;</span><br><span class="line">            return beanInstance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object object &#x3D; getCachedObjectForFactoryBean(beanName);</span><br><span class="line"></span><br><span class="line">        if (object &#x3D;&#x3D; null) &#123;</span><br><span class="line">            FactoryBean&lt;?&gt; factoryBean &#x3D; (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">            object &#x3D; getObjectFromFactoryBean(factoryBean, beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>首先这里把 AbstractBeanFactory 原来继承的 DefaultSingletonBeanRegistry，修改为继承 FactoryBeanRegistrySupport。因为需要扩展出创建 FactoryBean 对象的能力，所以这就想一个链条服务上，截出一个段来处理额外的服务，并把链条再链接上。</li><li>此处新增加的功能主要是在 doGetBean 方法中，添加了调用 <code>(T) getObjectForBeanInstance(sharedInstance, name)</code> 对获取 FactoryBean 的操作。</li><li>在 getObjectForBeanInstance 方法中做具体的 instanceof 判断，另外还会从 FactoryBean 的缓存中获取对象，如果不存在则调用 FactoryBeanRegistrySupport#getObjectFromFactoryBean，执行具体的操作</li></ul><p><strong>TEST</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface IUserDao &#123;</span><br><span class="line"></span><br><span class="line">    String queryUserName(String uId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">    private String uId;</span><br><span class="line">    private String company;</span><br><span class="line">    private String location;</span><br><span class="line">    private IUserDao userDao;</span><br><span class="line"></span><br><span class="line">    public String queryUserInfo() &#123;</span><br><span class="line">        return userDao.queryUserName(uId) + &quot;,&quot; + company + &quot;,&quot; + location;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...get&#x2F;set</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ProxyBeanFactory implements FactoryBean&lt;IUserDao&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IUserDao getObject() throws Exception &#123;</span><br><span class="line">        InvocationHandler handler &#x3D; (proxy, method, args) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            Map&lt;String, String&gt; hashMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">            hashMap.put(&quot;10001&quot;, &quot;小傅哥&quot;);</span><br><span class="line">            hashMap.put(&quot;10002&quot;, &quot;八杯水&quot;);</span><br><span class="line">            hashMap.put(&quot;10003&quot;, &quot;阿毛&quot;);</span><br><span class="line">            </span><br><span class="line">            return &quot;你被代理了 &quot; + method.getName() + &quot;：&quot; + hashMap.get(args[0].toString());</span><br><span class="line">        &#125;;</span><br><span class="line">        return (IUserDao) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class[]&#123;IUserDao.class&#125;, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        return IUserDao.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isSingleton() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>这是一个实现接口 FactoryBean 的代理类 ProxyBeanFactory 名称，主要是模拟了 UserDao 的原有功能，类似于 MyBatis 框架中的代理操作。</li><li>getObject() 中提供的就是一个 InvocationHandler 的代理对象，当有方法调用的时候，则执行代理对象的功能</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;cn.bugstack.springframework.test.bean.UserService&quot; scope&#x3D;&quot;prototype&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;uId&quot; value&#x3D;&quot;10001&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;company&quot; value&#x3D;&quot;腾讯&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;location&quot; value&#x3D;&quot;深圳&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;userDao&quot; ref&#x3D;&quot;proxyUserDao&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;proxyUserDao&quot; class&#x3D;&quot;cn.bugstack.springframework.test.bean.ProxyBeanFactory&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test_prototype() &#123;</span><br><span class="line">    &#x2F;&#x2F; 1.初始化 BeanFactory</span><br><span class="line">    ClassPathXmlApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;classpath:spring.xml&quot;);</span><br><span class="line">    applicationContext.registerShutdownHook();   </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2. 获取Bean对象调用方法</span><br><span class="line">    UserService userService01 &#x3D; applicationContext.getBean(&quot;userService&quot;, UserService.class);</span><br><span class="line">    UserService userService02 &#x3D; applicationContext.getBean(&quot;userService&quot;, UserService.class);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 3. 配置 scope&#x3D;&quot;prototype&#x2F;singleton&quot;</span><br><span class="line">    System.out.println(userService01);</span><br><span class="line">    System.out.println(userService02);    </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 4. 打印十六进制哈希</span><br><span class="line">    System.out.println(userService01 + &quot; 十六进制哈希：&quot; + Integer.toHexString(userService01.hashCode()));</span><br><span class="line">    System.out.println(ClassLayout.parseInstance(userService01).toPrintable());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>在 spring.xml 配置文件中，设置了 scope=”prototype” 这样就每次获取到的对象都应该是一个新的对象。</li><li>这里判断对象是否为一个会看到打印的类对象的哈希值，所以我们把十六进制哈希打印出来</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test_factory_bean() &#123;</span><br><span class="line">    &#x2F;&#x2F; 1.初始化 BeanFactory</span><br><span class="line">    ClassPathXmlApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;classpath:spring.xml&quot;);</span><br><span class="line">    applicationContext.registerShutdownHook(); </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2. 调用代理方法</span><br><span class="line">    UserService userService &#x3D; applicationContext.getBean(&quot;userService&quot;, UserService.class);</span><br><span class="line">    System.out.println(&quot;测试结果：&quot; + userService.queryUserInfo());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="容器事件和事件监听器"><a href="#容器事件和事件监听器" class="headerlink" title="容器事件和事件监听器"></a>容器事件和事件监听器</h1><p>如：<code>这里需要一个注册完成事件推送消息</code>、<code>用户下单我会发送一个MQ</code>、<code>收到我的支付消息就可以发货了</code>等等，都是依靠事件订阅和发布以及MQ消息这样的组件，来处理系统之间的调用解耦，最终通过解耦的方式来提升整体系统架构的负载能力。</p><p>其实解耦思路可以理解为设计模式中观察者模式的具体使用效果，在观察者模式中当对象间存在一对多关系时，则使用观察者模式，它是一种定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p>在 Spring 中有一个 Event 事件功能，它可以提供事件的定义、发布以及监听事件来完成一些自定义的动作。比如你可以定义一个新用户注册的事件，当有用户执行注册完成后，在事件监听中给用户发送一些优惠券和短信提醒，这样的操作就可以把属于基本功能的注册和对应的策略服务分开，降低系统的耦合。以后在扩展注册服务，比如需要添加风控策略、添加实名认证、判断用户属性等都不会影响到依赖注册成功后执行的动作。</p><p>我们需要以观察者模式的方式，设计和实现 Spring Event 的容器事件和事件监听器功能，最终可以让我们在现有实现的 Spring 框架中可以定义、监听和发布自己的事件信息</p><p>其实事件的设计本身就是一种观察者模式的实现，它所要解决的就是一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p><p>在功能实现上我们需要定义出事件类、事件监听、事件发布，而这些类的功能需要结合到 Spring 的 AbstractApplicationContext#refresh()，以便于处理事件初始化和注册事件监听器的操作</p><p><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206120010099.png" alt="img"></p><ul><li>在整个功能实现过程中，仍然需要在面向用户的应用上下文 <code>AbstractApplicationContext</code> 中添加相关事件内容，包括：初始化事件发布者、注册事件监听器、发布容器刷新完成事件。</li><li>使用观察者模式定义事件类、监听类、发布类，同时还需要完成一个广播器的功能，接收到事件推送时进行分析处理符合监听事件接受者感兴趣的事件，也就是使用 isAssignableFrom 进行判断。</li><li>isAssignableFrom 和 instanceof 相似，不过 isAssignableFrom 是用来判断子类和父类的关系的，或者接口的实现类和接口的关系的，默认所有的类的终极父类都是Object。如果A.isAssignableFrom(B)结果是true，证明B可以转换成为A,也就是A可以由B转换而来</li></ul><p><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206120011041.png" alt="图 10-2"></p><ul><li>以上整个类关系图以围绕实现 event 事件定义、发布、监听功能实现和把事件的相关内容使用 AbstractApplicationContext#refresh 进行注册和处理操作。</li><li>在实现的过程中主要以扩展 spring context 包为主，事件的实现也是在这个包下进行扩展的，当然也可以看出来目前所有的实现内容，仍然是以IOC为主。</li><li>ApplicationContext 容器继承事件发布功能接口 ApplicationEventPublisher，并在实现类中提供事件监听功能。</li><li>ApplicationEventMulticaster 接口是注册监听器和发布事件的广播器，提供添加、移除和发布事件方法。</li><li>最后是发布容器关闭事件，这个仍然需要扩展到 AbstractApplicationContext#close 方法中，由注册到虚拟机的钩子实现</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ApplicationEvent extends EventObject &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Constructs a prototypical Event.</span><br><span class="line">     *</span><br><span class="line">     * @param source The object on which the Event initially occurred.</span><br><span class="line">     * @throws IllegalArgumentException if source is null.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public ApplicationEvent(Object source) &#123;</span><br><span class="line">        super(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>以继承 java.util.EventObject 定义出具备事件功能的抽象类 ApplicationEvent，后续所有事件的类都需要继承这个类。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ApplicationContextEvent extends ApplicationEvent &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Constructs a prototypical Event.</span><br><span class="line">     *</span><br><span class="line">     * @param source The object on which the Event initially occurred.</span><br><span class="line">     * @throws IllegalArgumentException if source is null.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public ApplicationContextEvent(Object source) &#123;</span><br><span class="line">        super(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Get the &lt;code&gt;ApplicationContext&lt;&#x2F;code&gt; that the event was raised for.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public final ApplicationContext getApplicationContext() &#123;</span><br><span class="line">        return (ApplicationContext) getSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ContextClosedEvent extends ApplicationContextEvent&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Constructs a prototypical Event.</span><br><span class="line">     *</span><br><span class="line">     * @param source The object on which the Event initially occurred.</span><br><span class="line">     * @throws IllegalArgumentException if source is null.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public ContextClosedEvent(Object source) &#123;</span><br><span class="line">        super(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ContextRefreshedEvent extends ApplicationContextEvent&#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Constructs a prototypical Event.</span><br><span class="line">     *</span><br><span class="line">     * @param source The object on which the Event initially occurred.</span><br><span class="line">     * @throws IllegalArgumentException if source is null.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public ContextRefreshedEvent(Object source) &#123;</span><br><span class="line">        super(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>ApplicationContextEvent 是定义事件的抽象类，所有的事件包括关闭、刷新，以及用户自己实现的事件，都需要继承这个类。</li><li>ContextClosedEvent、ContextRefreshedEvent，分别是 Spring 框架自己实现的两个事件类，可以用于监听刷新和关闭动作</li></ul><h3 id="事件广播器"><a href="#事件广播器" class="headerlink" title="事件广播器"></a>事件广播器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public interface ApplicationEventMulticaster &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Add a listener to be notified of all events.</span><br><span class="line">     * @param listener the listener to add</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void addApplicationListener(ApplicationListener&lt;?&gt; listener);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Remove a listener from the notification list.</span><br><span class="line">     * @param listener the listener to remove</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void removeApplicationListener(ApplicationListener&lt;?&gt; listener);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Multicast the given application event to appropriate listeners.</span><br><span class="line">     * @param event the event to multicast</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void multicastEvent(ApplicationEvent event);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>在事件广播器中定义了添加监听和删除监听的方法以及一个广播事件的方法 <code>multicastEvent</code> 最终推送时间消息也会经过这个接口方法来处理谁该接收事件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractApplicationEventMulticaster implements ApplicationEventMulticaster, BeanFactoryAware &#123;</span><br><span class="line"></span><br><span class="line">    public final Set&lt;ApplicationListener&lt;ApplicationEvent&gt;&gt; applicationListeners &#x3D; new LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addApplicationListener(ApplicationListener&lt;?&gt; listener) &#123;</span><br><span class="line">        applicationListeners.add((ApplicationListener&lt;ApplicationEvent&gt;) listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void removeApplicationListener(ApplicationListener&lt;?&gt; listener) &#123;</span><br><span class="line">        applicationListeners.remove(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public final void setBeanFactory(BeanFactory beanFactory) &#123;</span><br><span class="line">        this.beanFactory &#x3D; beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Collection&lt;ApplicationListener&gt; getApplicationListeners(ApplicationEvent event) &#123;</span><br><span class="line">        LinkedList&lt;ApplicationListener&gt; allListeners &#x3D; new LinkedList&lt;ApplicationListener&gt;();</span><br><span class="line">        for (ApplicationListener&lt;ApplicationEvent&gt; listener : applicationListeners) &#123;</span><br><span class="line">            if (supportsEvent(listener, event)) allListeners.add(listener);</span><br><span class="line">        &#125;</span><br><span class="line">        return allListeners;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 监听器是否对该事件感兴趣</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected boolean supportsEvent(ApplicationListener&lt;ApplicationEvent&gt; applicationListener, ApplicationEvent event) &#123;</span><br><span class="line">        Class&lt;? extends ApplicationListener&gt; listenerClass &#x3D; applicationListener.getClass();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 按照 CglibSubclassingInstantiationStrategy、SimpleInstantiationStrategy 不同的实例化类型，需要判断后获取目标 class</span><br><span class="line">        Class&lt;?&gt; targetClass &#x3D; ClassUtils.isCglibProxyClass(listenerClass) ? listenerClass.getSuperclass() : listenerClass;</span><br><span class="line">        Type genericInterface &#x3D; targetClass.getGenericInterfaces()[0];</span><br><span class="line"></span><br><span class="line">        Type actualTypeArgument &#x3D; ((ParameterizedType) genericInterface).getActualTypeArguments()[0];</span><br><span class="line">        String className &#x3D; actualTypeArgument.getTypeName();</span><br><span class="line">        Class&lt;?&gt; eventClassName;</span><br><span class="line">        try &#123;</span><br><span class="line">            eventClassName &#x3D; Class.forName(className);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            throw new BeansException(&quot;wrong event class name: &quot; + className);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 判定此 eventClassName 对象所表示的类或接口与指定的 event.getClass() 参数所表示的类或接口是否相同，或是否是其超类或超接口。</span><br><span class="line">        &#x2F;&#x2F; isAssignableFrom是用来判断子类和父类的关系的，或者接口的实现类和接口的关系的，默认所有的类的终极父类都是Object。如果A.isAssignableFrom(B)结果是true，证明B可以转换成为A,也就是A可以由B转换而来。</span><br><span class="line">        return eventClassName.isAssignableFrom(event.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>AbstractApplicationEventMulticaster 是对事件广播器的公用方法提取，在这个类中可以实现一些基本功能，避免所有直接实现接口放还需要处理细节。</li><li>除了像 addApplicationListener、removeApplicationListener，这样的通用方法，这里这个类中主要是对 getApplicationListeners 和 supportsEvent 的处理。</li><li>getApplicationListeners 方法主要是摘取符合广播事件中的监听处理器，具体过滤动作在 supportsEvent 方法中。</li><li>在 supportsEvent 方法中，主要包括对Cglib、Simple不同实例化需要获取目标Class，Cglib代理类需要获取父类的Class，普通实例化的不需要。接下来就是通过提取接口和对应的 ParameterizedType 和 eventClassName，方便最后确认是否为子类和父类的关系，以此证明此事件归这个符合的类处理。<em>可以参考代码中的注释</em></li></ul><h3 id="事件发布者的定义和实现"><a href="#事件发布者的定义和实现" class="headerlink" title="事件发布者的定义和实现"></a>事件发布者的定义和实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface ApplicationEventPublisher &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Notify all listeners registered with this application of an application</span><br><span class="line">     * event. Events may be framework events (such as RequestHandledEvent)</span><br><span class="line">     * or application-specific events.</span><br><span class="line">     * @param event the event to publish</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void publishEvent(ApplicationEvent event);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>ApplicationEventPublisher 是整个一个事件的发布接口，所有的事件都需要从这个接口发布出去。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext &#123;</span><br><span class="line"></span><br><span class="line">    public static final String APPLICATION_EVENT_MULTICASTER_BEAN_NAME &#x3D; &quot;applicationEventMulticaster&quot;;</span><br><span class="line"></span><br><span class="line">    private ApplicationEventMulticaster applicationEventMulticaster;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void refresh() throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 6. 初始化事件发布者</span><br><span class="line">        initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 7. 注册事件监听器</span><br><span class="line">        registerListeners();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 9. 发布容器刷新完成事件</span><br><span class="line">        finishRefresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initApplicationEventMulticaster() &#123;</span><br><span class="line">        ConfigurableListableBeanFactory beanFactory &#x3D; getBeanFactory();</span><br><span class="line">        applicationEventMulticaster &#x3D; new SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">        beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, applicationEventMulticaster);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void registerListeners() &#123;</span><br><span class="line">        Collection&lt;ApplicationListener&gt; applicationListeners &#x3D; getBeansOfType(ApplicationListener.class).values();</span><br><span class="line">        for (ApplicationListener listener : applicationListeners) &#123;</span><br><span class="line">            applicationEventMulticaster.addApplicationListener(listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void finishRefresh() &#123;</span><br><span class="line">        publishEvent(new ContextRefreshedEvent(this));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void publishEvent(ApplicationEvent event) &#123;</span><br><span class="line">        applicationEventMulticaster.multicastEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void close() &#123;</span><br><span class="line">        &#x2F;&#x2F; 发布容器关闭事件</span><br><span class="line">        publishEvent(new ContextClosedEvent(this));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 执行销毁单例bean的销毁方法</span><br><span class="line">        getBeanFactory().destroySingletons();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>在抽象应用上下文 AbstractApplicationContext#refresh 中，主要新增了 <code>初始化事件发布者</code>、<code>注册事件监听器</code>、<code>发布容器刷新完成事件</code>，三个方法用于处理事件操作。</li><li>初始化事件发布者(initApplicationEventMulticaster)，主要用于实例化一个 SimpleApplicationEventMulticaster，这是一个事件广播器。</li><li>注册事件监听器(registerListeners)，通过 getBeansOfType 方法获取到所有从 spring.xml 中加载到的事件配置 Bean 对象。</li><li>发布容器刷新完成事件(finishRefresh)，发布了第一个服务器启动完成后的事件，这个事件通过 publishEvent 发布出去，其实也就是调用了 applicationEventMulticaster.multicastEvent(event); 方法。</li><li>最后是一个 close 方法中，新增加了发布一个容器关闭事件。<code>publishEvent(new ContextClosedEvent(this))</code></li></ul><p><strong>TEST</strong></p><h3 id="创建一个事件和监听器"><a href="#创建一个事件和监听器" class="headerlink" title="创建一个事件和监听器"></a>创建一个事件和监听器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class CustomEvent extends ApplicationContextEvent &#123;</span><br><span class="line"></span><br><span class="line">    private Long id;</span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Constructs a prototypical Event.</span><br><span class="line">     *</span><br><span class="line">     * @param source The object on which the Event initially occurred.</span><br><span class="line">     * @throws IllegalArgumentException if source is null.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public CustomEvent(Object source, Long id, String message) &#123;</span><br><span class="line">        super(source);</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">        this.message &#x3D; message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...get&#x2F;set</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>创建一个自定义事件，在事件类的构造函数中可以添加自己的想要的入参信息。这个事件类最终会被完成的拿到监听里，所以你添加的属性都会被获得到</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class CustomEventListener implements ApplicationListener&lt;CustomEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(CustomEvent event) &#123;</span><br><span class="line">        System.out.println(&quot;收到：&quot; + event.getSource() + &quot;消息;时间：&quot; + new Date());</span><br><span class="line">        System.out.println(&quot;消息：&quot; + event.getId() + &quot;:&quot; + event.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>这个是一个用于监听 CustomEvent 事件的监听器，这里你可以处理自己想要的操作，比如一些用户注册后发送优惠券和短信通知等。</li><li>另外是关于 <code>ContextRefreshedEventListener implements ApplicationListener&lt;ContextRefreshedEvent&gt;</code>、<code>ContextClosedEventListener implements ApplicationListener&lt;ContextClosedEvent&gt;</code> 监听器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class&#x3D;&quot;cn.bugstack.springframework.test.event.ContextRefreshedEventListener&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class&#x3D;&quot;cn.bugstack.springframework.test.event.CustomEventListener&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class&#x3D;&quot;cn.bugstack.springframework.test.event.ContextClosedEventListener&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>在 spring.xml 中配置了三个事件监听器，监听刷新、监控自定义事件、监听关闭事件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ApiTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test_event() &#123;</span><br><span class="line">        ClassPathXmlApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;classpath:spring.xml&quot;);</span><br><span class="line">        applicationContext.publishEvent(new CustomEvent(applicationContext, 1019129009086763L, &quot;成功了！&quot;));</span><br><span class="line"></span><br><span class="line">        applicationContext.registerShutdownHook();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>通过使用 applicationContext 新增加的发布事件接口方法，发布一个自定义事件 CustomEvent，并透传了相应的参数信息</li></ul></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97/">手写spring系列</a></div><div class="post_share"><div class="social-share" data-image="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206042241269.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/kele.png" target="_blank"><img class="post-qr-code-img" src="/img/kele.png" alt="觉得还不错，请他喝一瓶可乐"></a><div class="post-qr-code-desc">觉得还不错，请他喝一瓶可乐</div></li><li class="reward-item"><a href="/img/ali.jpg" target="_blank"><img class="post-qr-code-img" src="/img/ali.jpg" alt="雪碧也是可以的"></a><div class="post-qr-code-desc">雪碧也是可以的</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/20220612/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-AOP-1/"><img class="prev-cover" src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206042241269.jpeg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">手写spring系列-第4章-AOP-1</div></div></a></div><div class="next-post pull-right"><a href="/20220605/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Bean%E5%AE%B9%E5%99%A8/"><img class="next-cover" src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206042241269.jpeg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">手写spring系列-第2章-容器IOC-1</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/20220604/手写spring系列-第1章-源码整理解析/" title="手写spring系列-第1章-源码整体解析"><img class="cover" src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206042241269.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-04</div><div class="title">手写spring系列-第1章-源码整体解析</div></div></a></div><div><a href="/20220605/手写spring系列-第2章-实现一个简单的Bean容器/" title="手写spring系列-第2章-容器IOC-1"><img class="cover" src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206042241269.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-05</div><div class="title">手写spring系列-第2章-容器IOC-1</div></div></a></div><div><a href="/20220612/手写spring系列-第4章-AOP-1/" title="手写spring系列-第4章-AOP-1"><img class="cover" src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206042241269.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-12</div><div class="title">手写spring系列-第4章-AOP-1</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/tx2.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"><div class="author-info__name">章志成</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">75</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/gump12138"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/cooper12138" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:994739211@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">延迟满足</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">初始化和销毁方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.0.1.</span> <span class="toc-text">定义初始化和销毁方法的接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B9%89%E6%96%B0%E5%A2%9E%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81"><span class="toc-number">1.0.2.</span> <span class="toc-text">Bean属性定义新增初始化和销毁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C-Bean-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.3.</span> <span class="toc-text">执行 Bean 对象的初始化方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95%E9%80%82%E9%85%8D%E5%99%A8-%E6%8E%A5%E5%8F%A3%E5%92%8C%E9%85%8D%E7%BD%AE"><span class="toc-number">1.0.4.</span> <span class="toc-text">定义销毁方法适配器(接口和配置)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BABean%E6%97%B6%E6%B3%A8%E5%86%8C%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.0.5.</span> <span class="toc-text">创建Bean时注册销毁方法对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%B3%E9%97%AD%E9%92%A9%E5%AD%90%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.6.</span> <span class="toc-text">虚拟机关闭钩子注册调用销毁方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.0.7.</span> <span class="toc-text">配置文件</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%84%9F%E7%9F%A5%E5%AE%B9%E5%99%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">实现感知容器对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%A0%87%E8%AE%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.0.1.</span> <span class="toc-text">定义标记接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%84%9F%E7%9F%A5%E7%B1%BB"><span class="toc-number">2.0.2.</span> <span class="toc-text">容器感知类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E5%A4%84%E7%90%86%E5%99%A8-ApplicationContextAwareProcessor"><span class="toc-number">2.0.3.</span> <span class="toc-text">包装处理器(ApplicationContextAwareProcessor)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C-BeanPostProcessor"><span class="toc-number">2.0.4.</span> <span class="toc-text">注册 BeanPostProcessor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%9F%E7%9F%A5%E8%B0%83%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">2.0.5.</span> <span class="toc-text">感知调用操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BB%A5%E5%8F%8AFactoryBean"><span class="toc-number">3.</span> <span class="toc-text">对象作用域以及FactoryBean</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4%E5%AE%9A%E4%B9%89%E5%92%8Cxml%E8%A7%A3%E6%9E%90"><span class="toc-number">3.0.1.</span> <span class="toc-text">Bean的作用范围定义和xml解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BF%AE%E6%94%B9%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%80%99%E5%88%A4%E6%96%AD%E5%8D%95%E4%BE%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.0.2.</span> <span class="toc-text">创建和修改对象时候判断单例和原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-FactoryBean-%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.0.3.</span> <span class="toc-text">定义 FactoryBean 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-FactoryBean-%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1"><span class="toc-number">3.0.4.</span> <span class="toc-text">实现一个 FactoryBean 注册服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95-AbstractBeanFactory-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E9%80%BB%E8%BE%91"><span class="toc-number">3.0.5.</span> <span class="toc-text">扩展 AbstractBeanFactory 创建对象逻辑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">容器事件和事件监听器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%B9%BF%E6%92%AD%E5%99%A8"><span class="toc-number">4.0.1.</span> <span class="toc-text">事件广播器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83%E8%80%85%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.0.2.</span> <span class="toc-text">事件发布者的定义和实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">4.0.3.</span> <span class="toc-text">创建一个事件和监听器</span></a></li></ol></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/20220612/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-AOP-1/" title="手写spring系列-第4章-AOP-1"><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206042241269.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="手写spring系列-第4章-AOP-1"></a><div class="content"><a class="title" href="/20220612/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-AOP-1/" title="手写spring系列-第4章-AOP-1">手写spring系列-第4章-AOP-1</a><time datetime="2022-06-11T16:28:06.000Z" title="发表于 2022-06-12 00:28:06">2022-06-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/20220607/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E5%AE%B9%E5%99%A8IOC-2/" title="手写spring系列-第3章-容器IOC-2"><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206042241269.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="手写spring系列-第3章-容器IOC-2"></a><div class="content"><a class="title" href="/20220607/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E5%AE%B9%E5%99%A8IOC-2/" title="手写spring系列-第3章-容器IOC-2">手写spring系列-第3章-容器IOC-2</a><time datetime="2022-06-07T15:40:17.000Z" title="发表于 2022-06-07 23:40:17">2022-06-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/20220605/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Bean%E5%AE%B9%E5%99%A8/" title="手写spring系列-第2章-容器IOC-1"><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206042241269.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="手写spring系列-第2章-容器IOC-1"></a><div class="content"><a class="title" href="/20220605/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Bean%E5%AE%B9%E5%99%A8/" title="手写spring系列-第2章-容器IOC-1">手写spring系列-第2章-容器IOC-1</a><time datetime="2022-06-05T12:44:03.000Z" title="发表于 2022-06-05 20:44:03">2022-06-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/20220604/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC1%E7%AB%A0-%E6%BA%90%E7%A0%81%E6%95%B4%E7%90%86%E8%A7%A3%E6%9E%90/" title="手写spring系列-第1章-源码整体解析"><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206042241269.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="手写spring系列-第1章-源码整体解析"></a><div class="content"><a class="title" href="/20220604/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC1%E7%AB%A0-%E6%BA%90%E7%A0%81%E6%95%B4%E7%90%86%E8%A7%A3%E6%9E%90/" title="手写spring系列-第1章-源码整体解析">手写spring系列-第1章-源码整体解析</a><time datetime="2022-06-04T14:29:51.000Z" title="发表于 2022-06-04 22:29:51">2022-06-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/20220524/%E4%BB%8E%E8%B7%9F%E5%84%BF%E4%B8%8A%E7%90%86%E8%A7%A3MYSQL%E7%AC%94%E8%AE%B0%E8%80%8C%E5%B7%B2/" title="mysql系列-第1章-从跟儿上理解MYSQL笔记而已"><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202205242214058.webp" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="mysql系列-第1章-从跟儿上理解MYSQL笔记而已"></a><div class="content"><a class="title" href="/20220524/%E4%BB%8E%E8%B7%9F%E5%84%BF%E4%B8%8A%E7%90%86%E8%A7%A3MYSQL%E7%AC%94%E8%AE%B0%E8%80%8C%E5%B7%B2/" title="mysql系列-第1章-从跟儿上理解MYSQL笔记而已">mysql系列-第1章-从跟儿上理解MYSQL笔记而已</a><time datetime="2022-05-24T14:12:25.000Z" title="发表于 2022-05-24 22:12:25">2022-05-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 章志成</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="http://hankz.cc/">一个cv大师</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>function loadValine(){function e(){new Valine(Object.assign({el:"#vcomment",appId:"rX8EGp1QDIbaOBer0HPXb4wr-gzGzoHsz",appKey:"zYi2FKT3jfoRihSzwUQkzwd3",placeholder:"Please leave your footprints",avatar:"monsterid",meta:"nick,mail,link".split(","),pageSize:"10",lang:"zh-CN",recordIP:!1,serverURLs:"",emojiCDN:"",emojiMaps:"",enableQQ:!1,path:window.location.pathname,requiredFields:["nick,mail"],visitor:!1},null))}"function"==typeof Valine?e():getScript("https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js").then(e)}function loadOtherComment(){loadValine()}setTimeout(loadValine,0)</script></div><div class="aplayer no-destroy" data-id="84943176" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-autoplay="false" data-theme="#2980b9" data-loop="all" data-order="random" data-preload="auto" data-volume="0.4" data-mutex="true" data-listfolded="true" data-listmaxheight="340px" data-storagename="metingjs" muted></div><div class="aplayer no-destroy" data-id="https://music.163.com/playlist?id=84943176&userid=77272308" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-autoplay="true" data-theme="#2980b9" data-loop="all" data-order="random" data-preload="auto" data-volume="0.4" data-mutex="true" data-listfolded="true" data-listmaxheight="340px" data-storagename="metingjs" muted></div><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async mobile="true"></script><script>!function(t,a,n){a.ChatraID="K3d9XytKCJ4u5JfPd";var c=t.createElement("script");a[n]=a[n]||function(){(a[n].q=a[n].q||[]).push(arguments)},c.async=!0,c.src="https://call.chatra.io/chatra.js",t.head&&t.head.appendChild(c)}(document,window,"Chatra");var chatBtnFn=()=>{document.getElementById("chat_btn").addEventListener("click",function(){Chatra("openChat")})};function chatBtnHide(){Chatra("hide")}function chatBtnShow(){Chatra("show")}chatBtnFn()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:complete",function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script");var o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()}),document.addEventListener("pjax:send",function(){if("object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")}),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>