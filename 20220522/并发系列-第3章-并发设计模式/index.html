<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>并发系列-第3章-并发设计模式 | 去海边</title><meta name="keywords" content="并发编程"><meta name="author" content="章志成"><meta name="copyright" content="章志成"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="28 | Immutability模式：如何利用不变性解决并发问题？“多个线程同时读写同一共享变量存在并发问题”，这里的必要条件之一是读写，如果只有读，而没有写，是没有并发问题的。 不变性，简单来讲，就是对象一旦被创建之后，状态就不再发生变化 换句话说，就是变量一旦被赋值，就不允许修改了（没有写操作）；没有修改操作，也就是保持了不变性。 实现一个具备不可变性的类，还是挺简单的。将一个类所有的属性都"><meta property="og:type" content="article"><meta property="og:title" content="并发系列-第3章-并发设计模式"><meta property="og:url" content="http://example.com/20220522/%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html"><meta property="og:site_name" content="去海边"><meta property="og:description" content="28 | Immutability模式：如何利用不变性解决并发问题？“多个线程同时读写同一共享变量存在并发问题”，这里的必要条件之一是读写，如果只有读，而没有写，是没有并发问题的。 不变性，简单来讲，就是对象一旦被创建之后，状态就不再发生变化 换句话说，就是变量一旦被赋值，就不允许修改了（没有写操作）；没有修改操作，也就是保持了不变性。 实现一个具备不可变性的类，还是挺简单的。将一个类所有的属性都"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202205192229069.png"><meta property="article:published_time" content="2022-05-22T09:56:42.000Z"><meta property="article:modified_time" content="2022-05-22T16:23:25.228Z"><meta property="article:author" content="章志成"><meta property="article:tag" content="并发编程"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202205192229069.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/20220522/%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"bottom-left"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isanchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-05-23 00:23:25"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0!==o){const a=new Date;o=864e5*o,t={value:t,expiry:a.getTime()+o};localStorage.setItem(e,JSON.stringify(t))}},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);const o=new Date;if(!(o.getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=a=>new Promise((t,e)=>{const o=document.createElement("script");o.src=a,o.async=!0,o.onerror=e,o.onload=o.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(o.onload=o.onreadystatechange=null,t())},document.head.appendChild(o)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"))})(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/tx2.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-messageboard"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202205192232746.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">去海边</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-messageboard"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">并发系列-第3章-并发设计模式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-22T09:56:42.000Z" title="发表于 2022-05-22 17:56:42">2022-05-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-22T16:23:25.228Z" title="更新于 2022-05-23 00:23:25">2022-05-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="并发系列-第3章-并发设计模式"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/20220522/%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/20220522/%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="28-Immutability模式：如何利用不变性解决并发问题？"><a href="#28-Immutability模式：如何利用不变性解决并发问题？" class="headerlink" title="28 | Immutability模式：如何利用不变性解决并发问题？"></a>28 | Immutability模式：如何利用不变性解决并发问题？</h1><p>“多个线程同时读写同一共享变量存在并发问题”，这里的必要条件之一是读写，如果只有读，而没有写，是没有并发问题的。</p><p><strong>不变性，简单来讲，就是对象一旦被创建之后，状态就不再发生变化</strong></p><p>换句话说，就是变量一旦被赋值，就不允许修改了（没有写操作）；没有修改操作，也就是保持了不变性。</p><p>实现一个具备不可变性的类，还是挺简单的。<strong>将一个类所有的属性都设置成 final 的，并且只允许存在只读方法，那么这个类基本上就具备不可变性了</strong>。更严格的做法是<strong>这个类本身也是 final 的</strong>，也就是不允许继承。因为子类可以覆盖父类的方法，有可能改变不可变性</p><p>Java SDK 里很多类都具备不可变性，例如经常用到的 String 和 Long、Integer、Double 等基础类型的包装类都具备不可变性，这些对象的线程安全性都是靠不可变性来保证的。</p><p><strong>类和属性都是 final 的，所有方法均是只读的</strong>。</p><p>如果具备不可变性的类，需要提供类似修改的功能，具体该怎么操作呢？做法很简单，那就是<strong>创建一个新的不可变对象</strong></p><p>所有的修改操作都创建一个新的不可变对象，你可能会有这种担心：是不是创建的对象太多了，有点太浪费内存呢？是的，这样做的确有些浪费，那如何解决呢？</p><h2 id="利用享元模式避免创建重复对象"><a href="#利用享元模式避免创建重复对象" class="headerlink" title="利用享元模式避免创建重复对象"></a>利用享元模式避免创建重复对象</h2><p><strong>享元模式（Flyweight Pattern）</strong></p><p><strong>利用享元模式可以减少创建对象的数量，从而减少内存占用。</strong>Java 语言里面 Long、Integer、Short、Byte 等这些基本数据类型的包装类都用到了享元模式。</p><p>以 Long 这个类作为例子</p><p>享元模式本质上其实就是一个<strong>对象池</strong>：创建之前，首先去对象池里看看是不是存在；如果已经存在，就利用对象池里的对象；如果不存在，就会新创建一个对象，并且把这个新创建出来的对象放进对象池里。</p><p>Long 这个类并没有照搬享元模式，Long 内部维护了一个静态的对象池，仅缓存了 [-128,127] 之间的数字，这个对象池在 JVM 启动的时候就创建好了，而且这个对象池一直都不会变化，也就是说它是静态的。之所以采用这样的设计，是因为 Long 这个对象的状态共有 264 种，实在太多，不宜全部缓存，而 [-128,127] 之间的数字利用率最高。</p><p>valueOf() 方法就用到了 LongCache 这个缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Long valueOf(long l) &#123;</span><br><span class="line">  final int offset &#x3D; 128;</span><br><span class="line">  &#x2F;&#x2F; [-128,127] 直接的数字做了缓存</span><br><span class="line">  if (l &gt;&#x3D; -128 &amp;&amp; l &lt;&#x3D; 127) &#123; </span><br><span class="line">    return LongCache.cache[(int)l + offset];</span><br><span class="line">  &#125;</span><br><span class="line">  return new Long(l);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 缓存，等价于对象池</span><br><span class="line">&#x2F;&#x2F; 仅缓存 [-128,127] 直接的数字</span><br><span class="line">static class LongCache &#123;</span><br><span class="line">  static final Long cache[]  &#x3D; new Long[-(-128) + 127 + 1];</span><br><span class="line"> </span><br><span class="line">  static &#123;</span><br><span class="line">    for(int i&#x3D;0; i&lt;cache.length; i++)</span><br><span class="line">      cache[i] &#x3D; new Long(i-128);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“Integer 和 String 类型的对象不适合做锁”，其实基本上所有的基础类型的包装类都不适合做锁，因为它们内部用到了享元模式，这会导致看上去私有的锁，其实是共有的。</p><p>例如在下面代码中，本意是 A 用锁 al，B 用锁 bl，各自管理各自的，互不影响。但实际上 al 和 bl 是一个对象，结果 A 和 B 共用的是一把锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  Long al&#x3D;Long.valueOf(1);</span><br><span class="line">  public void setAX()&#123;</span><br><span class="line">    synchronized (al) &#123;</span><br><span class="line">      &#x2F;&#x2F; 省略代码无数</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B &#123;</span><br><span class="line">  Long bl&#x3D;Long.valueOf(1);</span><br><span class="line">  public void setBY()&#123;</span><br><span class="line">    synchronized (bl) &#123;</span><br><span class="line">      &#x2F;&#x2F; 省略代码无数</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-Immutability-模式的注意事项"><a href="#使用-Immutability-模式的注意事项" class="headerlink" title="使用 Immutability 模式的注意事项"></a>使用 Immutability 模式的注意事项</h2><ol><li>对象的所有属性都是 final 的，并不能保证不可变性；</li><li>不可变对象也需要正确发布。</li></ol><p>final 修饰的属性一旦被赋值，就不可以再修改，但是如果属性的类型是普通对象，那么这个普通对象的属性是可以被修改的。</p><p>例如下面的代码中，Bar 的属性 foo 虽然是 final 的，依然可以通过 setAge() 方法来设置 foo 的属性 age。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">  int age&#x3D;0;</span><br><span class="line">  int name&#x3D;&quot;abc&quot;;</span><br><span class="line">&#125;</span><br><span class="line">final class Bar &#123;</span><br><span class="line">  final Foo foo;</span><br><span class="line">  void setAge(int a)&#123;</span><br><span class="line">    foo.age&#x3D;a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何正确地发布不可变对象</p><p>不可变对象虽然是线程安全的，但是并不意味着引用这些不可变对象的对象就是线程安全的</p><p>例如在下面的代码中，Foo 具备不可变性，线程安全，但是类 Bar 并不是线程安全的，类 Bar 中持有对 Foo 的引用 foo，对 foo 这个引用的修改在多线程中并不能保证可见性和原子性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Foo 线程安全</span><br><span class="line">final class Foo&#123;</span><br><span class="line">  final int age&#x3D;0;</span><br><span class="line">  final int name&#x3D;&quot;abc&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;Bar 线程不安全</span><br><span class="line">class Bar &#123;</span><br><span class="line">  Foo foo;</span><br><span class="line">  void setFoo(Foo f)&#123;</span><br><span class="line">    this.foo&#x3D;f;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你的程序仅仅需要 foo 保持可见性，无需保证原子性，那么可以将 foo 声明为 volatile 变量，这样就能保证可见性。如果你的程序需要保证原子性，那么可以通过原子类来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class SafeWM &#123;</span><br><span class="line">  class WMRange&#123;</span><br><span class="line">    final int upper;</span><br><span class="line">    final int lower;</span><br><span class="line">    WMRange(int upper,int lower)&#123;</span><br><span class="line">    &#x2F;&#x2F; 省略构造函数实现</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  final AtomicReference&lt;WMRange&gt;rf &#x3D; new AtomicReference&lt;&gt;(new WMRange(0,0));</span><br><span class="line">  &#x2F;&#x2F; 设置库存上限</span><br><span class="line">  void setUpper(int v)&#123;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">      WMRange or &#x3D; rf.get();</span><br><span class="line">      &#x2F;&#x2F; 检查参数合法性</span><br><span class="line">      if(v &lt; or.lower)&#123;</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">      &#125;</span><br><span class="line">      WMRange nr &#x3D; new</span><br><span class="line">          WMRange(v, or.lower);</span><br><span class="line">      if(rf.compareAndSet(or, nr))&#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具备不变性的对象，只有一种状态，这个状态由对象内部所有的不变属性共同决定。其实还有一种更简单的不变性对象，那就是<strong>无状态</strong>。无状态对象内部没有属性，只有方法。除了无状态的对象，你可能还听说过无状态的服务、无状态的协议等等。无状态有很多好处，最核心的一点就是性能。在多线程领域，无状态对象没有线程安全问题，无需同步处理，自然性能很好；在分布式领域，无状态意味着可以无限地水平扩展，所以分布式领域里面性能的瓶颈一定不是出在无状态的服务节点上。</p><h1 id="29-Copy-on-Write模式：不是延时策略的COW"><a href="#29-Copy-on-Write模式：不是延时策略的COW" class="headerlink" title="29 | Copy-on-Write模式：不是延时策略的COW"></a>29 | Copy-on-Write模式：不是延时策略的COW</h1><p>所谓 Copy-on-Write，经常被缩写为 COW 或者 CoW，顾名思义就是<strong>写时复制</strong>。</p><h2 id="Copy-on-Write-模式的应用领域"><a href="#Copy-on-Write-模式的应用领域" class="headerlink" title="Copy-on-Write 模式的应用领域"></a>Copy-on-Write 模式的应用领域</h2><p>CopyOnWriteArrayList 和 CopyOnWriteArraySet</p><p>操作系统领域</p><p>类 Unix 的操作系统中创建进程的 API 是 fork()，传统的 fork() 函数会创建父进程的一个完整副本，例如父进程的地址空间现在用到了 1G 的内存，那么 fork() 子进程的时候要复制父进程整个进程的地址空间（占有 1G 内存）给子进程，这个过程是很耗时的。而 Linux 中的 fork() 函数就聪明得多了，fork() 子进程的时候，并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间；只用在父进程或者子进程需要写入的时候才会复制地址空间，从而使父子进程拥有各自的地址空间。</p><p>本质上来讲，父子进程的地址空间以及数据都是要隔离的，使用 Copy-on-Write 更多地体现的是一种<strong>延时策略，只有在真正需要复制的时候才复制，而不是提前复制好</strong>，同时 Copy-on-Write 还支持按需复制，所以 Copy-on-Write 在操作系统领域是能够提升性能的。</p><p>Java 提供的 Copy-on-Write 容器，由于在修改的同时会复制整个容器，所以在提升读操作性能的同时，是以内存复制为代价的。</p><p>很多文件系统也同样用到了，例如 Btrfs (B-Tree File System)、aufs（advanced multi-layered unification filesystem）等。</p><p>除了上面我们说的 Java 领域、操作系统领域，很多其他领域也都能看到 Copy-on-Write 的身影：Docker 容器镜像的设计是 Copy-on-Write，甚至分布式源码管理系统 Git 背后的设计思想都有 Copy-on-Write……</p><p><strong>Copy-on-Write 最大的应用领域还是在函数式编程领域</strong></p><p>函数式编程的基础是不可变性（Immutability），所以函数式编程里面所有的修改操作都需要 Copy-on-Write 来解决。</p><p>“所有数据的修改都需要复制一份，性能是不是会成为瓶颈呢？”</p><p>之所以函数式编程早年间没有兴起，性能绝对拖了后腿。但是随着硬件性能的提升，性能问题已经慢慢变得可以接受了。而且，Copy-on-Write 也远不像 Java 里的 CopyOnWriteArrayList 那样笨：整个数组都复制一遍。Copy-on-Write 也是可以按需复制的</p><p>CopyOnWriteArrayList 和 CopyOnWriteArraySet 这两个 Copy-on-Write 容器在修改的时候会复制整个数组，所以如果容器经常被修改或者这个数组本身就非常大的时候，是不建议使用的。反之，如果是修改非常少、数组数量也不大，并且对读性能要求苛刻的场景，使用 Copy-on-Write 容器效果就非常好了。</p><h1 id="30-线程本地存储模式：没有共享，就没有伤害"><a href="#30-线程本地存储模式：没有共享，就没有伤害" class="headerlink" title="30 | 线程本地存储模式：没有共享，就没有伤害"></a>30 | 线程本地存储模式：没有共享，就没有伤害</h1><p>解决并发问题的一个重要方法：<strong>避免共享</strong></p><h2 id="ThreadLocal-的使用方法"><a href="#ThreadLocal-的使用方法" class="headerlink" title="ThreadLocal 的使用方法"></a>ThreadLocal 的使用方法</h2><p>下面这个静态类 ThreadId 会为每个线程分配一个唯一的线程 Id，如果<strong>一个线程</strong>前后两次调用 ThreadId 的 get() 方法，两次 get() 方法的返回值是相同的。但如果是<strong>两个线程</strong>分别调用 ThreadId 的 get() 方法，那么两个线程看到的 get() 方法的返回值是不同的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static class ThreadId &#123;</span><br><span class="line">  static final AtomicLong </span><br><span class="line">  nextId&#x3D;new AtomicLong(0);</span><br><span class="line">  &#x2F;&#x2F; 定义 ThreadLocal 变量</span><br><span class="line">  static final ThreadLocal&lt;Long&gt; </span><br><span class="line">  tl&#x3D;ThreadLocal.withInitial(</span><br><span class="line">    ()-&gt;nextId.getAndIncrement());</span><br><span class="line">  &#x2F;&#x2F; 此方法会为每个线程分配一个唯一的 Id</span><br><span class="line">  static long get()&#123;</span><br><span class="line">    return tl.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SafeDateFormat 的 get() 方法将返回不同的 SimpleDateFormat 对象实例，由于不同线程并不共享 SimpleDateFormat，所以就像局部变量一样，是线程安全的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static class SafeDateFormat &#123;</span><br><span class="line">  &#x2F;&#x2F; 定义 ThreadLocal 变量</span><br><span class="line">  static final ThreadLocal&lt;DateFormat&gt;</span><br><span class="line">  tl&#x3D;ThreadLocal.withInitial(</span><br><span class="line">    ()-&gt; new SimpleDateFormat(</span><br><span class="line">      &quot;yyyy-MM-dd HH:mm:ss&quot;));</span><br><span class="line">      </span><br><span class="line">  static DateFormat get()&#123;</span><br><span class="line">    return tl.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 不同线程执行下面代码</span><br><span class="line">&#x2F;&#x2F; 返回的 df 是不同的</span><br><span class="line">DateFormat df &#x3D; SafeDateFormat.get()；</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal-的工作原理"><a href="#ThreadLocal-的工作原理" class="headerlink" title="ThreadLocal 的工作原理"></a>ThreadLocal 的工作原理</h2><p>ThreadLocal 的目标是让不同的线程有不同的变量 V，那最直接的方法就是创建一个 Map，它的 Key 是线程，Value 是每个线程拥有的变量 V，ThreadLocal 内部持有这样的一个 Map 就可以了。</p><p><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202205222338505.png" alt="image-20220522233810196"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class MyThreadLocal&lt;T&gt; &#123;</span><br><span class="line">  Map&lt;Thread, T&gt; locals &#x3D;  new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  &#x2F;&#x2F; 获取线程变量  </span><br><span class="line">  T get() &#123;</span><br><span class="line">    return locals.get(</span><br><span class="line">      Thread.currentThread());</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 设置线程变量</span><br><span class="line">  void set(T t) &#123;</span><br><span class="line">    locals.put(</span><br><span class="line">      Thread.currentThread(), t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那 Java 的 ThreadLocal 是这么实现的吗？这一次我们的设计思路和 Java 的实现差异很大。Java 的实现里面也有一个 Map，叫做 ThreadLocalMap，不过持有 ThreadLocalMap 的不是 ThreadLocal，而是 Thread。Thread 这个类内部有一个私有属性 threadLocals，其类型就是 ThreadLocalMap，ThreadLocalMap 的 Key 是 ThreadLocal。</p><p><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202205222338880.png" alt="image-20220522233858937"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Thread &#123;</span><br><span class="line">  &#x2F;&#x2F; 内部持有 ThreadLocalMap</span><br><span class="line">  ThreadLocal.ThreadLocalMap  threadLocals;</span><br><span class="line">&#125;</span><br><span class="line">class ThreadLocal&lt;T&gt;&#123;</span><br><span class="line">  public T get() &#123;</span><br><span class="line">    &#x2F;&#x2F; 首先获取线程持有的</span><br><span class="line">    &#x2F;&#x2F;ThreadLocalMap</span><br><span class="line">    ThreadLocalMap map &#x3D; Thread.currentThread().threadLocals;</span><br><span class="line">    &#x2F;&#x2F; 在 ThreadLocalMap 中</span><br><span class="line">    &#x2F;&#x2F; 查找变量</span><br><span class="line">    Entry e &#x3D; map.getEntry(this);</span><br><span class="line">    return e.value;  </span><br><span class="line">  &#125;</span><br><span class="line">  static class ThreadLocalMap&#123;</span><br><span class="line">    &#x2F;&#x2F; 内部是数组而不是 Map</span><br><span class="line">    Entry[] table;</span><br><span class="line">    &#x2F;&#x2F; 根据 ThreadLocal 查找 Entry</span><br><span class="line">    Entry getEntry(ThreadLocal key)&#123;</span><br><span class="line">      &#x2F;&#x2F; 省略查找逻辑</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;Entry 定义</span><br><span class="line">    static class Entry extends</span><br><span class="line">    WeakReference&lt;ThreadLocal&gt;&#123;</span><br><span class="line">      Object value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 的实现方案里面，ThreadLocal 仅仅是一个代理工具类，内部并不持有任何与线程相关的数据，所有和线程相关的数据都存储在 Thread 里面。而从数据的亲缘性上来讲，ThreadLocalMap 属于 Thread 也更加合理。</p><p>当然还有一个更加深层次的原因，那就是<strong>不容易产生内存泄露</strong>。在我们的设计方案中，ThreadLocal 持有的 Map 会持有 Thread 对象的引用，这就意味着，只要 ThreadLocal 对象存在，那么 Map 中的 Thread 对象就永远不会被回收。ThreadLocal 的生命周期往往都比线程要长，所以这种设计方案很容易导致内存泄露。而 Java 的实现中 Thread 持有 ThreadLocalMap，而且 ThreadLocalMap 里对 ThreadLocal 的引用还是弱引用（WeakReference），所以只要 Thread 对象可以被回收，那么 ThreadLocalMap 就能被回收。</p><h2 id="ThreadLocal-与内存泄露"><a href="#ThreadLocal-与内存泄露" class="headerlink" title="ThreadLocal 与内存泄露"></a>ThreadLocal 与内存泄露</h2><p>线程池中线程的存活时间太长，往往都是和程序同生共死的，这就意味着 Thread 持有的 ThreadLocalMap 一直都不会被回收，再加上 ThreadLocalMap 中的 Entry 对 ThreadLocal 是弱引用（WeakReference），所以只要 ThreadLocal 结束了自己的生命周期是可以被回收掉的。但是 Entry 中的 Value 却是被 Entry 强引用的，所以即便 Value 的生命周期结束了，Value 也是无法被回收的，从而导致内存泄露。</p><p>那在线程池中，我们该如何正确使用 ThreadLocal 呢？其实很简单，既然 JVM 不能做到自动释放对 Value 的强引用，那我们手动释放就可以了。</p><p><strong>try{}finally{}</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es;</span><br><span class="line">ThreadLocal tl;</span><br><span class="line">es.execute(()-&gt;&#123;</span><br><span class="line">  &#x2F;&#x2F;ThreadLocal 增加变量</span><br><span class="line">  tl.set(obj);</span><br><span class="line">  try &#123;</span><br><span class="line">    &#x2F;&#x2F; 省略业务逻辑代码</span><br><span class="line">  &#125;finally &#123;</span><br><span class="line">    &#x2F;&#x2F; 手动清理 ThreadLocal </span><br><span class="line">    tl.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="InheritableThreadLocal-与继承性"><a href="#InheritableThreadLocal-与继承性" class="headerlink" title="InheritableThreadLocal 与继承性"></a>InheritableThreadLocal 与继承性</h2><p>通过 ThreadLocal 创建的线程变量，其子线程是无法继承的。也就是说在线程中通过 ThreadLocal 创建了线程变量 V，而后该线程创建了子线程，在子线程中是无法通过 ThreadLocal 来访问父线程的线程变量 V 的。</p><p>Java 提供了 InheritableThreadLocal 来支持这种特性，InheritableThreadLocal 是 ThreadLocal 子类</p><p>不建议在线程池中使用 InheritableThreadLocal，不仅仅是因为它具有 ThreadLocal 相同的缺点——可能导致内存泄露，更重要的原因是：线程池中线程的创建是动态的，很容易导致继承关系错乱，如果业务逻辑依赖 InheritableThreadLocal，那么很可能导致业务逻辑计算错误，而这个错误往往比内存泄露更要命。</p><p>实际工作中，有很多平台型的技术方案都是采用 ThreadLocal 来传递一些上下文信息，例如 Spring 使用 ThreadLocal 来传递事务信息。</p><h1 id="31-Guarded-Suspension模式：等待唤醒机制的规范实现"><a href="#31-Guarded-Suspension模式：等待唤醒机制的规范实现" class="headerlink" title="31 | Guarded Suspension模式：等待唤醒机制的规范实现"></a>31 | Guarded Suspension模式：等待唤醒机制的规范实现</h1><p>Web 版的文件浏览器，通过它用户可以在浏览器里查看服务器上的目录和文件。这个项目依赖运维部门提供的文件浏览服务，而这个文件浏览服务只支持消息队列（MQ）方式接入。</p><p><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202205222349960.png" alt="image-20220522234917154"></p><p>在这个 Web 项目中，用户通过浏览器发过来一个请求，会被转换成一个异步消息发送给 MQ，等 MQ 返回结果后，再将这个结果返回至浏览器。</p><p>问题是：给 MQ 发送消息的线程是处理 Web 请求的线程 T1，但消费 MQ 结果的线程并不是线程 T1，那线程 T1 如何等待 MQ 的返回结果呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Message&#123;</span><br><span class="line">  String id;</span><br><span class="line">  String content;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 该方法可以发送消息</span><br><span class="line">void send(Message msg)&#123;</span><br><span class="line">  &#x2F;&#x2F; 省略相关代码</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;MQ 消息返回后会调用该方法</span><br><span class="line">&#x2F;&#x2F; 该方法的执行线程不同于</span><br><span class="line">&#x2F;&#x2F; 发送消息的线程</span><br><span class="line">void onMessage(Message msg)&#123;</span><br><span class="line">  &#x2F;&#x2F; 省略相关代码</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 处理浏览器发来的请求</span><br><span class="line">Respond handleWebReq()&#123;</span><br><span class="line">  &#x2F;&#x2F; 创建一消息</span><br><span class="line">  Message msg1 &#x3D; new Message(&quot;1&quot;,&quot;&#123;...&#125;&quot;);</span><br><span class="line">  &#x2F;&#x2F; 发送消息</span><br><span class="line">  send(msg1);</span><br><span class="line">  &#x2F;&#x2F; 如何等待 MQ 返回的消息呢？</span><br><span class="line">  String result &#x3D; ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Guarded-Suspension-模式"><a href="#Guarded-Suspension-模式" class="headerlink" title="Guarded Suspension 模式"></a>Guarded Suspension 模式</h2><p>比如，项目组团建要外出聚餐，我们提前预订了一个包间，然后兴冲冲地奔过去，到那儿后大堂经理看了一眼包间，发现服务员正在收拾，就会告诉我们：“您预订的包间服务员正在收拾，请您稍等片刻。”</p><p>我们等待包间收拾完的这个过程和遇到的等待 MQ 返回消息本质上是一样的，都是<strong>等待一个条件满足</strong>：就餐需要等待包间收拾完，程序里要等待 MQ 返回消息。</p><p>如何解决这类问题的呢？现实世界里大堂经理这个角色很重要，我们是否等待，完全是由他来协调的。通过类比：我们的程序里，也需要这样一个大堂经理。</p><p>所谓 Guarded Suspension，直译过来就是“保护性地暂停”</p><p>一个对象 GuardedObject，内部有一个成员变量——受保护的对象，以及两个成员方法——<code>get(Predicate&lt;T&gt; p)</code>和<code>onChanged(T obj)</code>方法。其中，对象 GuardedObject 就是我们前面提到的大堂经理，受保护对象就是餐厅里面的包间；受保护对象的 get() 方法对应的是我们的就餐，就餐的前提条件是包间已经收拾好了，参数 p 就是用来描述这个前提条件的；受保护对象的 onChanged() 方法对应的是服务员把包间收拾好了，通过 onChanged() 方法可以 fire 一个事件，而这个事件往往能改变前提条件 p 的计算结果。下图中，左侧的绿色线程就是需要就餐的顾客，而右侧的蓝色线程就是收拾包间的服务员。</p><p><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202205222352243.png" alt="image-20220522235231486"></p><p>核心是：get() 方法通过条件变量的 await() 方法实现等待，onChanged() 方法通过条件变量的 signalAll() 方法实现唤醒功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class GuardedObject&lt;T&gt;&#123;</span><br><span class="line">  &#x2F;&#x2F; 受保护的对象</span><br><span class="line">  T obj;</span><br><span class="line">  final Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">  final Condition done &#x3D;lock.newCondition();</span><br><span class="line">  final int timeout&#x3D;1;</span><br><span class="line">  &#x2F;&#x2F; 获取受保护对象  </span><br><span class="line">  T get(Predicate&lt;T&gt; p) &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F;MESA 管程推荐写法</span><br><span class="line">      while(!p.test(obj))&#123;</span><br><span class="line">        done.await(timeout, </span><br><span class="line">          TimeUnit.SECONDS);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;catch(InterruptedException e)&#123;</span><br><span class="line">      throw new RuntimeException(e);</span><br><span class="line">    &#125;finally&#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 返回非空的受保护对象</span><br><span class="line">    return obj;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 事件通知方法</span><br><span class="line">  void onChanged(T obj) &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">      this.obj &#x3D; obj;</span><br><span class="line">      done.signalAll();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展-Guarded-Suspension-模式"><a href="#扩展-Guarded-Suspension-模式" class="headerlink" title="扩展 Guarded Suspension 模式"></a>扩展 Guarded Suspension 模式</h2><p>Guarded Suspension 模式里 GuardedObject 有两个核心方法，一个是 get() 方法，一个是 onChanged() 方法。很显然，在处理 Web 请求的方法 handleWebReq() 中，可以调用 GuardedObject 的 get() 方法来实现等待；在 MQ 消息的消费方法 onMessage() 中，可以调用 GuardedObject 的 onChanged() 方法来实现唤醒。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 处理浏览器发来的请求</span><br><span class="line">Respond handleWebReq()&#123;</span><br><span class="line">  &#x2F;&#x2F; 创建一消息</span><br><span class="line">  Message msg1 &#x3D; new Message(&quot;1&quot;,&quot;&#123;...&#125;&quot;);</span><br><span class="line">  &#x2F;&#x2F; 发送消息</span><br><span class="line">  send(msg1);</span><br><span class="line">  &#x2F;&#x2F; 利用 GuardedObject 实现等待</span><br><span class="line">  GuardedObject&lt;Message&gt; go &#x3D;new GuardObjec&lt;&gt;();</span><br><span class="line">  Message r &#x3D; go.get(</span><br><span class="line">    t-&gt;t !&#x3D; null);</span><br><span class="line">&#125;</span><br><span class="line">void onMessage(Message msg)&#123;</span><br><span class="line">  &#x2F;&#x2F; 如何找到匹配的 go？</span><br><span class="line">  GuardedObject&lt;Message&gt; go&#x3D;???</span><br><span class="line">  go.onChanged(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在实现的时候会遇到一个问题，handleWebReq() 里面创建了 GuardedObject 对象的实例 go，并调用其 get() 方等待结果，那在 onMessage() 方法中，如何才能够找到匹配的 GuardedObject 对象呢？这个过程类似服务员告诉大堂经理某某包间已经收拾好了，大堂经理如何根据包间找到就餐的人。现实世界里，大堂经理的头脑中，有包间和就餐人之间的关系图，所以服务员说完之后大堂经理立刻就能把就餐人找出来。</p><p>程序中，每个发送到 MQ 的消息，都有一个唯一性的属性 id，所以我们可以维护一个 MQ 消息 id 和 GuardedObject 对象实例的关系，这个关系可以类比大堂经理大脑里维护的包间和就餐人的关系。</p><p>扩展后的 GuardedObject 内部维护了一个 Map，其 Key 是 MQ 消息 id，而 Value 是 GuardedObject 对象实例，同时增加了静态方法 create() 和 fireEvent()；create() 方法用来创建一个 GuardedObject 对象实例，并根据 key 值将其加入到 Map 中，而 fireEvent() 方法则是模拟的大堂经理根据包间找就餐人的逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class GuardedObject&lt;T&gt;&#123;</span><br><span class="line">  &#x2F;&#x2F; 受保护的对象</span><br><span class="line">  T obj;</span><br><span class="line">  final Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">  final Condition done &#x3D;lock.newCondition();</span><br><span class="line">  final int timeout&#x3D;2;</span><br><span class="line">  &#x2F;&#x2F; 保存所有 GuardedObject</span><br><span class="line">  final static Map&lt;Object, GuardedObject&gt; gos&#x3D;new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  &#x2F;&#x2F; 静态方法创建 GuardedObject</span><br><span class="line">  static &lt;K&gt; GuardedObject </span><br><span class="line">      create(K key)&#123;</span><br><span class="line">    GuardedObject go&#x3D;new GuardedObject();</span><br><span class="line">    gos.put(key, go);</span><br><span class="line">    return go;</span><br><span class="line">  &#125;</span><br><span class="line">  static &lt;K, T&gt; void </span><br><span class="line">      fireEvent(K key, T obj)&#123;</span><br><span class="line">    GuardedObject go&#x3D;gos.remove(key);</span><br><span class="line">    if (go !&#x3D; null)&#123;</span><br><span class="line">      go.onChanged(obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 获取受保护对象  </span><br><span class="line">  T get(Predicate&lt;T&gt; p) &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F;MESA 管程推荐写法</span><br><span class="line">      while(!p.test(obj))&#123;</span><br><span class="line">        done.await(timeout, </span><br><span class="line">          TimeUnit.SECONDS);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;catch(InterruptedException e)&#123;</span><br><span class="line">      throw new RuntimeException(e);</span><br><span class="line">    &#125;finally&#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 返回非空的受保护对象</span><br><span class="line">    return obj;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 事件通知方法</span><br><span class="line">  void onChanged(T obj) &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">      this.obj &#x3D; obj;</span><br><span class="line">      done.signalAll();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Guarded Suspension 模式也常被称作 Guarded Wait 模式、Spin Lock 模式（因为使用了 while 循环去等待），这些名字都很形象，不过它还有一个更形象的非官方名字：多线程版本的 if。单线程场景中，if 语句是不需要等待的，因为在只有一个线程的条件下，如果这个线程被阻塞，那就没有其他活动线程了，这意味着 if 判断条件的结果也不会发生变化了。但是多线程场景中，等待就变得有意义了，这种场景下，if 判断条件的结果是可能发生变化的。所以，用“多线程版本的 if”来理解这个模式会更简单。</p><h1 id="32-Balking模式：再谈线程安全的单例模式"><a href="#32-Balking模式：再谈线程安全的单例模式" class="headerlink" title="32 | Balking模式：再谈线程安全的单例模式"></a>32 | Balking模式：再谈线程安全的单例模式</h1><p>各种编辑器提供的自动保存功能。自动保存功能的实现逻辑一般都是隔一定时间自动执行存盘操作，存盘操作的前提是文件做过修改，如果文件没有执行过修改操作，就需要快速放弃存盘操作。下面的示例代码将自动保存功能代码化了，很显然 AutoSaveEditor 这个类不是线程安全的，因为对共享变量 changed 的读写没有使用同步，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class AutoSaveEditor&#123;</span><br><span class="line">  &#x2F;&#x2F; 文件是否被修改过</span><br><span class="line">  boolean changed&#x3D;false;</span><br><span class="line">  &#x2F;&#x2F; 定时任务线程池</span><br><span class="line">  ScheduledExecutorService ses &#x3D;  Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">  &#x2F;&#x2F; 定时执行自动保存</span><br><span class="line">  void startAutoSave()&#123;</span><br><span class="line">    ses.scheduleWithFixedDelay(()-&gt;&#123;</span><br><span class="line">      autoSave();</span><br><span class="line">    &#125;, 5, 5, TimeUnit.SECONDS);  </span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 自动存盘操作</span><br><span class="line">  void autoSave()&#123;</span><br><span class="line">    if (!changed) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    changed &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F; 执行存盘操作</span><br><span class="line">    &#x2F;&#x2F; 省略且实现</span><br><span class="line">    this.execSave();</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 编辑操作</span><br><span class="line">  void edit()&#123;</span><br><span class="line">    &#x2F;&#x2F; 省略编辑逻辑</span><br><span class="line">    ......</span><br><span class="line">    changed &#x3D; true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读写共享变量 changed 的方法 autoSave() 和 edit() 都加互斥锁就可以了。这样做虽然简单，但是性能很差，原因是锁的范围太大了。那我们可以将锁的范围缩小，只在读写共享变量 changed 的地方加锁，实现代码如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 自动存盘操作</span><br><span class="line">void autoSave()&#123;</span><br><span class="line">  synchronized(this)&#123;</span><br><span class="line">    if (!changed) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    changed &#x3D; false;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 执行存盘操作</span><br><span class="line">  &#x2F;&#x2F; 省略且实现</span><br><span class="line">  this.execSave();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 编辑操作</span><br><span class="line">void edit()&#123;</span><br><span class="line">  &#x2F;&#x2F; 省略编辑逻辑</span><br><span class="line">  ......</span><br><span class="line">  synchronized(this)&#123;</span><br><span class="line">    changed &#x3D; true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>深入地分析一下这个示例程序，会发现，示例中的共享变量是一个状态变量，业务逻辑依赖于这个状态变量的状态：当状态满足某个条件时，执行某个业务逻辑，其本质其实不过就是一个 if 而已，放到多线程场景里，就是一种“多线程版本的 if”。这种“多线程版本的 if”的应用场景还是很多的，所以也有人把它总结成了一种设计模式，叫做<strong>Balking 模式</strong>。</p><h2 id="Balking-模式的经典实现"><a href="#Balking-模式的经典实现" class="headerlink" title="Balking 模式的经典实现"></a>Balking 模式的经典实现</h2><p>使用 Balking 模式规范化之后的写法如下所示，会发现仅仅是将 edit() 方法中对共享变量 changed 的赋值操作抽取到了 change() 中，这样的好处是将并发处理逻辑和业务逻辑分开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">boolean changed&#x3D;false;</span><br><span class="line">&#x2F;&#x2F; 自动存盘操作</span><br><span class="line">void autoSave()&#123;</span><br><span class="line">  synchronized(this)&#123;</span><br><span class="line">    if (!changed) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    changed &#x3D; false;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 执行存盘操作</span><br><span class="line">  &#x2F;&#x2F; 省略且实现</span><br><span class="line">  this.execSave();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 编辑操作</span><br><span class="line">void edit()&#123;</span><br><span class="line">  &#x2F;&#x2F; 省略编辑逻辑</span><br><span class="line">  ......</span><br><span class="line">  change();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 改变状态</span><br><span class="line">void change()&#123;</span><br><span class="line">  synchronized(this)&#123;</span><br><span class="line">    changed &#x3D; true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用-volatile-实现-Balking-模式"><a href="#用-volatile-实现-Balking-模式" class="headerlink" title="用 volatile 实现 Balking 模式"></a>用 volatile 实现 Balking 模式</h2><p><strong>使用 volatile 的前提是对原子性没有要求</strong>。</p><p>线程安全的单例模式本质上其实也是单次初始化，所以可以用 Balking 模式来实现线程安全的单例模式，下面的示例代码是其实现。这个实现虽然功能上没有问题，但是性能却很差，因为互斥锁 synchronized 将 getInstance() 方法串行化了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">  private static Singleton singleton;</span><br><span class="line">  &#x2F;&#x2F; 构造方法私有化  </span><br><span class="line">  private Singleton()&#123;&#125;</span><br><span class="line">  &#x2F;&#x2F; 获取实例（单例）</span><br><span class="line">  public synchronized static  Singleton getInstance()&#123;</span><br><span class="line">    if(singleton &#x3D;&#x3D; null)&#123;</span><br><span class="line">      singleton&#x3D;new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    return singleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>办法当然是有的，那就是经典的<strong>双重检查</strong>（Double Check）方案</p><p>在双重检查方案中，一旦 Singleton 对象被成功创建之后，就不会执行 synchronized(Singleton.class){}相关的代码，也就是说，此时 getInstance() 方法的执行路径是无锁的，从而解决了性能问题。不过需要注意的是，这个方案中使用了 volatile 来禁止编译优化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">  private static volatile  Singleton singleton;</span><br><span class="line">  &#x2F;&#x2F; 构造方法私有化  </span><br><span class="line">  private Singleton() &#123;&#125;</span><br><span class="line">  &#x2F;&#x2F; 获取实例（单例）</span><br><span class="line">  public static Singleton getInstance() &#123;</span><br><span class="line">    &#x2F;&#x2F; 第一次检查</span><br><span class="line">    if(singleton&#x3D;&#x3D;null)&#123;</span><br><span class="line">      synchronize&#123;Singleton.class)&#123;</span><br><span class="line">        &#x2F;&#x2F; 获取锁后二次检查</span><br><span class="line">        if(singleton&#x3D;&#x3D;null)&#123;</span><br><span class="line">          singleton&#x3D;new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return singleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>Balking 模式和 Guarded Suspension 模式从实现上看似乎没有多大的关系，Balking 模式只需要用互斥锁就能解决，而 Guarded Suspension 模式则要用到管程这种高级的并发原语；但是从应用的角度来看，它们解决的都是“线程安全的 if”语义，不同之处在于，Guarded Suspension 模式会等待 if 条件为真，而 Balking 模式不会等待。</p><p>Balking 模式的经典实现是使用互斥锁，你可以使用 Java 语言内置 synchronized，也可以使用 SDK 提供 Lock；如果对互斥锁的性能不满意，可以尝试采用 volatile 方案，不过使用 volatile 方案需要你更加谨慎。</p><h1 id="33-Thread-Per-Message模式：最简单实用的分工方法"><a href="#33-Thread-Per-Message模式：最简单实用的分工方法" class="headerlink" title="33 | Thread-Per-Message模式：最简单实用的分工方法"></a>33 | Thread-Per-Message模式：最简单实用的分工方法</h1><p>并发编程领域的问题总结为三个核心问题：分工、同步和互斥。其中，同步和互斥相关问题更多地源自微观，而分工问题则是源自宏观。我们解决问题，往往都是从宏观入手，在编程领域，软件的设计过程也是先从概要设计开始，而后才进行详细设计。同样，<strong>解决并发编程问题，首要问题也是解决宏观的分工问题</strong>。</p><p>并发编程领域里，解决分工问题也有一系列的设计模式，比较常用的主要有 Thread-Per-Message 模式、Worker Thread 模式、生产者 - 消费者模式等等。</p><h2 id="如何理解-Thread-Per-Message-模式"><a href="#如何理解-Thread-Per-Message-模式" class="headerlink" title="如何理解 Thread-Per-Message 模式"></a>如何理解 Thread-Per-Message 模式</h2><p>现实世界里，很多事情我们都需要委托他人办理，一方面受限于我们的能力，总有很多搞不定的事，比如教育小朋友，搞不定怎么办呢？只能委托学校老师了；另一方面受限于我们的时间，比如忙着写 Bug，哪有时间买别墅呢？只能委托房产中介了。委托他人代办有一个非常大的好处，那就是可以专心做自己的事了。</p><p>在编程领域也有很多类似的需求，比如写一个 HTTP Server，很显然只能在主线程中接收请求，而不能处理 HTTP 请求，因为如果在主线程中处理 HTTP 请求的话，那同一时间只能处理一个请求，太慢了！怎么办呢？可以利用代办的思路，创建一个子线程，委托子线程去处理 HTTP 请求。</p><p>这种委托他人办理的方式，在并发编程领域被总结为一种设计模式，叫做<strong>Thread-Per-Message 模式</strong>，简言之就是为每个任务分配一个独立的线程。</p><h2 id="用-Thread-实现-Thread-Per-Message-模式"><a href="#用-Thread-实现-Thread-Per-Message-模式" class="headerlink" title="用 Thread 实现 Thread-Per-Message 模式"></a>用 Thread 实现 Thread-Per-Message 模式</h2><p>Thread-Per-Message 模式的一个最经典的应用场景是<strong>网络编程里服务端的实现</strong>，服务端为每个客户端请求创建一个独立的线程，当线程处理完请求后，自动销毁，这是一种最简单的并发处理网络请求的方法。</p><p>示例代码如下，我们为每个请求都创建了一个 Java 线程，核心代码是：new Thread(()-&gt;{…}).start()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">final ServerSocketChannel ssc &#x3D; ServerSocketChannel.open().bind(new InetSocketAddress(8080));</span><br><span class="line">&#x2F;&#x2F; 处理请求    </span><br><span class="line">try &#123;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    &#x2F;&#x2F; 接收请求</span><br><span class="line">    SocketChannel sc &#x3D; ssc.accept();</span><br><span class="line">    &#x2F;&#x2F; 每个请求都创建一个线程</span><br><span class="line">    new Thread(()-&gt;&#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        &#x2F;&#x2F; 读 Socket</span><br><span class="line">        ByteBuffer rb &#x3D; ByteBuffer.allocateDirect(1024);</span><br><span class="line">        sc.read(rb);</span><br><span class="line">        &#x2F;&#x2F; 模拟处理请求</span><br><span class="line">        Thread.sleep(2000);</span><br><span class="line">        &#x2F;&#x2F; 写 Socket</span><br><span class="line">        ByteBuffer wb &#x3D; (ByteBuffer)rb.flip();</span><br><span class="line">        sc.write(wb);</span><br><span class="line">        &#x2F;&#x2F; 关闭 Socket</span><br><span class="line">        sc.close();</span><br><span class="line">      &#125;catch(Exception e)&#123;</span><br><span class="line">        throw new UncheckedIOException(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  ssc.close();</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>面这个 echo 服务的实现方案是不具备可行性的。原因在于 Java 中的线程是一个重量级的对象，创建成本很高，一方面创建线程比较耗时，另一方面线程占用的内存也比较大。所以，为每个请求创建一个新的线程并不适合高并发场景。</p><p>Java 语言里，Java 线程是和操作系统线程一一对应的，这种做法本质上是将 Java 线程的调度权完全委托给操作系统，而操作系统在这方面非常成熟，所以这种做法的好处是稳定、可靠，但是也继承了操作系统线程的缺点：创建成本高。为了解决这个缺点，Java 并发包里提供了线程池等工具类。这个思路在很长一段时间里都是很稳妥的方案，但是这个方案并不是唯一的方案。</p><p>业界还有另外一种方案，叫做<strong>轻量级线程</strong>。这个方案在 Java 领域知名度并不高，但是在其他编程语言里却叫得很响，例如 Go 语言、Lua 语言里的协程，本质上就是一种轻量级的线程。轻量级的线程，创建的成本很低，基本上和创建一个普通对象的成本相似；并且创建的速度和内存占用相比操作系统线程至少有一个数量级的提升，所以基于轻量级线程实现 Thread-Per-Message 模式就完全没有问题了。</p><p>Java 语言目前也已经意识到轻量级线程的重要性了，OpenJDK 有个 Loom 项目，就是要解决 Java 语言的轻量级线程问题，在这个项目中，轻量级线程被叫做<strong>Fiber</strong>。</p><h2 id="用-Fiber-实现-Thread-Per-Message-模式"><a href="#用-Fiber-实现-Thread-Per-Message-模式" class="headerlink" title="用 Fiber 实现 Thread-Per-Message 模式"></a>用 Fiber 实现 Thread-Per-Message 模式</h2><p>用 Fiber 实现 echo 服务的示例代码如下所示，对比 Thread 的实现，会发现改动量非常小，只需要把 new Thread(()-&gt;{…}).start() 换成 Fiber.schedule(()-&gt;{}) 就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">final ServerSocketChannel ssc &#x3D; </span><br><span class="line">  ServerSocketChannel.open().bind(new InetSocketAddress(8080));</span><br><span class="line">&#x2F;&#x2F; 处理请求</span><br><span class="line">try&#123;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    &#x2F;&#x2F; 接收请求</span><br><span class="line">    final SocketChannel sc &#x3D; serverSocketChannel.accept();</span><br><span class="line">    Fiber.schedule(()-&gt;&#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        &#x2F;&#x2F; 读 Socket</span><br><span class="line">        ByteBuffer rb &#x3D; ByteBuffer.allocateDirect(1024);</span><br><span class="line">        sc.read(rb);</span><br><span class="line">        &#x2F;&#x2F; 模拟处理请求</span><br><span class="line">        LockSupport.parkNanos(2000*1000000);</span><br><span class="line">        &#x2F;&#x2F; 写 Socket</span><br><span class="line">        ByteBuffer wb &#x3D; (ByteBuffer)rb.flip()</span><br><span class="line">        sc.write(wb);</span><br><span class="line">        &#x2F;&#x2F; 关闭 Socket</span><br><span class="line">        sc.close();</span><br><span class="line">      &#125; catch(Exception e)&#123;</span><br><span class="line">        throw new UncheckedIOException(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;&#x2F;&#x2F;while</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">  ssc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先通过 <code>ulimit -u 512</code> 将用户能创建的最大进程数（包括线程）设置为 512；</li><li>启动 Fiber 实现的 echo 程序；</li><li>利用压测工具 ab 进行压测：ab -r -c 20000 -n 200000 <a target="_blank" rel="noopener" href="http://测试机ip地址:8080/">http:// 测试机 IP 地址:8080/</a></li></ol><p>压测执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Concurrency Level:      20000</span><br><span class="line">Time taken for tests:   67.718 seconds</span><br><span class="line">Complete requests:      200000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Write errors:           0</span><br><span class="line">Non-2xx responses:      200000</span><br><span class="line">Total transferred:      16400000 bytes</span><br><span class="line">HTML transferred:       0 bytes</span><br><span class="line">Requests per second:    2953.41 [#&#x2F;sec] (mean)</span><br><span class="line">Time per request:       6771.844 [ms] (mean)</span><br><span class="line">Time per request:       0.339 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          236.50 [Kbytes&#x2F;sec] received</span><br><span class="line"> </span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+&#x2F;-sd] median   max</span><br><span class="line">Connect:        0  557 3541.6      1   63127</span><br><span class="line">Processing:  2000 2010  31.8   2003    2615</span><br><span class="line">Waiting:     1986 2008  30.9   2002    2615</span><br><span class="line">Total:       2000 2567 3543.9   2004   65293</span><br></pre></td></tr></table></figure><p>你会发现即便在 20000 并发下，该程序依然能够良好运行。同等条件下，Thread 实现的 echo 程序 512 并发都抗不过去，直接就 OOM 了。</p><p>如果通过 Linux 命令 <code>top -Hp pid</code> 查看 Fiber 实现的 echo 程序的进程信息，你可以看到该进程仅仅创建了 16（不同 CPU 核数结果会不同）个操作系统线程。</p><p><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202205230009464.png" alt="image-20220523000907710"></p><h1 id="34-Worker-Thread模式：如何避免重复创建线程？"><a href="#34-Worker-Thread模式：如何避免重复创建线程？" class="headerlink" title="34 | Worker Thread模式：如何避免重复创建线程？"></a>34 | Worker Thread模式：如何避免重复创建线程？</h1><p>Thread-Per-Message 模式，对应到现实世界，其实就是委托代办。这种分工模式如果用 Java Thread 实现，频繁地创建、销毁线程非常影响性能，同时无限制地创建线程还可能导致 OOM，所以在 Java 领域使用场景就受限了。</p><h2 id="Worker-Thread-模式及其实现"><a href="#Worker-Thread-模式及其实现" class="headerlink" title="Worker Thread 模式及其实现"></a>Worker Thread 模式及其实现</h2><p>Worker Thread 模式可以类比现实世界里车间的工作模式：车间里的工人，有活儿了，大家一起干，没活儿了就聊聊天等着。</p><p>Worker Thread 模式中<strong>Worker Thread 对应到现实世界里，其实指的就是车间里的工人</strong>。不过这里需要注意的是，车间里的工人数量往往是确定的。</p><p><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202205230010337.png" alt="image-20220523001022197"></p><p>用阻塞队列做任务池，然后创建固定数量的线程消费阻塞队列中的任务。其实仔细想会发现，这个方案就是 Java 语言提供的线程池。</p><p>线程池有很多优点，例如能够避免重复创建、销毁线程，同时能够限制创建线程的上限等等。</p><h1 id="35-两阶段终止模式：如何优雅地终止线程？"><a href="#35-两阶段终止模式：如何优雅地终止线程？" class="headerlink" title="35 | 两阶段终止模式：如何优雅地终止线程？"></a>35 | 两阶段终止模式：如何优雅地终止线程？</h1><p>不是自己终止自己，而是在一个线程 T1 中，终止线程 T2；这里所谓的“优雅”，指的是给 T2 一个机会料理后事，而不是被一剑封喉。</p><h2 id="如何理解两阶段终止模式"><a href="#如何理解两阶段终止模式" class="headerlink" title="如何理解两阶段终止模式"></a>如何理解两阶段终止模式</h2><p>顾名思义，就是将终止过程分成两个阶段，其中第一个阶段主要是线程 T1 向线程 T2<strong>发送终止指令</strong>，而第二阶段则是线程 T2<strong>响应终止指令</strong>。</p><p><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202205230013576.png" alt="image-20220523001308833"></p><p><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202205230013548.png" alt="image-20220523001319834"></p><p>从这个图里你会发现，Java 线程进入终止状态的前提是线程进入 RUNNABLE 状态，而实际上线程也可能处在休眠状态，也就是说，我们要想终止一个线程，首先要把线程的状态从休眠状态转换到 RUNNABLE 状态。如何做到呢？这个要靠 Java Thread 类提供的<strong>interrupt() 方法</strong>，它可以将休眠状态的线程转换到 RUNNABLE 状态。</p><p>线程转换到 RUNNABLE 状态之后，我们如何再将其终止呢？RUNNABLE 状态转换到终止状态，优雅的方式是让 Java 线程自己执行完 run() 方法，所以一般我们采用的方法是<strong>设置一个标志位</strong>，然后线程会在合适的时机检查这个标志位，如果发现符合终止条件，则自动退出 run() 方法。这个过程其实就是我们前面提到的第二阶段：<strong>响应终止指令</strong>。</p><p><strong>interrupt() 方法</strong>和<strong>线程终止的标志位</strong>。</p><h2 id="用两阶段终止模式终止监控操作"><a href="#用两阶段终止模式终止监控操作" class="headerlink" title="用两阶段终止模式终止监控操作"></a>用两阶段终止模式终止监控操作</h2><p>// todo 记录2022 05 23</p><h1 id="36-生产者-消费者模式：用流水线思想提高效率"><a href="#36-生产者-消费者模式：用流水线思想提高效率" class="headerlink" title="36 | 生产者-消费者模式：用流水线思想提高效率"></a>36 | 生产者-消费者模式：用流水线思想提高效率</h1><p>并发编程领域很多地方也都用到了生产者 - 消费者模式，例如 Log4j2 中异步 Appender 内部也用到了生产者 - 消费者模式。</p><h2 id="生产者-消费者模式的优点"><a href="#生产者-消费者模式的优点" class="headerlink" title="生产者 - 消费者模式的优点"></a>生产者 - 消费者模式的优点</h2><p>生产者 - 消费者模式的核心是一个<strong>任务队列</strong>，生产者线程生产任务，并将任务添加到任务队列中，而消费者线程从任务队列中获取任务并执行。</p><p><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202205230016486.png" alt="image-20220523001618733"></p><p>从架构设计的角度来看，生产者 - 消费者模式有一个很重要的优点，就是<strong>解耦</strong>。解耦对于大型系统的设计非常重要，而解耦的一个关键就是组件之间的依赖关系和通信方式必须受限。在生产者 - 消费者模式中，生产者和消费者没有任何依赖关系，它们彼此之间的通信只能通过任务队列，所以<strong>生产者 - 消费者模式是一个不错的解耦方案</strong>。</p><p>生产者 - 消费者模式还有一个重要的优点就是<strong>支持异步，并且能够平衡生产者和消费者的速度差异</strong>。在生产者 - 消费者模式中，生产者线程只需要将任务添加到任务队列而无需等待任务被消费者线程执行完，也就是说任务的生产和消费是异步的，这是与传统的方法之间调用的本质区别，传统的方法之间调用是同步的。</p><p>异步化处理最简单的方式就是创建一个新的线程去处理，那中间增加一个“<strong>任务队列</strong>”究竟有什么用呢？我觉得主要还是用于<strong>平衡生产者和消费者的速度差异</strong>。我们假设生产者的速率很慢，而消费者的速率很高，比如是 1:3，如果生产者有 3 个线程，采用创建新的线程的方式，那么会创建 3 个子线程，而采用生产者 - 消费者模式，消费线程只需要 1 个就可以了。Java 语言里，Java 线程和操作系统线程是一一对应的，线程创建得太多，会增加上下文切换的成本，所以 Java 线程不是越多越好，适量即可。而<strong>生产者 - 消费者模式恰好能支持你用适量的线程</strong>。</p><h2 id="支持批量执行以提升性能"><a href="#支持批量执行以提升性能" class="headerlink" title="支持批量执行以提升性能"></a>支持批量执行以提升性能</h2><p>如果使用轻量级线程，就没有必要平衡生产者和消费者的速度差异了，因为轻量级线程本身就是廉价的，那是否意味着生产者 - 消费者模式在性能优化方面就无用武之地了呢？当然不是，有一类并发场景应用生产者 - 消费者模式就有奇效，那就是<strong>批量执行</strong>任务。</p><p>例如，我们要在数据库里 INSERT 1000 条数据，有两种方案：第一种方案是用 1000 个线程并发执行，每个线程 INSERT 一条数据；第二种方案是用 1 个线程，执行一个批量的 SQL，一次性把 1000 条数据 INSERT 进去。这两种方案，显然是第二种方案效率更高，其实这样的应用场景就是我们上面提到的批量执行场景。</p><p>利用生产者 - 消费者模式实现批量执行 SQL 非常简单：将原来直接 INSERT 数据到数据库的线程作为生产者线程，生产者线程只需将数据添加到任务队列，然后消费者线程负责将任务从任务队列中批量取出并批量执行。</p><p>在下面的示例代码中，我们创建了 5 个消费者线程负责批量执行 SQL，这 5 个消费者线程以 <code>while(true)&#123;&#125;</code> 循环方式批量地获取任务并批量地执行。需要注意的是，从任务队列中获取批量任务的方法 pollTasks() 中，首先是以阻塞方式获取任务队列中的一条任务，而后则是以非阻塞的方式获取任务；之所以首先采用阻塞方式，是因为如果任务队列中没有任务，这样的方式能够避免无谓的循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 任务队列</span><br><span class="line">BlockingQueue&lt;Task&gt; bq&#x3D;new LinkedBlockingQueue&lt;&gt;(2000);</span><br><span class="line">&#x2F;&#x2F; 启动 5 个消费者线程</span><br><span class="line">&#x2F;&#x2F; 执行批量任务  </span><br><span class="line">void start() &#123;</span><br><span class="line">  ExecutorService es&#x3D;xecutors.newFixedThreadPool(5);</span><br><span class="line">  for (int i&#x3D;0; i&lt;5; i++) &#123;</span><br><span class="line">    es.execute(()-&gt;&#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">          &#x2F;&#x2F; 获取批量任务</span><br><span class="line">          List&lt;Task&gt; ts&#x3D;pollTasks();</span><br><span class="line">          &#x2F;&#x2F; 执行批量任务</span><br><span class="line">          execTasks(ts);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 从任务队列中获取批量任务</span><br><span class="line">List&lt;Task&gt; pollTasks() throws InterruptedException&#123;</span><br><span class="line">  List&lt;Task&gt; ts&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">  &#x2F;&#x2F; 阻塞式获取一条任务</span><br><span class="line">  Task t &#x3D; bq.take();</span><br><span class="line">  while (t !&#x3D; null) &#123;</span><br><span class="line">    ts.add(t);</span><br><span class="line">    &#x2F;&#x2F; 非阻塞式获取一条任务</span><br><span class="line">    t &#x3D; bq.poll();</span><br><span class="line">  &#125;</span><br><span class="line">  return ts;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 批量执行任务</span><br><span class="line">execTasks(List&lt;Task&gt; ts) &#123;</span><br><span class="line">  &#x2F;&#x2F; 省略具体代码无数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="支持分阶段提交以提升性能"><a href="#支持分阶段提交以提升性能" class="headerlink" title="支持分阶段提交以提升性能"></a>支持分阶段提交以提升性能</h2><p>利用生产者 - 消费者模式还可以轻松地支持一种分阶段提交的应用场景。我们知道写文件如果同步刷盘性能会很慢，所以对于不是很重要的数据，我们往往采用异步刷盘的方式。</p><p>刷盘的时机是：</p><ol><li>ERROR 级别的日志需要立即刷盘；</li><li>数据积累到 500 条需要立即刷盘；</li><li>存在未刷盘数据，且 5 秒钟内未曾刷盘，需要立即刷盘。</li></ol><p>这个日志组件的异步刷盘操作本质上其实就是一种<strong>分阶段提交</strong>。</p><p>在下面的示例代码中，可以通过调用 <code>info()</code>和<code>error()</code> 方法写入日志，这两个方法都是创建了一个日志任务 LogMsg，并添加到阻塞队列中，调用 <code>info()</code>和<code>error()</code> 方法的线程是生产者；而真正将日志写入文件的是消费者线程，在 Logger 这个类中，我们只创建了 1 个消费者线程，在这个消费者线程中，会根据刷盘规则执行刷盘操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">class Logger &#123;</span><br><span class="line">  &#x2F;&#x2F; 任务队列  </span><br><span class="line">  final BlockingQueue&lt;LogMsg&gt; bq &#x3D; new BlockingQueue&lt;&gt;();</span><br><span class="line">  &#x2F;&#x2F;flush 批量  </span><br><span class="line">  static final int batchSize&#x3D;500;</span><br><span class="line">  &#x2F;&#x2F; 只需要一个线程写日志</span><br><span class="line">  ExecutorService es &#x3D;  Executors.newFixedThreadPool(1);</span><br><span class="line">  &#x2F;&#x2F; 启动写日志线程</span><br><span class="line">  void start()&#123;</span><br><span class="line">    File file&#x3D;File.createTempFile(&quot;foo&quot;, &quot;.log&quot;);</span><br><span class="line">    final FileWriter writer&#x3D;new FileWriter(file);</span><br><span class="line">    this.es.execute(()-&gt;&#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        &#x2F;&#x2F; 未刷盘日志数量</span><br><span class="line">        int curIdx &#x3D; 0;</span><br><span class="line">        long preFT&#x3D;System.currentTimeMillis();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">          LogMsg log &#x3D; bq.poll(</span><br><span class="line">            5, TimeUnit.SECONDS);</span><br><span class="line">          &#x2F;&#x2F; 写日志</span><br><span class="line">          if (log !&#x3D; null) &#123;</span><br><span class="line">            writer.write(log.toString());</span><br><span class="line">            ++curIdx;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F; 如果不存在未刷盘数据，则无需刷盘</span><br><span class="line">          if (curIdx &lt;&#x3D; 0) &#123;</span><br><span class="line">            continue;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F; 根据规则刷盘</span><br><span class="line">          if (log!&#x3D;null &amp;&amp; log.level&#x3D;&#x3D;LEVEL.ERROR ||</span><br><span class="line">              curIdx &#x3D;&#x3D; batchSize ||</span><br><span class="line">              System.currentTimeMillis()-preFT&gt;5000)&#123;</span><br><span class="line">            writer.flush();</span><br><span class="line">            curIdx &#x3D; 0;</span><br><span class="line">            preFT&#x3D;System.currentTimeMillis();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;catch(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          writer.flush();</span><br><span class="line">          writer.close();</span><br><span class="line">        &#125;catch(IOException e)&#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);  </span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 写 INFO 级别日志</span><br><span class="line">  void info(String msg) &#123;</span><br><span class="line">    bq.put(new LogMsg(</span><br><span class="line">      LEVEL.INFO, msg));</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 写 ERROR 级别日志</span><br><span class="line">  void error(String msg) &#123;</span><br><span class="line">    bq.put(new LogMsg(</span><br><span class="line">      LEVEL.ERROR, msg));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 日志级别</span><br><span class="line">enum LEVEL &#123;</span><br><span class="line">  INFO, ERROR</span><br><span class="line">&#125;</span><br><span class="line">class LogMsg &#123;</span><br><span class="line">  LEVEL level;</span><br><span class="line">  String msg;</span><br><span class="line">  &#x2F;&#x2F; 省略构造函数实现</span><br><span class="line">  LogMsg(LEVEL lvl, String msg)&#123;&#125;</span><br><span class="line">  &#x2F;&#x2F; 省略 toString() 实现</span><br><span class="line">  String toString()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></div><div class="post_share"><div class="social-share" data-image="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202205192229069.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/kele.png" target="_blank"><img class="post-qr-code-img" src="/img/kele.png" alt="觉得还不错，请他喝一瓶可乐"></a><div class="post-qr-code-desc">觉得还不错，请他喝一瓶可乐</div></li><li class="reward-item"><a href="/img/ali.jpg" target="_blank"><img class="post-qr-code-img" src="/img/ali.jpg" alt="雪碧也是可以的"></a><div class="post-qr-code-desc">雪碧也是可以的</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/20220523/%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/"><img class="prev-cover" src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202205192229069.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">并发系列-第4章-案例分析</div></div></a></div><div class="next-post pull-right"><a href="/20220521/%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"><img class="next-cover" src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202205192229069.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">并发系列-第2章-并发工具类</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/20220519/并发系列-第1章-并发理论基础/" title="并发系列-第1章-并发理论基础"><img class="cover" src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202205192229069.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-19</div><div class="title">并发系列-第1章-并发理论基础</div></div></a></div><div><a href="/20220521/并发系列-第2章-并发工具类/" title="并发系列-第2章-并发工具类"><img class="cover" src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202205192229069.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-21</div><div class="title">并发系列-第2章-并发工具类</div></div></a></div><div><a href="/20220523/并发系列-第4章-案例分析/" title="并发系列-第4章-案例分析"><img class="cover" src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202205192229069.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-23</div><div class="title">并发系列-第4章-案例分析</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/tx2.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"><div class="author-info__name">章志成</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/gump12138"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/cooper12138" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:994739211@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">延迟满足</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#28-Immutability%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E4%B8%8D%E5%8F%98%E6%80%A7%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">28 | Immutability模式：如何利用不变性解决并发问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E9%81%BF%E5%85%8D%E5%88%9B%E5%BB%BA%E9%87%8D%E5%A4%8D%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.</span> <span class="toc-text">利用享元模式避免创建重复对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Immutability-%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.2.</span> <span class="toc-text">使用 Immutability 模式的注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#29-Copy-on-Write%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%B8%8D%E6%98%AF%E5%BB%B6%E6%97%B6%E7%AD%96%E7%95%A5%E7%9A%84COW"><span class="toc-number">2.</span> <span class="toc-text">29 | Copy-on-Write模式：不是延时策略的COW</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Copy-on-Write-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E9%A2%86%E5%9F%9F"><span class="toc-number">2.1.</span> <span class="toc-text">Copy-on-Write 模式的应用领域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#30-%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%EF%BC%9A%E6%B2%A1%E6%9C%89%E5%85%B1%E4%BA%AB%EF%BC%8C%E5%B0%B1%E6%B2%A1%E6%9C%89%E4%BC%A4%E5%AE%B3"><span class="toc-number">3.</span> <span class="toc-text">30 | 线程本地存储模式：没有共享，就没有伤害</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">ThreadLocal 的使用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">ThreadLocal 的工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal-%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-number">3.3.</span> <span class="toc-text">ThreadLocal 与内存泄露</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InheritableThreadLocal-%E4%B8%8E%E7%BB%A7%E6%89%BF%E6%80%A7"><span class="toc-number">3.4.</span> <span class="toc-text">InheritableThreadLocal 与继承性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#31-Guarded-Suspension%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6%E7%9A%84%E8%A7%84%E8%8C%83%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">31 | Guarded Suspension模式：等待唤醒机制的规范实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Guarded-Suspension-%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">Guarded Suspension 模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95-Guarded-Suspension-%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">扩展 Guarded Suspension 模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#32-Balking%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%86%8D%E8%B0%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">32 | Balking模式：再谈线程安全的单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Balking-%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%8F%E5%85%B8%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.1.</span> <span class="toc-text">Balking 模式的经典实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8-volatile-%E5%AE%9E%E7%8E%B0-Balking-%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.2.</span> <span class="toc-text">用 volatile 实现 Balking 模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">5.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#33-Thread-Per-Message%E6%A8%A1%E5%BC%8F%EF%BC%9A%E6%9C%80%E7%AE%80%E5%8D%95%E5%AE%9E%E7%94%A8%E7%9A%84%E5%88%86%E5%B7%A5%E6%96%B9%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">33 | Thread-Per-Message模式：最简单实用的分工方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-Thread-Per-Message-%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.1.</span> <span class="toc-text">如何理解 Thread-Per-Message 模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8-Thread-%E5%AE%9E%E7%8E%B0-Thread-Per-Message-%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">用 Thread 实现 Thread-Per-Message 模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8-Fiber-%E5%AE%9E%E7%8E%B0-Thread-Per-Message-%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.3.</span> <span class="toc-text">用 Fiber 实现 Thread-Per-Message 模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#34-Worker-Thread%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">34 | Worker Thread模式：如何避免重复创建线程？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Worker-Thread-%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.1.</span> <span class="toc-text">Worker Thread 模式及其实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#35-%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">35 | 两阶段终止模式：如何优雅地终止线程？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.1.</span> <span class="toc-text">如何理解两阶段终止模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F%E7%BB%88%E6%AD%A2%E7%9B%91%E6%8E%A7%E6%93%8D%E4%BD%9C"><span class="toc-number">8.2.</span> <span class="toc-text">用两阶段终止模式终止监控操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#36-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%94%A8%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%80%9D%E6%83%B3%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87"><span class="toc-number">9.</span> <span class="toc-text">36 | 生产者-消费者模式：用流水线思想提高效率</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">9.1.</span> <span class="toc-text">生产者 - 消费者模式的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E6%89%B9%E9%87%8F%E6%89%A7%E8%A1%8C%E4%BB%A5%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD"><span class="toc-number">9.2.</span> <span class="toc-text">支持批量执行以提升性能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E5%88%86%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E4%BB%A5%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD"><span class="toc-number">9.3.</span> <span class="toc-text">支持分阶段提交以提升性能</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/20220828/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/" title="设计模式总结"><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202208282314841.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="设计模式总结"></a><div class="content"><a class="title" href="/20220828/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/" title="设计模式总结">设计模式总结</a><time datetime="2022-08-28T15:11:14.000Z" title="发表于 2022-08-28 23:11:14">2022-08-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/20220813/spring-cache-redis%E8%87%AA%E5%AE%9A%E4%B9%89cache/" title="spring-cache+redis自定义cache"><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202208132131962.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="spring-cache+redis自定义cache"></a><div class="content"><a class="title" href="/20220813/spring-cache-redis%E8%87%AA%E5%AE%9A%E4%B9%89cache/" title="spring-cache+redis自定义cache">spring-cache+redis自定义cache</a><time datetime="2022-08-13T13:29:30.000Z" title="发表于 2022-08-13 21:29:30">2022-08-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/20220710/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E7%9B%98/" title="如何搭建自己的网盘"><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202207101923657.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="如何搭建自己的网盘"></a><div class="content"><a class="title" href="/20220710/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E7%9B%98/" title="如何搭建自己的网盘">如何搭建自己的网盘</a><time datetime="2022-07-10T11:22:08.000Z" title="发表于 2022-07-10 19:22:08">2022-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/20220607/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E5%AE%B9%E5%99%A8IOC-2/" title="手写spring系列-第3章-容器IOC-2"><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206042241269.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="手写spring系列-第3章-容器IOC-2"></a><div class="content"><a class="title" href="/20220607/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E5%AE%B9%E5%99%A8IOC-2/" title="手写spring系列-第3章-容器IOC-2">手写spring系列-第3章-容器IOC-2</a><time datetime="2022-06-07T15:40:17.000Z" title="发表于 2022-06-07 23:40:17">2022-06-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/20220605/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Bean%E5%AE%B9%E5%99%A8/" title="手写spring系列-第2章-容器IOC-1"><img src="https://bolg2022.oss-cn-hangzhou.aliyuncs.com/202206042241269.jpeg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="手写spring系列-第2章-容器IOC-1"></a><div class="content"><a class="title" href="/20220605/%E6%89%8B%E5%86%99spring%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Bean%E5%AE%B9%E5%99%A8/" title="手写spring系列-第2章-容器IOC-1">手写spring系列-第2章-容器IOC-1</a><time datetime="2022-06-05T12:44:03.000Z" title="发表于 2022-06-05 20:44:03">2022-06-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 章志成</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="http://hankz.cc/">一个cv大师</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>function loadValine(){function e(){new Valine(Object.assign({el:"#vcomment",appId:"rX8EGp1QDIbaOBer0HPXb4wr-gzGzoHsz",appKey:"zYi2FKT3jfoRihSzwUQkzwd3",placeholder:"Please leave your footprints",avatar:"monsterid",meta:"nick,mail,link".split(","),pageSize:"10",lang:"zh-CN",recordIP:!1,serverURLs:"",emojiCDN:"",emojiMaps:"",enableQQ:!1,path:window.location.pathname,requiredFields:["nick,mail"],visitor:!1},null))}"function"==typeof Valine?e():getScript("https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js").then(e)}function loadOtherComment(){loadValine()}setTimeout(loadValine,0)</script></div><div class="aplayer no-destroy" data-id="84943176" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-autoplay="false" data-theme="#2980b9" data-loop="all" data-order="random" data-preload="auto" data-volume="0.4" data-mutex="true" data-listfolded="true" data-listmaxheight="340px" data-storagename="metingjs" muted></div><div class="aplayer no-destroy" data-id="https://music.163.com/playlist?id=84943176&userid=77272308" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-autoplay="true" data-theme="#2980b9" data-loop="all" data-order="random" data-preload="auto" data-volume="0.4" data-mutex="true" data-listfolded="true" data-listmaxheight="340px" data-storagename="metingjs" muted></div><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async mobile="true"></script><script>!function(t,a,n){a.ChatraID="K3d9XytKCJ4u5JfPd";var c=t.createElement("script");a[n]=a[n]||function(){(a[n].q=a[n].q||[]).push(arguments)},c.async=!0,c.src="https://call.chatra.io/chatra.js",t.head&&t.head.appendChild(c)}(document,window,"Chatra");var chatBtnFn=()=>{document.getElementById("chat_btn").addEventListener("click",function(){Chatra("openChat")})};function chatBtnHide(){Chatra("hide")}function chatBtnShow(){Chatra("show")}chatBtnFn()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:complete",function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script");var o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()}),document.addEventListener("pjax:send",function(){if("object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")}),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>