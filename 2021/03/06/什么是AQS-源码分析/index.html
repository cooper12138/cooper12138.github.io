<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>什么是AQS?源码分析 | 不学习会被杀掉的！</title><meta name="keywords" content="源码"><meta name="author" content="章志成"><meta name="copyright" content="章志成"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="AQS简介java.util.concurrent.locks.AbstractQueuedSynchronizer 抽象类，简称 AQS ，是一个用于构建锁和同步容器的同步器。concurrent&#96; 包内许多类都是基于 AQS 构建。如 ReentrantLock，Semaphore，CountDownLatch，ReentrantReadWriteLock，等。 AQS 使用一个 FIFO 的">
<meta property="og:type" content="article">
<meta property="og:title" content="什么是AQS?源码分析">
<meta property="og:url" content="http://example.com/2021/03/06/%E4%BB%80%E4%B9%88%E6%98%AFAQS-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="不学习会被杀掉的！">
<meta property="og:description" content="AQS简介java.util.concurrent.locks.AbstractQueuedSynchronizer 抽象类，简称 AQS ，是一个用于构建锁和同步容器的同步器。concurrent&#96; 包内许多类都是基于 AQS 构建。如 ReentrantLock，Semaphore，CountDownLatch，ReentrantReadWriteLock，等。 AQS 使用一个 FIFO 的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hankz.oss-cn-hangzhou.aliyuncs.com/wallhaven-39em6d.png">
<meta property="article:published_time" content="2021-03-06T08:48:59.000Z">
<meta property="article:modified_time" content="2022-05-15T07:29:59.086Z">
<meta property="article:author" content="章志成">
<meta property="article:tag" content="源码">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hankz.oss-cn-hangzhou.aliyuncs.com/wallhaven-39em6d.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/03/06/%E4%BB%80%E4%B9%88%E6%98%AFAQS-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-15 15:29:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/tx2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-messageboard"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://hankz.oss-cn-hangzhou.aliyuncs.com/wallhaven-39em6d.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">不学习会被杀掉的！</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-messageboard"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">什么是AQS?源码分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-06T08:48:59.000Z" title="发表于 2021-03-06 16:48:59">2021-03-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-15T07:29:59.086Z" title="更新于 2022-05-15 15:29:59">2022-05-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="什么是AQS?源码分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/03/06/%E4%BB%80%E4%B9%88%E6%98%AFAQS-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2021/03/06/%E4%BB%80%E4%B9%88%E6%98%AFAQS-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code> 抽象类，简称 AQS ，是一个用于构建锁和同步容器的同步器。concurrent` 包内许多类都是基于 AQS 构建。如 ReentrantLock，Semaphore，CountDownLatch，ReentrantReadWriteLock，等。</p>
<p>AQS 使用一个 FIFO 的队列表示排队等待锁的线程，队列头节点称作“哨兵节点”，它不与任何线程关联。其他的节点与等待线程关联，每个节点维护一个等待状态 <code>waitStatus</code> 。</p>
<p>它是 J.U.C 并发包中的核心基础组件。</p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>AQS 解决了在实现同步器时涉及当的大量细节问题，例如获取同步状态、FIFO 同步队列。基于 AQS 来构建同步器可以带来<strong>很多好处</strong>。它不仅能够极大地减少实现工作，而且也不必处理在多个位置上发生的竞争问题。</p>
<p>在基于 AQS 构建的同步器中，只能在一个时刻发生阻塞，从而降低上下文切换的开销，提高了吞吐量。同时在设计 AQS 时充分考虑了可伸缩性，因此 J.U.C 中，所有基于 AQS 构建的同步器均可以获得这个优势。</p>
<h4 id="同步状态"><a href="#同步状态" class="headerlink" title="同步状态"></a>同步状态</h4><p>AQS 的主要使用方式是<strong>继承</strong>，子类通过继承同步器，并实现它的<strong>抽象方法</strong>来管理同步状态。</p>
<p>AQS 使用一个 <code>int</code> 类型的成员变量 <code>state</code> 来<strong>表示同步状态</strong>：</p>
<ul>
<li>当 <code>state &gt; 0</code> 时，表示已经获取了锁。</li>
<li>当 <code>state = 0</code> 时，表示释放了锁。</li>
</ul>
<p>它提供了三个方法，来对同步状态 <code>state</code> 进行操作，并且 AQS 可以确保对 <code>state</code> 的操作是<strong>安全</strong>的：</p>
<ul>
<li><code>#getState()</code></li>
<li><code>#setState(int newState)</code></li>
<li><code>#compareAndSetState(int expect, int update)</code></li>
</ul>
<h4 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h4><p>AQS 通过内置的 FIFO 同步队列来完成资源获取线程的<strong>排队工作</strong>：</p>
<ul>
<li>如果当前线程获取同步状态失败（锁）时，AQS 则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程</li>
<li>当同步状态<strong>释放</strong>时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。</li>
</ul>
<h4 id="主要内置方法"><a href="#主要内置方法" class="headerlink" title="主要内置方法"></a>主要内置方法</h4><p>AQS 主要提供了如下<strong>方法</strong>：</p>
<ul>
<li><code>#getState()</code>：返回同步状态的当前值。</li>
<li><code>#setState(int newState)</code>：设置当前同步状态。</li>
<li><code>#compareAndSetState(int expect, int update)</code>：使用 CAS 设置当前状态，该方法能够保证状态设置的原子性。</li>
<li>【可重写】<code>#tryAcquire(int arg)</code>：独占式获取同步状态，获取同步状态成功后，其他线程需要等待该线程释放同步状态才能获取同步状态。</li>
<li>【可重写】<code>#tryRelease(int arg)</code>：独占式释放同步状态。</li>
<li>【可重写】<code>#tryAcquireShared(int arg)</code>：共享式获取同步状态，返回值大于等于 0 ，则表示获取成功；否则，获取失败。</li>
<li>【可重写】<code>#tryReleaseShared(int arg)</code>：共享式释放同步状态。</li>
<li>【可重写】<code>#isHeldExclusively()</code>：当前同步器是否在独占式模式下被线程占用，一般该方法表示是否被当前线程所独占。</li>
<li><code>acquire(int arg)</code>：独占式获取同步状态。如果当前线程获取同步状态成功，则由该方法返回；否则，将会进入同步队列等待。该方法将会调用<strong>可重写</strong>的 <code>#tryAcquire(int arg)</code> 方法；</li>
<li><code>#acquireInterruptibly(int arg)</code>：与 <code>#acquire(int arg)</code> 相同，但是该方法响应中断。当前线程为获取到同步状态而进入到同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException 异常并返回。</li>
<li><code>#tryAcquireNanos(int arg, long nanos)</code>：超时获取同步状态。如果当前线程在 nanos 时间内没有获取到同步状态，那么将会返回 false ，已经获取则返回 true 。</li>
<li><code>#acquireShared(int arg)</code>：共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态；</li>
<li><code>#acquireSharedInterruptibly(int arg)</code>：共享式获取同步状态，响应中断。</li>
<li><code>#tryAcquireSharedNanos(int arg, long nanosTimeout)</code>：共享式获取同步状态，增加超时限制。</li>
<li><code>#release(int arg)</code>：独占式释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒。</li>
<li><code>#releaseShared(int arg)</code>：共享式释放同步状态。</li>
</ul>
<p>从上面的方法看下来，基本上可以分成 <strong>3</strong> 类：</p>
<ul>
<li><strong>独占式</strong>—–非公平锁—-获取与释放同步状态</li>
<li><strong>共享式</strong>—–公平锁—-获取与释放同步状态</li>
<li>查询<strong>同步队列</strong>中的等待线程情况</li>
</ul>
<hr>
<h3 id="AQS：CLH-同步队列"><a href="#AQS：CLH-同步队列" class="headerlink" title="AQS：CLH 同步队列"></a>AQS：CLH 同步队列</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>CLH 同步队列是一个 FIFO <strong>双向</strong>队列，AQS 依赖它来完成同步状态的管理：</p>
<ul>
<li>当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程</li>
<li>当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。</li>
</ul>
<h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><p>在 CLH 同步队列中，<strong>一个节点（Node），表示一个线程</strong>，它保存着线程的引用（<code>thread</code>）、状态（<code>waitStatus</code>）、前驱节点（<code>prev</code>）、后继节点（<code>next</code>）。其定义如下：</p>
<blockquote>
<p>Node 是 AbstractQueuedSynchronizer 的内部静态类。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 共享</span><br><span class="line">    static final Node SHARED &#x3D; new Node();</span><br><span class="line">    &#x2F;&#x2F; 独占</span><br><span class="line">    static final Node EXCLUSIVE &#x3D; null;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 因为超时或者中断，节点会被设置为取消状态，被取消的节点时不会参与到竞争中的，他会一直保持取消状态不会转变为其他状态</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static final int CANCELLED &#x3D;  1;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static final int SIGNAL    &#x3D; -1;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()后，该节点将会从等待队列中转移到同步队列中，加入到同步状态的获取中</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static final int CONDITION &#x3D; -2;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 表示下一次共享式同步状态获取，将会无条件地传播下去</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static final int PROPAGATE &#x3D; -3;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 等待状态 *&#x2F;</span><br><span class="line">    volatile int waitStatus;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 前驱节点，当节点添加到同步队列时被设置（尾部添加） *&#x2F;</span><br><span class="line">    volatile Node prev;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 后继节点 *&#x2F;</span><br><span class="line">    volatile Node next;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 等待队列中的后续节点。如果当前节点是共享的，那么字段将是一个 SHARED 常量，也就是说节点类型（独占和共享）和等待队列中的后续节点共用同一个字段 *&#x2F;</span><br><span class="line">    Node nextWaiter;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** 获取同步状态的线程 *&#x2F;</span><br><span class="line">    volatile Thread thread;</span><br><span class="line"></span><br><span class="line">    final boolean isShared() &#123;</span><br><span class="line">        return nextWaiter &#x3D;&#x3D; SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final Node predecessor() throws NullPointerException &#123;</span><br><span class="line">        Node p &#x3D; prev;</span><br><span class="line">        if (p &#x3D;&#x3D; null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        else</span><br><span class="line">            return p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123; &#x2F;&#x2F; Used to establish initial head or SHARED marker</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123; &#x2F;&#x2F; Used by addWaiter</span><br><span class="line">        this.nextWaiter &#x3D; mode;</span><br><span class="line">        this.thread &#x3D; thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, int waitStatus) &#123; &#x2F;&#x2F; Used by Condition</span><br><span class="line">        this.waitStatus &#x3D; waitStatus;</span><br><span class="line">        this.thread &#x3D; thread;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>waitStatus</code> 字段，等待状态，用来控制线程的阻塞和唤醒，并且可以避免不必要的调用LockSupport的 <code>#park(...)</code> 和 <code>#unpark(...)</code> 方法。</p>
<p>CLH 同步队列，结构图如下：</p>
<p><img src="https://gitee.com/chenssy/blog-home/raw/master/image/sijava/2018120810001.png" alt="CLH 同步队列"></p>
<ul>
<li><code>prev</code> 和 <code>next</code> 字段，是 <strong>AbstractQueuedSynchronizer</strong> 的字段，分别指向同步队列的头和尾。</li>
<li><code>head</code> 和 <code>tail</code> 字段，分别指向 Node 节点的<strong>前一个</strong>和<strong>后一个</strong> Node 节点，从而实现<strong>链式双向队列</strong>。再配合上 <code>prev</code> 和 <code>next</code> 字段，快速定位到同步队列的头尾。</li>
</ul>
<h4 id="入列"><a href="#入列" class="headerlink" title="入列"></a>入列</h4><ul>
<li><code>tail</code> 指向新节点。</li>
<li>新节点的 <code>prev</code> 指向当前最后的节点。</li>
<li>当前最后一个节点的 <code>next</code> 指向当前节点。</li>
</ul>
<p>过程图如下：</p>
<p><img src="https://gitee.com/chenssy/blog-home/raw/master/image/sijava/2018120810002.png" alt="入列 流程"></p>
<p>但是，实际上，入队逻辑实现的 <code>#addWaiter(Node)</code> 方法，需要考虑<strong>并发</strong>的情况。它通过 <strong>CAS</strong> 的方式，来保证正确的添加 Node 。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> 1: private Node addWaiter(Node mode) &#123;</span><br><span class="line"> 2:     &#x2F;&#x2F; 新建节点</span><br><span class="line"> 3:     Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line"> 4:     &#x2F;&#x2F; 记录原尾节点</span><br><span class="line"> 5:     Node pred &#x3D; tail;</span><br><span class="line"> 6:     &#x2F;&#x2F; 快速尝试，添加新节点为尾节点</span><br><span class="line"> 7:     if (pred !&#x3D; null) &#123;</span><br><span class="line"> 8:         &#x2F;&#x2F; 设置新 Node 节点的尾节点为原尾节点</span><br><span class="line"> 9:         node.prev &#x3D; pred;</span><br><span class="line">10:         &#x2F;&#x2F; CAS 设置新的尾节点</span><br><span class="line">11:         if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">12:             &#x2F;&#x2F; 成功，原尾节点的下一个节点为新节点</span><br><span class="line">13:             pred.next &#x3D; node;</span><br><span class="line">14:             return node;</span><br><span class="line">15:         &#125;</span><br><span class="line">16:     &#125;</span><br><span class="line">17:     &#x2F;&#x2F; 失败，多次尝试，直到成功</span><br><span class="line">18:     enq(node);</span><br><span class="line">19:     return node;</span><br><span class="line">20: &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第 3 行：创建新节点 <code>node</code> 。在创建的构造方法，<code>mode</code> 方法参数，传递获取同步状态的模式。</p>
</li>
<li><p>第 5 行：记录<strong>原</strong>尾节点 <code>tail</code> 。</p>
</li>
<li><p>在下面的代码，会分成2部分：</p>
<ul>
<li>第 6 至 16 行：<strong>快速</strong>尝试，添加新节点为尾节点。</li>
<li>第 18 行：添加失败，<strong>多次</strong>尝试，直到成功添加。</li>
</ul>
</li>
<li><p>========== 第 <strong>1</strong> 部分 ==========</p>
</li>
<li><p>第 7 行：当<strong>原</strong>尾节点非空，才执行<strong>快速</strong>尝试的逻辑。在下面的 <code>#enq(Node node)</code> 方法中，我们会看到，<strong>首</strong>节点未初始化的时，<code>head</code> 和 <code>tail</code> 都为空。</p>
</li>
<li><p>第 9 行：设置<strong>新</strong>节点的<strong>尾</strong>节点为<strong>原</strong>尾节点。</p>
</li>
<li><p>第 11 行：调用 <code>#compareAndSetTail(Node expect, Node update)</code> 方法，使用 <strong>Unsafe</strong> 来 <strong>CAS</strong> 设置<strong>尾</strong>节点 <code>tail</code> 为<strong>新</strong>节点。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static final Unsafe unsafe &#x3D; Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">private static final long tailOffset &#x3D; unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;tail&quot;));  &#x2F;&#x2F; 这块代码，实际在 static 代码块，此处为了方便理解，做了简化。</span><br><span class="line"></span><br><span class="line">private final boolean compareAndSetTail(Node expect, Node update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapObject(this, tailOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>第 13 行：添加<strong>成功</strong>，最终，将<strong>原</strong>尾节点的下一个节点为<strong>新</strong>节点。</p>
</li>
<li><p>第 14 行：返回<strong>新</strong>节点。</p>
</li>
<li><p>如果添加<strong>失败</strong>，因为存在多线程并发的情况，此时需要执行【第 18 行】的代码。</p>
</li>
<li><p>========== 第 <strong>2</strong> 部分 ==========</p>
</li>
<li><p>调用 <code>#enq(Node node)</code> 方法，<strong>多次</strong>尝试，直到成功添加。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> 1: private Node enq(final Node node) &#123;</span><br><span class="line"> 2:     &#x2F;&#x2F; 多次尝试，直到成功为止</span><br><span class="line"> 3:     for (;;) &#123;</span><br><span class="line"> 4:         &#x2F;&#x2F; 记录原尾节点</span><br><span class="line"> 5:         Node t &#x3D; tail;</span><br><span class="line"> 6:         &#x2F;&#x2F; 原尾节点不存在，创建首尾节点都为 new Node()</span><br><span class="line"> 7:         if (t &#x3D;&#x3D; null) &#123;</span><br><span class="line"> 8:             if (compareAndSetHead(new Node()))</span><br><span class="line"> 9:                 tail &#x3D; head;</span><br><span class="line">10:         &#x2F;&#x2F; 原尾节点存在，添加新节点为尾节点</span><br><span class="line">11:         &#125; else &#123;</span><br><span class="line">12:             &#x2F;&#x2F;设置为尾节点</span><br><span class="line">13:             node.prev &#x3D; t;</span><br><span class="line">14:             &#x2F;&#x2F; CAS 设置新的尾节点</span><br><span class="line">15:             if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">16:                 &#x2F;&#x2F; 成功，原尾节点的下一个节点为新节点</span><br><span class="line">17:                 t.next &#x3D; node;</span><br><span class="line">18:                 return t;</span><br><span class="line">19:             &#125;</span><br><span class="line">20:         &#125;</span><br><span class="line">21:     &#125;</span><br><span class="line">22: &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第 3 行：“<strong>死</strong>”循环，多次尝试，直到成功添加<strong>为止</strong>【第 18 行】。</li>
<li>第 5 行：记录原尾节点 <code>t</code> 。🙂 和 <code>#addWaiter(Node node)</code> 方法的【第 5 行】相同。</li>
<li>第 10 至 19 行：原尾节点存在，添加新节点为尾节点。🙂 和 <code>#addWaiter(Node node)</code> 方法的【第 7 至 16 行】相同。</li>
<li>第 6 至 9 行：原尾节点不存在，创建<strong>首尾</strong>节点都为 <strong>new Node()</strong> 。<strong>注意</strong>，此时修改的<strong>首尾</strong>节点是重新创建( <code>new Node()</code> )的，而不是<strong>新节点</strong>！</li>
</ul>
</li>
</ul>
<h4 id="出列"><a href="#出列" class="headerlink" title="出列"></a>出列</h4><p>CLH 同步队列遵循 FIFO，首节点的线程释放同步状态后，将会唤醒它的<strong>下一个</strong>节点（<code>Node.next</code>）。而后继节点将会在获取同步状态成功时，将自己设置为首节点( <code>head</code> )。</p>
<p>这个过程非常简单，<code>head</code> 执行该节点并断开原首节点的 <code>next</code> 和当前节点的 <code>prev</code> 即可。注意，在这个过程是<strong>不需要使用 CAS 来保证</strong>的，因为<strong>只有一个</strong>线程，能够成功获取到同步状态。</p>
<p>过程图如下：</p>
<p><img src="https://gitee.com/chenssy/blog-home/raw/master/image/sijava/2018120810003.png" alt="过程图"></p>
<p><code>#setHead(Node node)</code> 方法，实现上述的<strong>出列</strong>逻辑。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void setHead(Node node) &#123;</span><br><span class="line">    head &#x3D; node;</span><br><span class="line">    node.thread &#x3D; null;</span><br><span class="line">    node.prev &#x3D; null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="AQS：同步状态的获取与释放"><a href="#AQS：同步状态的获取与释放" class="headerlink" title="AQS：同步状态的获取与释放"></a>AQS：同步状态的获取与释放</h3><p>AQS 的设计模式采用的<strong>模板方法模式</strong>，子类通过继承的方式，实现它的抽象方法来管理同步状态。对于子类而言，它并没有太多的活要做，AQS 已经提供了大量的模板方法来实现同步，主要是分为三类：</p>
<ul>
<li>独占式获取和释放同步状态</li>
<li>共享式获取和释放同步状态</li>
<li>查询同步队列中的等待线程情况。</li>
</ul>
<p>自定义子类使用 AQS 提供的模板方法，就可以实现<strong>自己的同步语义</strong>。</p>
<h4 id="独占式"><a href="#独占式" class="headerlink" title="独占式"></a>独占式</h4><p>独占式，<strong>同一时刻，仅有一个线程持有同步状态</strong>。</p>
<h5 id="独占式同步状态获取"><a href="#独占式同步状态获取" class="headerlink" title="独占式同步状态获取"></a>独占式同步状态获取</h5><p><code>#acquire(int arg)</code> 方法，为 AQS 提供的<strong>模板方法</strong>。该方法为独占式获取同步状态，但是该方法对<strong>中断不敏感</strong>。也就是说，由于线程获取同步状态失败而加入到 CLH 同步队列中，后续对该线程进行中断操作时，线程<strong>不会</strong>从 CLH 同步队列中<strong>移除</strong>。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1: public final void acquire(int arg) &#123;</span><br><span class="line">2:     if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">3:         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">4:         selfInterrupt();</span><br><span class="line">5: &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第 2 行：调用 <code>#tryAcquire(int arg)</code> 方法，去尝试获取同步状态，获取成功则设置锁状态并返回 true ，否则获取失败，返回 false 。若获取成功，<code>#acquire(int arg)</code> 方法，直接返回，<strong>不用线程阻塞</strong>，自旋直到获得同步状态成功。</p>
</li>
<li><p>第 3 行：如果 <code>#tryAcquire(int arg)</code> 方法返回 false ，即获取同步状态失败，则调用 <code>#addWaiter(Node mode)</code> 方法，将当前线程加入到 CLH 同步队列尾部。并且， <code>mode</code> 方法参数为 <code>Node.EXCLUSIVE</code> ，表示<strong>独占</strong>模式。</p>
</li>
<li><p>第 3 行：调用 <code>boolean #acquireQueued(Node node, int arg)</code> 方法，自旋直到获得同步状态成功。另外，该方法的返回值类型为 <code>boolean</code> ，当返回 true 时，表示在这个过程中，发生过<strong>线程中断</strong>。但是，这个方法又会<strong>清理</strong>线程中断的<strong>标识</strong>，所以在种情况下，需要调用【第 4 行】的 <code>#selfInterrupt()</code> 方法，恢复线程中断的<strong>标识</strong>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void selfInterrupt() &#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h6><p><code>boolean #acquireQueued(Node node, int arg)</code> 方法，为一个<strong>自旋</strong>的过程，也就是说，当前线程（Node）进入同步队列后，就会进入一个自旋的过程，每个节点都会<strong>自省</strong>地观察，当条件满足，获取到同步状态后，就可以从这个自旋过程中退出，否则会一直执行下去。</p>
<p><strong>流程图</strong>如下：</p>
<p><img src="https://gitee.com/chenssy/blog-home/raw/master/image/sijava/2018120811001.png" alt="流程图"></p>
<p><strong>代码</strong>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> 1: final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line"> 2:     &#x2F;&#x2F; 记录是否获取同步状态成功</span><br><span class="line"> 3:     boolean failed &#x3D; true;</span><br><span class="line"> 4:     try &#123;</span><br><span class="line"> 5:         &#x2F;&#x2F; 记录过程中，是否发生线程中断</span><br><span class="line"> 6:         boolean interrupted &#x3D; false;</span><br><span class="line"> 7:         &#x2F;*</span><br><span class="line"> 8:          * 自旋过程，其实就是一个死循环而已</span><br><span class="line"> 9:          *&#x2F;</span><br><span class="line">10:         for (;;) &#123;</span><br><span class="line">11:             &#x2F;&#x2F; 当前线程的前驱节点</span><br><span class="line">12:             final Node p &#x3D; node.predecessor();</span><br><span class="line">13:             &#x2F;&#x2F; 当前线程的前驱节点是头结点，且同步状态成功</span><br><span class="line">14:             if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">15:                 setHead(node);</span><br><span class="line">16:                 p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">17:                 failed &#x3D; false;</span><br><span class="line">18:                 return interrupted;</span><br><span class="line">19:             &#125;</span><br><span class="line">20:             &#x2F;&#x2F; 获取失败，线程等待--具体后面介绍</span><br><span class="line">21:             if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">22:                     parkAndCheckInterrupt())</span><br><span class="line">23:                 interrupted &#x3D; true;</span><br><span class="line">24:         &#125;</span><br><span class="line">25:     &#125; finally &#123;</span><br><span class="line">26:         &#x2F;&#x2F; 获取同步状态发生异常，取消获取。</span><br><span class="line">27:         if (failed)</span><br><span class="line">28:             cancelAcquire(node);</span><br><span class="line">29:     &#125;</span><br><span class="line">30: &#125;</span><br></pre></td></tr></table></figure>

<h6 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> 1: private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line"> 2:     &#x2F;&#x2F; 获得前一个节点的等待状态</span><br><span class="line"> 3:     int ws &#x3D; pred.waitStatus;</span><br><span class="line"> 4:     if (ws &#x3D;&#x3D; Node.SIGNAL) &#x2F;&#x2F;  Node.SIGNAL</span><br><span class="line"> 5:         &#x2F;*</span><br><span class="line"> 6:          * This node has already set status asking a release</span><br><span class="line"> 7:          * to signal it, so it can safely park.</span><br><span class="line"> 8:          *&#x2F;</span><br><span class="line"> 9:         return true;</span><br><span class="line">10:     if (ws &gt; 0) &#123; &#x2F;&#x2F; Node.CANCEL</span><br><span class="line">11:         &#x2F;*</span><br><span class="line">12:          * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">13:          * indicate retry.</span><br><span class="line">14:          *&#x2F;</span><br><span class="line">15:         do &#123;</span><br><span class="line">16:             node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class="line">17:         &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">18:         pred.next &#x3D; node;</span><br><span class="line">19:     &#125; else &#123; &#x2F;&#x2F; 0 或者 Node.PROPAGATE</span><br><span class="line">20:         &#x2F;*</span><br><span class="line">21:          * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">22:          * need a signal, but don&#39;t park yet.  Caller will need to</span><br><span class="line">23:          * retry to make sure it cannot acquire before parking.</span><br><span class="line">24:          *&#x2F;</span><br><span class="line">25:         compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">26:     &#125;</span><br><span class="line">27:     return false;</span><br><span class="line">28: &#125;</span><br></pre></td></tr></table></figure>

<h6 id="cancelAcquire"><a href="#cancelAcquire" class="headerlink" title="cancelAcquire"></a>cancelAcquire</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> 1: private void cancelAcquire(Node node) &#123;</span><br><span class="line"> 2:     &#x2F;&#x2F; Ignore if node doesn&#39;t exist</span><br><span class="line"> 3:     if (node &#x3D;&#x3D; null)</span><br><span class="line"> 4:         return;</span><br><span class="line"> 5: </span><br><span class="line"> 6:     node.thread &#x3D; null;</span><br><span class="line"> 7: </span><br><span class="line"> 8:     &#x2F;&#x2F; Skip cancelled predecessors</span><br><span class="line"> 9:     Node pred &#x3D; node.prev;</span><br><span class="line">10:     while (pred.waitStatus &gt; 0)</span><br><span class="line">11:         node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class="line">12: </span><br><span class="line">13:     &#x2F;&#x2F; predNext is the apparent node to unsplice. CASes below will</span><br><span class="line">14:     &#x2F;&#x2F; fail if not, in which case, we lost race vs another cancel</span><br><span class="line">15:     &#x2F;&#x2F; or signal, so no further action is necessary.</span><br><span class="line">16:     Node predNext &#x3D; pred.next;</span><br><span class="line">17: </span><br><span class="line">18:     &#x2F;&#x2F; Can use unconditional write instead of CAS here.</span><br><span class="line">19:     &#x2F;&#x2F; After this atomic step, other Nodes can skip past us.</span><br><span class="line">20:     &#x2F;&#x2F; Before, we are free of interference from other threads.</span><br><span class="line">21:     node.waitStatus &#x3D; Node.CANCELLED;</span><br><span class="line">22: </span><br><span class="line">23:     &#x2F;&#x2F; If we are the tail, remove ourselves.</span><br><span class="line">24:     if (node &#x3D;&#x3D; tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">25:         compareAndSetNext(pred, predNext, null);</span><br><span class="line">26:     &#125; else &#123;</span><br><span class="line">27:         &#x2F;&#x2F; If successor needs signal, try to set pred&#39;s next-link</span><br><span class="line">28:         &#x2F;&#x2F; so it will get one. Otherwise wake it up to propagate.</span><br><span class="line">29:         int ws;</span><br><span class="line">30:         if (pred !&#x3D; head &amp;&amp;</span><br><span class="line">31:             ((ws &#x3D; pred.waitStatus) &#x3D;&#x3D; Node.SIGNAL ||</span><br><span class="line">32:              (ws &lt;&#x3D; 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">33:             pred.thread !&#x3D; null) &#123;</span><br><span class="line">34:             Node next &#x3D; node.next;</span><br><span class="line">35:             if (next !&#x3D; null &amp;&amp; next.waitStatus &lt;&#x3D; 0)</span><br><span class="line">36:                 compareAndSetNext(pred, predNext, next);</span><br><span class="line">37:         &#125; else &#123;</span><br><span class="line">38:             unparkSuccessor(node);</span><br><span class="line">39:         &#125;</span><br><span class="line">40: </span><br><span class="line">41:         node.next &#x3D; node; &#x2F;&#x2F; help GC</span><br><span class="line">42:     &#125;</span><br><span class="line">43: &#125;</span><br></pre></td></tr></table></figure>

<h5 id="独占式获取响应中断"><a href="#独占式获取响应中断" class="headerlink" title="独占式获取响应中断"></a>独占式获取响应中断</h5><p>AQS 提供了<code>acquire(int arg)</code> 方法，以供独占式获取同步状态，但是该方法<strong>对中断不响应</strong>，对线程进行中断操作后，该线程会依然位于CLH同步队列中，等待着获取同步状态。为了<strong>响应中断</strong>，AQS 提供了 <code>#acquireInterruptibly(int arg)</code> 方法。该方法在等待获取同步状态时，如果当前线程被中断了，会<strong>立刻</strong>响应中断，并抛出 InterruptedException 异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireInterruptibly(int arg) throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先，校验该线程是否已经中断了，如果是，则抛出InterruptedException 异常。</li>
<li>然后，调用 <code>#tryAcquire(int arg)</code> 方法，尝试获取同步状态，如果获取成功，则直接返回。</li>
<li>最后，调用 <code>#doAcquireInterruptibly(int arg)</code> 方法，自旋直到获得同步状态成功，<strong>或线程中断抛出 InterruptedException 异常</strong>。</li>
<li>应该不仅仅 help gc</li>
</ul>
<h6 id="doAcquireInterruptibly"><a href="#doAcquireInterruptibly" class="headerlink" title="doAcquireInterruptibly"></a>doAcquireInterruptibly</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireInterruptibly(int arg)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    final Node node &#x3D; addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                failed &#x3D; false;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                throw new InterruptedException(); &#x2F;&#x2F; &lt;1&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它与 <code>#acquire(int arg)</code> 方法<strong>仅有两个差别</strong>：</p>
<ol>
<li>方法声明抛出 InterruptedException 异常。</li>
<li>在中断方法处不再是使用 <code>interrupted</code> 标志，而是直接抛出 InterruptedException 异常，即 <code>&lt;1&gt;</code> 处。</li>
</ol>
<h5 id="独占式超时获取"><a href="#独占式超时获取" class="headerlink" title="独占式超时获取"></a>独占式超时获取</h5><p>AQS 除了提供上面两个方法外，还提供了一个增强版的方法 <code>#tryAcquireNanos(int arg, long nanos)</code> 。该方法为 <code>#acquireInterruptibly(int arg)</code> 方法的进一步增强，它除了响应中断外，还有<strong>超时控制</strong>。即如果当前线程没有在指定时间内获取同步状态，则会返回 false ，否则返回 true 。</p>
<p><strong>流程图</strong>如下：</p>
<p><img src="https://gitee.com/chenssy/blog-home/raw/master/image/sijava/2018120811002.png" alt="流程图"></p>
<p><strong>代码</strong>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean tryAcquireNanos(int arg, long nanosTimeout)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    return tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先，校验该线程是否已经中断了，如果是，则抛出InterruptedException 异常。</li>
<li>然后，调用 <code>#tryAcquire(int arg)</code> 方法，尝试获取同步状态，如果获取成功，则直接返回。</li>
<li>最后，调用 <code>#tryAcquireNanos(int arg)</code> 方法，自旋直到获得同步状态成功，或线程中断抛出 InterruptedException 异常，<strong>或超过指定时间返回获取同步状态失败</strong>。</li>
</ul>
<h6 id="tryAcquireNanos"><a href="#tryAcquireNanos" class="headerlink" title="tryAcquireNanos"></a>tryAcquireNanos</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">static final long spinForTimeoutThreshold &#x3D; 1000L;</span><br><span class="line"></span><br><span class="line">  1: private boolean doAcquireNanos(int arg, long nanosTimeout)</span><br><span class="line">  2:         throws InterruptedException &#123;</span><br><span class="line">  3:     &#x2F;&#x2F; nanosTimeout &lt;&#x3D; 0</span><br><span class="line">  4:     if (nanosTimeout &lt;&#x3D; 0L)</span><br><span class="line">  5:         return false;</span><br><span class="line">  6:     &#x2F;&#x2F; 超时时间</span><br><span class="line">  7:     final long deadline &#x3D; System.nanoTime() + nanosTimeout;</span><br><span class="line">  8:     &#x2F;&#x2F; 新增 Node 节点</span><br><span class="line">  9:     final Node node &#x3D; addWaiter(Node.EXCLUSIVE);</span><br><span class="line"> 10:     boolean failed &#x3D; true;</span><br><span class="line"> 11:     try &#123;</span><br><span class="line"> 12:         &#x2F;&#x2F; 自旋</span><br><span class="line"> 13:         for (;;) &#123;</span><br><span class="line"> 14:             final Node p &#x3D; node.predecessor();</span><br><span class="line"> 15:             &#x2F;&#x2F; 获取同步状态成功</span><br><span class="line"> 16:             if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line"> 17:                 setHead(node);</span><br><span class="line"> 18:                 p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line"> 19:                 failed &#x3D; false;</span><br><span class="line"> 20:                 return true;</span><br><span class="line"> 21:             &#125;</span><br><span class="line"> 22:             &#x2F;*</span><br><span class="line"> 23:              * 获取失败，做超时、中断判断</span><br><span class="line"> 24:              *&#x2F;</span><br><span class="line"> 25:             &#x2F;&#x2F; 重新计算需要休眠的时间</span><br><span class="line"> 26:             nanosTimeout &#x3D; deadline - System.nanoTime();</span><br><span class="line"> 27:             &#x2F;&#x2F; 已经超时，返回false</span><br><span class="line"> 28:             if (nanosTimeout &lt;&#x3D; 0L)</span><br><span class="line"> 29:                 return false;</span><br><span class="line"> 30:             &#x2F;&#x2F; 如果没有超时，则等待nanosTimeout纳秒</span><br><span class="line"> 31:             &#x2F;&#x2F; 注：该线程会直接从LockSupport.parkNanos中返回，</span><br><span class="line"> 32:             &#x2F;&#x2F; LockSupport 为 J.U.C 提供的一个阻塞和唤醒的工具类，后面做详细介绍</span><br><span class="line"> 33:             if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line"> 34:                     nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line"> 35:                 LockSupport.parkNanos(this, nanosTimeout);</span><br><span class="line"> 36:             &#x2F;&#x2F; 线程是否已经中断了</span><br><span class="line"> 37:             if (Thread.interrupted())</span><br><span class="line"> 38:                 throw new InterruptedException();</span><br><span class="line"> 39:         &#125;</span><br><span class="line"> 40:     &#125; finally &#123;</span><br><span class="line"> 41:         if (failed)</span><br><span class="line"> 42:             cancelAcquire(node);</span><br><span class="line"> 43:     &#125;</span><br><span class="line"> 44: &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>因为是在 <code>#doAcquireInterruptibly(int arg)</code> 方法的基础上，做了<strong>超时</strong>控制的增强，所以<strong>相同部分，我们直接跳过</strong>。</li>
<li>第 3 至 5 行：如果超时时间小于 0 ，直接返回 false ，已经超时。</li>
<li>第 7 行：计算最终超时时间 <code>deadline</code> 。</li>
<li>第 9 行：【相同，跳过】</li>
<li>第 10 行：【相同，跳过】</li>
<li>第 13 行：【相同，跳过】</li>
<li>第 14 行：【相同，跳过】</li>
<li>第 15 至 21 行：【相同，跳过】</li>
<li>第 26 行：重新计算<strong>剩余</strong>可获取同步状态的时间 <code>nanosTimeout</code> 。</li>
<li>第 27 至 29 行：如果剩余时间小于 0 ，直接返回 false ，已经超时。</li>
<li>第 33 行：【相同，跳过】</li>
<li>第 34 至 35 行：如果剩余时间大于 <code>spinForTimeoutThreshold</code> ，则调用 <code>LockSupport#parkNanos(Object blocker, long nanos)</code> 方法，休眠 <code>nanosTimeout</code> <strong>纳</strong>秒。否则，就不需要休眠了，直接进入<strong>快速自旋</strong>的过程。原因在于，<code>spinForTimeoutThreshold</code> 已经非常小了，<strong>非常短的时间等待无法做到十分精确</strong>，如果这时再次进行超时等待，相反会让 <code>nanosTimeout</code> 的超时从整体上面表现得不是那么精确。<strong>所以，在超时非常短的场景中，AQS 会进行无条件的快速自旋</strong>。</li>
<li>第 36 至 39 行：若线程已经中断了，抛出 InterruptedException 异常。</li>
<li>第 40 至 43 行：【相同，跳过】</li>
</ul>
<h5 id="独占式同步状态释放"><a href="#独占式同步状态释放" class="headerlink" title="独占式同步状态释放"></a>独占式同步状态释放</h5><p>当线程获取同步状态后，执行完相应逻辑后，就需要<strong>释放同步状态</strong>。AQS 提供了<code>#release(int arg)</code>方法，释放同步状态。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1: public final boolean release(int arg) &#123;</span><br><span class="line">2:     if (tryRelease(arg)) &#123;</span><br><span class="line">3:         Node h &#x3D; head;</span><br><span class="line">4:         if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">5:             unparkSuccessor(h);</span><br><span class="line">6:         return true;</span><br><span class="line">7:     &#125;</span><br><span class="line">8:     return false;</span><br><span class="line">9: &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第 2 行：调用 <code>#tryRelease(int arg)</code> 方法，去尝试释放同步状态，释放成功则设置锁状态并返回 true ，否则获取失败，返回 false 。同时，它们分别对应【第 3 至 6】和【第 8 行】的逻辑。</li>
<li>第 3 行：获得<strong>当前</strong>的 <code>head</code> ，避免并发问题。</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>这里稍微总结下：</p>
<blockquote>
<p>在 AQS 中维护着一个 FIFO 的同步队列。</p>
<ul>
<li>当线程获取同步状态失败后，则会加入到这个 CLH 同步队列的对尾，并一直保持着自旋。</li>
<li>在 CLH 同步队列中的线程在自旋时，会判断其前驱节点是否为首节点，如果为首节点则不断尝试获取同步状态，获取成功则退出CLH同步队列。</li>
<li>当线程执行完逻辑后，会释放同步状态，释放后会唤醒其后继节点。</li>
</ul>
</blockquote>
<h4 id="共享式"><a href="#共享式" class="headerlink" title="共享式"></a>共享式</h4><p>共享式与独占式的最主要区别在于，<strong>同一时刻</strong>：</p>
<ul>
<li>独占式只能有<strong>一个</strong>线程获取同步状态。</li>
<li>共享式可以有<strong>多个</strong>线程获取同步状态。</li>
</ul>
<p>例如，读操作可以有多个线程同时进行，而写操作同一时刻只能有一个线程进行写操作，其他操作都会被阻塞。参见 ReentrantReadWriteLock 。</p>
<h5 id="共享式同步状态获取"><a href="#共享式同步状态获取" class="headerlink" title="共享式同步状态获取"></a>共享式同步状态获取</h5><p>AQS 提供 <code>#acquireShared(int arg)</code> 方法，共享式获取同步状态。代码如下：</p>
<blockquote>
<p><code>#acquireShared(int arg)</code> 方法，对标 <code>#acquire(int arg)</code> 方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1: public final void acquireShared(int arg) &#123;</span><br><span class="line">2:     if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">3:         doAcquireShared(arg);</span><br><span class="line">4: &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第 2 行：调用 <code>#tryAcquireShared(int arg)</code> 方法，尝试获取同步状态，获取成功则设置锁状态并返回大于等于 0 ，否则获取失败，返回小于 0 。若获取成功，直接返回，<strong>不用线程阻塞</strong>，自旋直到获得同步状态成功。</li>
</ul>
<h6 id="doAcquireShared"><a href="#doAcquireShared" class="headerlink" title="doAcquireShared"></a>doAcquireShared</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> 1: private void doAcquireShared(int arg) &#123;</span><br><span class="line"> 2:     &#x2F;&#x2F; 共享式节点</span><br><span class="line"> 3:     final Node node &#x3D; addWaiter(Node.SHARED);</span><br><span class="line"> 4:     boolean failed &#x3D; true;</span><br><span class="line"> 5:     try &#123;</span><br><span class="line"> 6:         boolean interrupted &#x3D; false;</span><br><span class="line"> 7:         for (;;) &#123;</span><br><span class="line"> 8:             &#x2F;&#x2F; 前驱节点</span><br><span class="line"> 9:             final Node p &#x3D; node.predecessor();</span><br><span class="line">10:             &#x2F;&#x2F; 如果其前驱节点，获取同步状态</span><br><span class="line">11:             if (p &#x3D;&#x3D; head) &#123;</span><br><span class="line">12:                 &#x2F;&#x2F; 尝试获取同步</span><br><span class="line">13:                 int r &#x3D; tryAcquireShared(arg);</span><br><span class="line">14:                 if (r &gt;&#x3D; 0) &#123;</span><br><span class="line">15:                     setHeadAndPropagate(node, r);</span><br><span class="line">16:                     p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">17:                     if (interrupted)</span><br><span class="line">18:                         selfInterrupt();</span><br><span class="line">19:                     failed &#x3D; false;</span><br><span class="line">20:                     return;</span><br><span class="line">21:                 &#125;</span><br><span class="line">22:             &#125;</span><br><span class="line">23:             if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">24:                     parkAndCheckInterrupt())</span><br><span class="line">25:                 interrupted &#x3D; true;</span><br><span class="line">26:         &#125;</span><br><span class="line">27:     &#125; finally &#123;</span><br><span class="line">28:         if (failed)</span><br><span class="line">29:             cancelAcquire(node);</span><br><span class="line">30:     &#125;</span><br><span class="line">31: &#125;</span><br></pre></td></tr></table></figure>

<h6 id="setHeadAndPropagate"><a href="#setHeadAndPropagate" class="headerlink" title="setHeadAndPropagate"></a>setHeadAndPropagate</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> 1: private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line"> 2:     Node h &#x3D; head; &#x2F;&#x2F; Record old head for check below</span><br><span class="line"> 3:     setHead(node);</span><br><span class="line"> 4:     &#x2F;*</span><br><span class="line"> 5:      * Try to signal next queued node if:</span><br><span class="line"> 6:      *   Propagation was indicated by caller,</span><br><span class="line"> 7:      *     or was recorded (as h.waitStatus either before</span><br><span class="line"> 8:      *     or after setHead) by a previous operation</span><br><span class="line"> 9:      *     (note: this uses sign-check of waitStatus because</span><br><span class="line">10:      *      PROPAGATE status may transition to SIGNAL.)</span><br><span class="line">11:      * and</span><br><span class="line">12:      *   The next node is waiting in shared mode,</span><br><span class="line">13:      *     or we don&#39;t know, because it appears null</span><br><span class="line">14:      *</span><br><span class="line">15:      * The conservatism in both of these checks may cause</span><br><span class="line">16:      * unnecessary wake-ups, but only when there are multiple</span><br><span class="line">17:      * racing acquires&#x2F;releases, so most need signals now or soon</span><br><span class="line">18:      * anyway.</span><br><span class="line">19:      *&#x2F;</span><br><span class="line">20:     if (propagate &gt; 0 || h &#x3D;&#x3D; null || h.waitStatus &lt; 0 ||</span><br><span class="line">21:         (h &#x3D; head) &#x3D;&#x3D; null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">22:         Node s &#x3D; node.next;</span><br><span class="line">23:         if (s &#x3D;&#x3D; null || s.isShared())</span><br><span class="line">24:             doReleaseShared();</span><br><span class="line">25:     &#125;</span><br><span class="line">26: &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第 2 行：记录<strong>原来</strong>的<strong>首</strong>节点 <code>h</code> 。</li>
<li>第 3 行：调用 <code>#setHead(Node node)</code> 方法，设置 <code>node</code> 为<strong>新</strong>的<strong>首</strong>节点。</li>
<li>第 20 行：<code>propagate &gt; 0</code> 代码块，说明同步状态还能被其他线程获取。</li>
<li>第 20 至 21 行：判断<strong>原来</strong>的或者<strong>新</strong>的<strong>首</strong>节点，<strong>等待状态</strong>为 <code>Node.PROPAGATE</code> 或者 <code>Node.SIGNAL</code> 时，可以继续向下<strong>唤醒</strong>。</li>
<li>第 23 行：调用 <code>Node#isShared()</code> 方法，判断<strong>下</strong>一个节点为<strong>共享式</strong>获取同步状态。</li>
<li>第 24 行：调用 <code>#doReleaseShared()</code> 方法，唤醒后续的<strong>共享式</strong>获取同步状态的节点。</li>
</ul>
<h5 id="共享式获取响应中断"><a href="#共享式获取响应中断" class="headerlink" title="共享式获取响应中断"></a>共享式获取响应中断</h5><p><code>#acquireSharedInterruptibly(int arg)</code> 方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    final Node node &#x3D; addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            if (p &#x3D;&#x3D; head) &#123;</span><br><span class="line">                int r &#x3D; tryAcquireShared(arg);</span><br><span class="line">                if (r &gt;&#x3D; 0) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                    failed &#x3D; false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="共享式超时获取"><a href="#共享式超时获取" class="headerlink" title="共享式超时获取"></a>共享式超时获取</h5><p><code>#tryAcquireSharedNanos(int arg, long nanosTimeout)</code> 方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    return tryAcquireShared(arg) &gt;&#x3D; 0 ||</span><br><span class="line">        doAcquireSharedNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean doAcquireSharedNanos(int arg, long nanosTimeout)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (nanosTimeout &lt;&#x3D; 0L)</span><br><span class="line">        return false;</span><br><span class="line">    final long deadline &#x3D; System.nanoTime() + nanosTimeout;</span><br><span class="line">    final Node node &#x3D; addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            if (p &#x3D;&#x3D; head) &#123;</span><br><span class="line">                int r &#x3D; tryAcquireShared(arg);</span><br><span class="line">                if (r &gt;&#x3D; 0) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                    failed &#x3D; false;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nanosTimeout &#x3D; deadline - System.nanoTime();</span><br><span class="line">            if (nanosTimeout &lt;&#x3D; 0L)</span><br><span class="line">                return false;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(this, nanosTimeout);</span><br><span class="line">            if (Thread.interrupted())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="共享式同步状态释放"><a href="#共享式同步状态释放" class="headerlink" title="共享式同步状态释放"></a>共享式同步状态释放</h5><p>当线程获取同步状态后，执行完相应逻辑后，就需要<strong>释放同步状态</strong>。AQS 提供了<code>#releaseShared(int arg)</code>方法，释放同步状态。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1: public final boolean releaseShared(int arg) &#123;</span><br><span class="line">2:     if (tryReleaseShared(arg)) &#123;</span><br><span class="line">3:         doReleaseShared();</span><br><span class="line">4:         return true;</span><br><span class="line">5:     &#125;</span><br><span class="line">6:     return false;</span><br><span class="line">7: &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第 2 行：调用 <code>#tryReleaseShared(int arg)</code> 方法，去尝试释放同步状态，释放成功则设置锁状态并返回 true ，否则获取失败，返回 false 。同时，它们分别对应【第 3 至 5】和【第 6 行】的逻辑。</li>
<li>第 3 行：调用 <code>#doReleaseShared()</code> 方法，唤醒后续的<strong>共享式</strong>获取同步状态的节点。</li>
</ul>
<h6 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared"></a>doReleaseShared</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> 1: private void doReleaseShared() &#123;</span><br><span class="line"> 2:     &#x2F;*</span><br><span class="line"> 3:      * Ensure that a release propagates, even if there are other</span><br><span class="line"> 4:      * in-progress acquires&#x2F;releases.  This proceeds in the usual</span><br><span class="line"> 5:      * way of trying to unparkSuccessor of head if it needs</span><br><span class="line"> 6:      * signal. But if it does not, status is set to PROPAGATE to</span><br><span class="line"> 7:      * ensure that upon release, propagation continues.</span><br><span class="line"> 8:      * Additionally, we must loop in case a new node is added</span><br><span class="line"> 9:      * while we are doing this. Also, unlike other uses of</span><br><span class="line">10:      * unparkSuccessor, we need to know if CAS to reset status</span><br><span class="line">11:      * fails, if so rechecking.</span><br><span class="line">12:      *&#x2F;</span><br><span class="line">13:     for (;;) &#123;</span><br><span class="line">14:         Node h &#x3D; head;</span><br><span class="line">15:         if (h !&#x3D; null &amp;&amp; h !&#x3D; tail) &#123;</span><br><span class="line">16:             int ws &#x3D; h.waitStatus;</span><br><span class="line">17:             if (ws &#x3D;&#x3D; Node.SIGNAL) &#123;</span><br><span class="line">18:                 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">19:                     continue;            &#x2F;&#x2F; loop to recheck cases</span><br><span class="line">20:                 unparkSuccessor(h);</span><br><span class="line">21:             &#125;</span><br><span class="line">22:             else if (ws &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">23:                      !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">24:                 continue;                &#x2F;&#x2F; loop on failed CAS</span><br><span class="line">25:         &#125;</span><br><span class="line">26:         if (h &#x3D;&#x3D; head)                   &#x2F;&#x2F; loop if head changed</span><br><span class="line">27:             break;</span><br><span class="line">28:     &#125;</span><br><span class="line">29: &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="AQS：阻塞和唤醒线程"><a href="#AQS：阻塞和唤醒线程" class="headerlink" title="AQS：阻塞和唤醒线程"></a>AQS：阻塞和唤醒线程</h3><h4 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a>parkAndCheckInterrupt</h4><p>在线程获取同步状态时，如果获取失败，则加入 CLH 同步队列，通过通过自旋的方式不断获取同步状态，但是在自旋的过程中，则需要判断当前线程是否需要阻塞，其主要方法在<code>acquireQueued(int arg)</code> ，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ... 省略前面无关代码</span><br><span class="line"></span><br><span class="line">if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted &#x3D; true;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ... 省略前面无关代码</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在获取同步状态失败后，线程并不是立马进行阻塞，需要检查该线程的状态，检查状态的方法为 <code>#shouldParkAfterFailedAcquire(Node pred, Node node)</code>方法，该方法主要靠前驱节点判断当前线程<strong>是否应该被阻塞</strong>。</p>
</li>
<li><p>如果 <code>#shouldParkAfterFailedAcquire(Node pred, Node node)</code> 方法返回 <strong>true</strong> ，则调用<code>parkAndCheckInterrupt()</code> 方法，阻塞当前线程。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    LockSupport.park(this);</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，在线程被唤醒时，调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread#interrupted()</span><br></pre></td></tr></table></figure>

<p>方法，返回当前线程是否被打断，并清理打断状态。所以，实际上，线程被唤醒</p>
<p>有两种情况：</p>
<ul>
<li>第一种，当前节点(线程)的<strong>前序节点</strong>释放同步状态时，唤醒了该线程。</li>
<li>第二种，当前线程被打断导致唤醒。</li>
</ul>
</li>
</ul>
<h4 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h4><p>当线程释放同步状态后，则需要唤醒该线程的后继节点。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">            unparkSuccessor(h); &#x2F;&#x2F; 唤醒后继节点</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>调用 <code>unparkSuccessor(Node node)</code> 方法，唤醒<strong>后继</strong>节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    &#x2F;&#x2F;当前节点状态</span><br><span class="line">    int ws &#x3D; node.waitStatus;</span><br><span class="line">    &#x2F;&#x2F;当前状态 &lt; 0 则设置为 0</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当前节点的后继节点</span><br><span class="line">    Node s &#x3D; node.next;</span><br><span class="line">    &#x2F;&#x2F;后继节点为null或者其状态 &gt; 0 (超时或者被中断了)</span><br><span class="line">    if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F;从tail节点来找可用节点</span><br><span class="line">        for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)</span><br><span class="line">            if (t.waitStatus &lt;&#x3D; 0)</span><br><span class="line">                s &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;唤醒后继节点</span><br><span class="line">    if (s !&#x3D; null)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可能会存在当前线程的<strong>后继</strong>节点为 <code>null</code>，例如：超时、被中断的情况。如果遇到这种情况了，则需要跳过该节点。<ul>
<li>但是，为何是从 <code>tail</code> 尾节点开始，而不是从 <code>node.next</code> 开始呢？原因在于，取消的 <code>node.next.next</code> 指向的是 <code>node.next</code> 自己。如果顺序遍历下去，会导致<strong>死循环</strong>。所以此时，<strong>只能</strong>采用 <code>tail</code> 回溯的办法，找到第一个( 不是<strong>最新</strong>找到的，而是<strong>最前序的</strong> )可用的线程。</li>
<li>再但是，为什么取消的 <code>node.next.next</code> 指向的是 <code>node.next</code> 自己呢？在 <code>#cancelAcquire(Node node)</code> 的末尾，<code>node.next = node;</code> 代码块，取消的 <code>node</code> 节点，将其 <code>next</code> 指向了自己。</li>
</ul>
</li>
<li>最后，调用 <code>LockSupport的unpark(Thread thread)</code> 方法，唤醒该线程。</li>
</ul>
</li>
</ul>
<h4 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h4><p>从上面我可以看到，当需要阻塞或者唤醒一个线程的时候，AQS 都是使用 LockSupport 这个工具类来完成的。</p>
<blockquote>
<p>LockSupport 是用来创建锁和其他同步类的基本线程阻塞原语。</p>
</blockquote>
<p>每个使用 LockSupport 的线程都会与一个许可与之关联：</p>
<ul>
<li>如果该许可可用，并且可在进程中使用，则调用 <code>#park(...)</code> 将会立即返回，否则可能阻塞。</li>
<li>如果许可尚不可用，则可以调用 <code>#unpark(...)</code> 使其可用。</li>
<li>但是，注意许可<strong>不可重入</strong>，也就是说只能调用一次 <code>park(...)</code> 方法，否则会一直阻塞。</li>
</ul>
<p>LockSupport 定义了一系列以 <code>park</code> 开头的方法来阻塞当前线程，<code>unpark(Thread thread)</code> 方法来唤醒一个被阻塞的线程。如下图所示：</p>
<p><img src="https://gitee.com/chenssy/blog-home/raw/master/image/sijava/2018120812001.png" alt="方法"></p>
<ul>
<li><code>park(Object blocker)</code> 方法的blocker参数，主要是用来标识当前线程在等待的对象，该对象主要用于<strong>问题排查和系统监控</strong>。</li>
<li>park 方法和 <code>unpark(Thread thread)</code> 方法，都是<strong>成对出现</strong>的。同时 <code>unpark(Thread thread)</code> 方法，必须要在 park 方法执行之后执行。当然，并不是说没有调用 <code>unpark(Thread thread)</code> 方法的线程就会一直阻塞，park 有一个方法，它是带了时间戳的 <code>#parkNanos(long nanos)</code> 方法：为了线程调度禁用当前线程，最多等待指定的等待时间，除非许可可用。</li>
</ul>
<h4 id="park"><a href="#park" class="headerlink" title="park"></a>park</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void park() &#123;</span><br><span class="line">    UNSAFE.park(false, 0L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="unpark"><a href="#unpark" class="headerlink" title="unpark"></a>unpark</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void unpark(Thread thread) &#123;</span><br><span class="line">    if (thread !&#x3D; null)</span><br><span class="line">        UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>内部的实现都是通过 <code>sun.misc.Unsafe</code> 来实现的，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; UNSAFE.java</span><br><span class="line">public native void park(boolean var1, long var2);</span><br><span class="line">public native void unpark(Object var1);</span><br></pre></td></tr></table></figure>

<p>两个都是 <code>native</code> 本地方法。Unsafe 是一个比较危险的类，主要是用于执行低级别、不安全的方法集合。尽管这个类和所有的方法都是公开的（使用 <code>public</code> 进行修饰），但是这个类的使用仍然受限，你无法在自己的 Java 程序中直接使用该类，因为只有授信的代码才能获得该类的实例。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81/">源码</a></div><div class="post_share"><div class="social-share" data-image="http://hankz.oss-cn-hangzhou.aliyuncs.com/wallhaven-39em6d.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/kele.png" target="_blank"><img class="post-qr-code-img" src="/img/kele.png" alt="觉得还不错，请他喝一瓶可乐"/></a><div class="post-qr-code-desc">觉得还不错，请他喝一瓶可乐</div></li><li class="reward-item"><a href="/img/ali.jpg" target="_blank"><img class="post-qr-code-img" src="/img/ali.jpg" alt="雪碧也是可以的"/></a><div class="post-qr-code-desc">雪碧也是可以的</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/03/07/%E4%BB%80%E4%B9%88%E6%98%AFspring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><img class="prev-cover" src="http://hankz.oss-cn-hangzhou.aliyuncs.com/wallhaven-6oj73l.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">什么是spring循环依赖?源码分析</div></div></a></div><div class="next-post pull-right"><a href="/2021/03/03/Github%E9%AA%9A%E6%93%8D%E4%BD%9C/"><img class="next-cover" src="http://hankz.oss-cn-hangzhou.aliyuncs.com/wallhaven-6oj73l.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Github骚操作</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/07/09/什么是CAS原理/" title="什么是CAS"><img class="cover" src="http://hankz.oss-cn-hangzhou.aliyuncs.com/wallhaven-39em6d.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-09</div><div class="title">什么是CAS</div></div></a></div><div><a href="/2022/05/08/手写mybatis第四篇/" title="手写mybatis第四篇"><img class="cover" src="https://zzc-sso.oss-cn-hangzhou.aliyuncs.com/bolg/wallhaven-pk8l5m.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-08</div><div class="title">手写mybatis第四篇</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/tx2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">章志成</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/gump12138"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/cooper12138" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:994739211@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">延迟满足</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS"><span class="toc-number">1.</span> <span class="toc-text">AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">1.2.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.</span> <span class="toc-text">同步状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97"><span class="toc-number">1.4.</span> <span class="toc-text">同步队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">主要内置方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%EF%BC%9ACLH-%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97"><span class="toc-number">2.</span> <span class="toc-text">AQS：CLH 同步队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node"><span class="toc-number">2.2.</span> <span class="toc-text">Node</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E5%88%97"><span class="toc-number">2.3.</span> <span class="toc-text">入列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E5%88%97"><span class="toc-number">2.4.</span> <span class="toc-text">出列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%EF%BC%9A%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81%E7%9A%84%E8%8E%B7%E5%8F%96%E4%B8%8E%E9%87%8A%E6%94%BE"><span class="toc-number">3.</span> <span class="toc-text">AQS：同步状态的获取与释放</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8B%AC%E5%8D%A0%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">独占式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8B%AC%E5%8D%A0%E5%BC%8F%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81%E8%8E%B7%E5%8F%96"><span class="toc-number">3.1.1.</span> <span class="toc-text">独占式同步状态获取</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#acquireQueued"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">acquireQueued</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#shouldParkAfterFailedAcquire"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">shouldParkAfterFailedAcquire</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#cancelAcquire"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">cancelAcquire</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8B%AC%E5%8D%A0%E5%BC%8F%E8%8E%B7%E5%8F%96%E5%93%8D%E5%BA%94%E4%B8%AD%E6%96%AD"><span class="toc-number">3.1.2.</span> <span class="toc-text">独占式获取响应中断</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#doAcquireInterruptibly"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">doAcquireInterruptibly</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8B%AC%E5%8D%A0%E5%BC%8F%E8%B6%85%E6%97%B6%E8%8E%B7%E5%8F%96"><span class="toc-number">3.1.3.</span> <span class="toc-text">独占式超时获取</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#tryAcquireNanos"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">tryAcquireNanos</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8B%AC%E5%8D%A0%E5%BC%8F%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81%E9%87%8A%E6%94%BE"><span class="toc-number">3.1.4.</span> <span class="toc-text">独占式同步状态释放</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.1.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">共享式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%BC%8F%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81%E8%8E%B7%E5%8F%96"><span class="toc-number">3.2.1.</span> <span class="toc-text">共享式同步状态获取</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#doAcquireShared"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">doAcquireShared</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#setHeadAndPropagate"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">setHeadAndPropagate</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%BC%8F%E8%8E%B7%E5%8F%96%E5%93%8D%E5%BA%94%E4%B8%AD%E6%96%AD"><span class="toc-number">3.2.2.</span> <span class="toc-text">共享式获取响应中断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%BC%8F%E8%B6%85%E6%97%B6%E8%8E%B7%E5%8F%96"><span class="toc-number">3.2.3.</span> <span class="toc-text">共享式超时获取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%BC%8F%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81%E9%87%8A%E6%94%BE"><span class="toc-number">3.2.4.</span> <span class="toc-text">共享式同步状态释放</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#doReleaseShared"><span class="toc-number">3.2.4.1.</span> <span class="toc-text">doReleaseShared</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%EF%BC%9A%E9%98%BB%E5%A1%9E%E5%92%8C%E5%94%A4%E9%86%92%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">AQS：阻塞和唤醒线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#parkAndCheckInterrupt"><span class="toc-number">4.1.</span> <span class="toc-text">parkAndCheckInterrupt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unparkSuccessor"><span class="toc-number">4.2.</span> <span class="toc-text">unparkSuccessor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LockSupport"><span class="toc-number">4.3.</span> <span class="toc-text">LockSupport</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#park"><span class="toc-number">4.4.</span> <span class="toc-text">park</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unpark"><span class="toc-number">4.5.</span> <span class="toc-text">unpark</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">4.6.</span> <span class="toc-text">实现原理</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/05/08/%E6%89%8B%E5%86%99mybatis%E7%AC%AC%E5%9B%9B%E7%AF%87/" title="手写mybatis第四篇"><img src="https://zzc-sso.oss-cn-hangzhou.aliyuncs.com/bolg/wallhaven-pk8l5m.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="手写mybatis第四篇"/></a><div class="content"><a class="title" href="/2022/05/08/%E6%89%8B%E5%86%99mybatis%E7%AC%AC%E5%9B%9B%E7%AF%87/" title="手写mybatis第四篇">手写mybatis第四篇</a><time datetime="2022-05-08T06:58:47.000Z" title="发表于 2022-05-08 14:58:47">2022-05-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/11/%E6%89%8B%E5%86%99mybatis%E7%AC%AC%E4%B8%89%E7%AF%87/" title="手写mybatis第三篇"><img src="https://zzc-sso.oss-cn-hangzhou.aliyuncs.com/bolg/wallhaven-73zz29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="手写mybatis第三篇"/></a><div class="content"><a class="title" href="/2022/04/11/%E6%89%8B%E5%86%99mybatis%E7%AC%AC%E4%B8%89%E7%AF%87/" title="手写mybatis第三篇">手写mybatis第三篇</a><time datetime="2022-04-11T03:39:41.000Z" title="发表于 2022-04-11 11:39:41">2022-04-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/10/%E6%89%8B%E5%86%99mybatis%E7%AC%AC%E4%BA%8C%E7%AF%87/" title="手写mybatis第二篇"><img src="http://hankz.oss-cn-hangzhou.aliyuncs.com/wallhaven-72pj33.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="手写mybatis第二篇"/></a><div class="content"><a class="title" href="/2022/04/10/%E6%89%8B%E5%86%99mybatis%E7%AC%AC%E4%BA%8C%E7%AF%87/" title="手写mybatis第二篇">手写mybatis第二篇</a><time datetime="2022-04-10T08:23:17.000Z" title="发表于 2022-04-10 16:23:17">2022-04-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E7%AC%AC%E4%B8%80%E7%AF%87/" title="JVM与Java体系结构"><img src="https://zzc-sso.oss-cn-hangzhou.aliyuncs.com/bolg/JVM/src%3Dhttp___upload-images.jianshu.io_upload_images_15462057-05caf5645086f1cf.png%26refer%3Dhttp___upload-images.jianshu.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM与Java体系结构"/></a><div class="content"><a class="title" href="/2022/04/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E7%AC%AC%E4%B8%80%E7%AF%87/" title="JVM与Java体系结构">JVM与Java体系结构</a><time datetime="2022-04-10T07:17:31.000Z" title="发表于 2022-04-10 15:17:31">2022-04-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/10/%E6%89%8B%E5%86%99mybatis%E7%AC%AC%E4%B8%80%E7%AF%87/" title="手写mybatis第一篇"><img src="https://zzc-sso.oss-cn-hangzhou.aliyuncs.com/bolg/%E7%AA%97%E5%8F%B0%20%E6%97%A5%E8%90%BD%20%E5%A5%B3%E5%AD%A9%20%C3%A8%20%E4%B9%A6%E6%9C%AC%20alena%20aenami%204k%E5%A3%81%E7%BA%B8_%E5%BD%BC%E5%B2%B8%E5%9B%BE%E7%BD%91.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="手写mybatis第一篇"/></a><div class="content"><a class="title" href="/2022/04/10/%E6%89%8B%E5%86%99mybatis%E7%AC%AC%E4%B8%80%E7%AF%87/" title="手写mybatis第一篇">手写mybatis第一篇</a><time datetime="2022-04-10T07:17:31.000Z" title="发表于 2022-04-10 15:17:31">2022-04-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 章志成</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a  target="_blank" rel="noopener" href="http://hankz.cc/">一个cv大师</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'rX8EGp1QDIbaOBer0HPXb4wr-gzGzoHsz',
      appKey: 'zYi2FKT3jfoRihSzwUQkzwd3',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.17.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=monsterid'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://rX8EGp1Q.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'rX8EGp1QDIbaOBer0HPXb4wr-gzGzoHsz',
        "X-LC-Key": 'zYi2FKT3jfoRihSzwUQkzwd3',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><div class="aplayer no-destroy" data-id="84943176" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-autoplay="false" data-theme="#2980b9" data-loop="all" data-order="random" data-preload="auto" data-volume="0.4" data-mutex="true" data-listFolded="true" data-listmaxheight="340px" data-storagename="metingjs" muted></div><div class="aplayer no-destroy" data-id="https://music.163.com/playlist?id=84943176&userid=77272308" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-autoplay="true" data-theme="#2980b9" data-loop="all" data-order="random" data-preload="auto" data-volume="0.4" data-mutex="true" data-listFolded="true" data-listmaxheight="340px" data-storagename="metingjs" muted></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script>(function(d, w, c) {
    w.ChatraID = 'K3d9XytKCJ4u5JfPd';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>